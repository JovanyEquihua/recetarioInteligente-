
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Calificacion
 * 
 */
export type Calificacion = $Result.DefaultSelection<Prisma.$CalificacionPayload>
/**
 * Model Comentario
 * 
 */
export type Comentario = $Result.DefaultSelection<Prisma.$ComentarioPayload>
/**
 * Model Cuenta
 * 
 */
export type Cuenta = $Result.DefaultSelection<Prisma.$CuentaPayload>
/**
 * Model Favorito
 * 
 */
export type Favorito = $Result.DefaultSelection<Prisma.$FavoritoPayload>
/**
 * Model Ingrediente
 * 
 */
export type Ingrediente = $Result.DefaultSelection<Prisma.$IngredientePayload>
/**
 * Model ListaCompra
 * 
 */
export type ListaCompra = $Result.DefaultSelection<Prisma.$ListaCompraPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Receta
 * 
 */
export type Receta = $Result.DefaultSelection<Prisma.$RecetaPayload>
/**
 * Model RecetaIngrediente
 * 
 */
export type RecetaIngrediente = $Result.DefaultSelection<Prisma.$RecetaIngredientePayload>
/**
 * Model Reporte
 * 
 */
export type Reporte = $Result.DefaultSelection<Prisma.$ReportePayload>
/**
 * Model TipoComida
 * 
 */
export type TipoComida = $Result.DefaultSelection<Prisma.$TipoComidaPayload>
/**
 * Model TipoSabor
 * 
 */
export type TipoSabor = $Result.DefaultSelection<Prisma.$TipoSaborPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DificultadReceta: {
  Facil: 'Facil',
  Medio: 'Medio',
  Dificil: 'Dificil'
};

export type DificultadReceta = (typeof DificultadReceta)[keyof typeof DificultadReceta]


export const NombreSabor: {
  Dulce: 'Dulce',
  Salado: 'Salado',
  Amargo: 'Amargo',
  Acido: 'Acido',
  Umami: 'Umami'
};

export type NombreSabor = (typeof NombreSabor)[keyof typeof NombreSabor]


export const TipoIngrediente: {
  Verduras: 'Verduras',
  Frutas: 'Frutas',
  Cereales: 'Cereales',
  Alimentos_de_origen_animal: 'Alimentos_de_origen_animal',
  Leguminosas: 'Leguminosas'
};

export type TipoIngrediente = (typeof TipoIngrediente)[keyof typeof TipoIngrediente]


export const UserRole: {
  ADMIN: 'ADMIN',
  USUARIO: 'USUARIO'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type DificultadReceta = $Enums.DificultadReceta

export const DificultadReceta: typeof $Enums.DificultadReceta

export type NombreSabor = $Enums.NombreSabor

export const NombreSabor: typeof $Enums.NombreSabor

export type TipoIngrediente = $Enums.TipoIngrediente

export const TipoIngrediente: typeof $Enums.TipoIngrediente

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Calificacions
 * const calificacions = await prisma.calificacion.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Calificacions
   * const calificacions = await prisma.calificacion.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.calificacion`: Exposes CRUD operations for the **Calificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calificacions
    * const calificacions = await prisma.calificacion.findMany()
    * ```
    */
  get calificacion(): Prisma.CalificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **Comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.ComentarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cuenta`: Exposes CRUD operations for the **Cuenta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuentas
    * const cuentas = await prisma.cuenta.findMany()
    * ```
    */
  get cuenta(): Prisma.CuentaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorito`: Exposes CRUD operations for the **Favorito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favoritos
    * const favoritos = await prisma.favorito.findMany()
    * ```
    */
  get favorito(): Prisma.FavoritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ingrediente`: Exposes CRUD operations for the **Ingrediente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredientes
    * const ingredientes = await prisma.ingrediente.findMany()
    * ```
    */
  get ingrediente(): Prisma.IngredienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listaCompra`: Exposes CRUD operations for the **ListaCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListaCompras
    * const listaCompras = await prisma.listaCompra.findMany()
    * ```
    */
  get listaCompra(): Prisma.ListaCompraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receta`: Exposes CRUD operations for the **Receta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recetas
    * const recetas = await prisma.receta.findMany()
    * ```
    */
  get receta(): Prisma.RecetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recetaIngrediente`: Exposes CRUD operations for the **RecetaIngrediente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecetaIngredientes
    * const recetaIngredientes = await prisma.recetaIngrediente.findMany()
    * ```
    */
  get recetaIngrediente(): Prisma.RecetaIngredienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reporte`: Exposes CRUD operations for the **Reporte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reportes
    * const reportes = await prisma.reporte.findMany()
    * ```
    */
  get reporte(): Prisma.ReporteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoComida`: Exposes CRUD operations for the **TipoComida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoComidas
    * const tipoComidas = await prisma.tipoComida.findMany()
    * ```
    */
  get tipoComida(): Prisma.TipoComidaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoSabor`: Exposes CRUD operations for the **TipoSabor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoSabors
    * const tipoSabors = await prisma.tipoSabor.findMany()
    * ```
    */
  get tipoSabor(): Prisma.TipoSaborDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Calificacion: 'Calificacion',
    Comentario: 'Comentario',
    Cuenta: 'Cuenta',
    Favorito: 'Favorito',
    Ingrediente: 'Ingrediente',
    ListaCompra: 'ListaCompra',
    Notificacion: 'Notificacion',
    PasswordResetToken: 'PasswordResetToken',
    Receta: 'Receta',
    RecetaIngrediente: 'RecetaIngrediente',
    Reporte: 'Reporte',
    TipoComida: 'TipoComida',
    TipoSabor: 'TipoSabor',
    Usuario: 'Usuario',
    VerificationToken: 'VerificationToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "calificacion" | "comentario" | "cuenta" | "favorito" | "ingrediente" | "listaCompra" | "notificacion" | "passwordResetToken" | "receta" | "recetaIngrediente" | "reporte" | "tipoComida" | "tipoSabor" | "usuario" | "verificationToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Calificacion: {
        payload: Prisma.$CalificacionPayload<ExtArgs>
        fields: Prisma.CalificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          findFirst: {
            args: Prisma.CalificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          findMany: {
            args: Prisma.CalificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          create: {
            args: Prisma.CalificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          createMany: {
            args: Prisma.CalificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          delete: {
            args: Prisma.CalificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          update: {
            args: Prisma.CalificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          deleteMany: {
            args: Prisma.CalificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>[]
          }
          upsert: {
            args: Prisma.CalificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalificacionPayload>
          }
          aggregate: {
            args: Prisma.CalificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalificacion>
          }
          groupBy: {
            args: Prisma.CalificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalificacionCountArgs<ExtArgs>
            result: $Utils.Optional<CalificacionCountAggregateOutputType> | number
          }
        }
      }
      Comentario: {
        payload: Prisma.$ComentarioPayload<ExtArgs>
        fields: Prisma.ComentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findFirst: {
            args: Prisma.ComentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findMany: {
            args: Prisma.ComentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          create: {
            args: Prisma.ComentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          createMany: {
            args: Prisma.ComentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComentarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          delete: {
            args: Prisma.ComentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          update: {
            args: Prisma.ComentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComentarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          upsert: {
            args: Prisma.ComentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.ComentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      Cuenta: {
        payload: Prisma.$CuentaPayload<ExtArgs>
        fields: Prisma.CuentaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CuentaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuentaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          findFirst: {
            args: Prisma.CuentaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuentaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          findMany: {
            args: Prisma.CuentaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>[]
          }
          create: {
            args: Prisma.CuentaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          createMany: {
            args: Prisma.CuentaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CuentaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>[]
          }
          delete: {
            args: Prisma.CuentaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          update: {
            args: Prisma.CuentaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          deleteMany: {
            args: Prisma.CuentaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CuentaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CuentaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>[]
          }
          upsert: {
            args: Prisma.CuentaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuentaPayload>
          }
          aggregate: {
            args: Prisma.CuentaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCuenta>
          }
          groupBy: {
            args: Prisma.CuentaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CuentaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CuentaCountArgs<ExtArgs>
            result: $Utils.Optional<CuentaCountAggregateOutputType> | number
          }
        }
      }
      Favorito: {
        payload: Prisma.$FavoritoPayload<ExtArgs>
        fields: Prisma.FavoritoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoritoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoritoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          findFirst: {
            args: Prisma.FavoritoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoritoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          findMany: {
            args: Prisma.FavoritoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          create: {
            args: Prisma.FavoritoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          createMany: {
            args: Prisma.FavoritoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoritoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          delete: {
            args: Prisma.FavoritoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          update: {
            args: Prisma.FavoritoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          deleteMany: {
            args: Prisma.FavoritoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoritoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoritoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          upsert: {
            args: Prisma.FavoritoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          aggregate: {
            args: Prisma.FavoritoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorito>
          }
          groupBy: {
            args: Prisma.FavoritoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoritoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoritoCountArgs<ExtArgs>
            result: $Utils.Optional<FavoritoCountAggregateOutputType> | number
          }
        }
      }
      Ingrediente: {
        payload: Prisma.$IngredientePayload<ExtArgs>
        fields: Prisma.IngredienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          findFirst: {
            args: Prisma.IngredienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          findMany: {
            args: Prisma.IngredienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>[]
          }
          create: {
            args: Prisma.IngredienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          createMany: {
            args: Prisma.IngredienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngredienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>[]
          }
          delete: {
            args: Prisma.IngredienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          update: {
            args: Prisma.IngredienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          deleteMany: {
            args: Prisma.IngredienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngredienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngredienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>[]
          }
          upsert: {
            args: Prisma.IngredienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientePayload>
          }
          aggregate: {
            args: Prisma.IngredienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngrediente>
          }
          groupBy: {
            args: Prisma.IngredienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngredienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredienteCountArgs<ExtArgs>
            result: $Utils.Optional<IngredienteCountAggregateOutputType> | number
          }
        }
      }
      ListaCompra: {
        payload: Prisma.$ListaCompraPayload<ExtArgs>
        fields: Prisma.ListaCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListaCompraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListaCompraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          findFirst: {
            args: Prisma.ListaCompraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListaCompraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          findMany: {
            args: Prisma.ListaCompraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>[]
          }
          create: {
            args: Prisma.ListaCompraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          createMany: {
            args: Prisma.ListaCompraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListaCompraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>[]
          }
          delete: {
            args: Prisma.ListaCompraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          update: {
            args: Prisma.ListaCompraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          deleteMany: {
            args: Prisma.ListaCompraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListaCompraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListaCompraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>[]
          }
          upsert: {
            args: Prisma.ListaCompraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaCompraPayload>
          }
          aggregate: {
            args: Prisma.ListaCompraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListaCompra>
          }
          groupBy: {
            args: Prisma.ListaCompraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListaCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListaCompraCountArgs<ExtArgs>
            result: $Utils.Optional<ListaCompraCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Receta: {
        payload: Prisma.$RecetaPayload<ExtArgs>
        fields: Prisma.RecetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          findFirst: {
            args: Prisma.RecetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          findMany: {
            args: Prisma.RecetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>[]
          }
          create: {
            args: Prisma.RecetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          createMany: {
            args: Prisma.RecetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>[]
          }
          delete: {
            args: Prisma.RecetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          update: {
            args: Prisma.RecetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          deleteMany: {
            args: Prisma.RecetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecetaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>[]
          }
          upsert: {
            args: Prisma.RecetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaPayload>
          }
          aggregate: {
            args: Prisma.RecetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceta>
          }
          groupBy: {
            args: Prisma.RecetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecetaCountArgs<ExtArgs>
            result: $Utils.Optional<RecetaCountAggregateOutputType> | number
          }
        }
      }
      RecetaIngrediente: {
        payload: Prisma.$RecetaIngredientePayload<ExtArgs>
        fields: Prisma.RecetaIngredienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecetaIngredienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecetaIngredienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          findFirst: {
            args: Prisma.RecetaIngredienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecetaIngredienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          findMany: {
            args: Prisma.RecetaIngredienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>[]
          }
          create: {
            args: Prisma.RecetaIngredienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          createMany: {
            args: Prisma.RecetaIngredienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecetaIngredienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>[]
          }
          delete: {
            args: Prisma.RecetaIngredienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          update: {
            args: Prisma.RecetaIngredienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          deleteMany: {
            args: Prisma.RecetaIngredienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecetaIngredienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecetaIngredienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>[]
          }
          upsert: {
            args: Prisma.RecetaIngredienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecetaIngredientePayload>
          }
          aggregate: {
            args: Prisma.RecetaIngredienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecetaIngrediente>
          }
          groupBy: {
            args: Prisma.RecetaIngredienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecetaIngredienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecetaIngredienteCountArgs<ExtArgs>
            result: $Utils.Optional<RecetaIngredienteCountAggregateOutputType> | number
          }
        }
      }
      Reporte: {
        payload: Prisma.$ReportePayload<ExtArgs>
        fields: Prisma.ReporteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReporteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReporteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          findFirst: {
            args: Prisma.ReporteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReporteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          findMany: {
            args: Prisma.ReporteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>[]
          }
          create: {
            args: Prisma.ReporteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          createMany: {
            args: Prisma.ReporteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReporteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>[]
          }
          delete: {
            args: Prisma.ReporteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          update: {
            args: Prisma.ReporteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          deleteMany: {
            args: Prisma.ReporteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReporteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReporteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>[]
          }
          upsert: {
            args: Prisma.ReporteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportePayload>
          }
          aggregate: {
            args: Prisma.ReporteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReporte>
          }
          groupBy: {
            args: Prisma.ReporteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReporteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReporteCountArgs<ExtArgs>
            result: $Utils.Optional<ReporteCountAggregateOutputType> | number
          }
        }
      }
      TipoComida: {
        payload: Prisma.$TipoComidaPayload<ExtArgs>
        fields: Prisma.TipoComidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoComidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoComidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          findFirst: {
            args: Prisma.TipoComidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoComidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          findMany: {
            args: Prisma.TipoComidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>[]
          }
          create: {
            args: Prisma.TipoComidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          createMany: {
            args: Prisma.TipoComidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoComidaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>[]
          }
          delete: {
            args: Prisma.TipoComidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          update: {
            args: Prisma.TipoComidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          deleteMany: {
            args: Prisma.TipoComidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoComidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoComidaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>[]
          }
          upsert: {
            args: Prisma.TipoComidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoComidaPayload>
          }
          aggregate: {
            args: Prisma.TipoComidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoComida>
          }
          groupBy: {
            args: Prisma.TipoComidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoComidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoComidaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoComidaCountAggregateOutputType> | number
          }
        }
      }
      TipoSabor: {
        payload: Prisma.$TipoSaborPayload<ExtArgs>
        fields: Prisma.TipoSaborFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoSaborFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoSaborFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          findFirst: {
            args: Prisma.TipoSaborFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoSaborFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          findMany: {
            args: Prisma.TipoSaborFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>[]
          }
          create: {
            args: Prisma.TipoSaborCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          createMany: {
            args: Prisma.TipoSaborCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoSaborCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>[]
          }
          delete: {
            args: Prisma.TipoSaborDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          update: {
            args: Prisma.TipoSaborUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          deleteMany: {
            args: Prisma.TipoSaborDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoSaborUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoSaborUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>[]
          }
          upsert: {
            args: Prisma.TipoSaborUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSaborPayload>
          }
          aggregate: {
            args: Prisma.TipoSaborAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoSabor>
          }
          groupBy: {
            args: Prisma.TipoSaborGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoSaborGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoSaborCountArgs<ExtArgs>
            result: $Utils.Optional<TipoSaborCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    calificacion?: CalificacionOmit
    comentario?: ComentarioOmit
    cuenta?: CuentaOmit
    favorito?: FavoritoOmit
    ingrediente?: IngredienteOmit
    listaCompra?: ListaCompraOmit
    notificacion?: NotificacionOmit
    passwordResetToken?: PasswordResetTokenOmit
    receta?: RecetaOmit
    recetaIngrediente?: RecetaIngredienteOmit
    reporte?: ReporteOmit
    tipoComida?: TipoComidaOmit
    tipoSabor?: TipoSaborOmit
    usuario?: UsuarioOmit
    verificationToken?: VerificationTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ComentarioCountOutputType
   */

  export type ComentarioCountOutputType = {
    Reporte: number
  }

  export type ComentarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reporte?: boolean | ComentarioCountOutputTypeCountReporteArgs
  }

  // Custom InputTypes
  /**
   * ComentarioCountOutputType without action
   */
  export type ComentarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioCountOutputType
     */
    select?: ComentarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComentarioCountOutputType without action
   */
  export type ComentarioCountOutputTypeCountReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteWhereInput
  }


  /**
   * Count Type IngredienteCountOutputType
   */

  export type IngredienteCountOutputType = {
    RecetaIngrediente: number
  }

  export type IngredienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecetaIngrediente?: boolean | IngredienteCountOutputTypeCountRecetaIngredienteArgs
  }

  // Custom InputTypes
  /**
   * IngredienteCountOutputType without action
   */
  export type IngredienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredienteCountOutputType
     */
    select?: IngredienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IngredienteCountOutputType without action
   */
  export type IngredienteCountOutputTypeCountRecetaIngredienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaIngredienteWhereInput
  }


  /**
   * Count Type RecetaCountOutputType
   */

  export type RecetaCountOutputType = {
    Calificacion: number
    Comentario: number
    Favorito: number
    RecetaIngrediente: number
    Reporte: number
  }

  export type RecetaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Calificacion?: boolean | RecetaCountOutputTypeCountCalificacionArgs
    Comentario?: boolean | RecetaCountOutputTypeCountComentarioArgs
    Favorito?: boolean | RecetaCountOutputTypeCountFavoritoArgs
    RecetaIngrediente?: boolean | RecetaCountOutputTypeCountRecetaIngredienteArgs
    Reporte?: boolean | RecetaCountOutputTypeCountReporteArgs
  }

  // Custom InputTypes
  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaCountOutputType
     */
    select?: RecetaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountCalificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountFavoritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountRecetaIngredienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaIngredienteWhereInput
  }

  /**
   * RecetaCountOutputType without action
   */
  export type RecetaCountOutputTypeCountReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteWhereInput
  }


  /**
   * Count Type TipoComidaCountOutputType
   */

  export type TipoComidaCountOutputType = {
    Receta: number
  }

  export type TipoComidaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | TipoComidaCountOutputTypeCountRecetaArgs
  }

  // Custom InputTypes
  /**
   * TipoComidaCountOutputType without action
   */
  export type TipoComidaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComidaCountOutputType
     */
    select?: TipoComidaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoComidaCountOutputType without action
   */
  export type TipoComidaCountOutputTypeCountRecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaWhereInput
  }


  /**
   * Count Type TipoSaborCountOutputType
   */

  export type TipoSaborCountOutputType = {
    Receta: number
  }

  export type TipoSaborCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | TipoSaborCountOutputTypeCountRecetaArgs
  }

  // Custom InputTypes
  /**
   * TipoSaborCountOutputType without action
   */
  export type TipoSaborCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSaborCountOutputType
     */
    select?: TipoSaborCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoSaborCountOutputType without action
   */
  export type TipoSaborCountOutputTypeCountRecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    Calificacion: number
    Comentario: number
    Cuenta: number
    Favorito: number
    ListaCompra: number
    Notificacion: number
    Receta: number
    Reporte: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Calificacion?: boolean | UsuarioCountOutputTypeCountCalificacionArgs
    Comentario?: boolean | UsuarioCountOutputTypeCountComentarioArgs
    Cuenta?: boolean | UsuarioCountOutputTypeCountCuentaArgs
    Favorito?: boolean | UsuarioCountOutputTypeCountFavoritoArgs
    ListaCompra?: boolean | UsuarioCountOutputTypeCountListaCompraArgs
    Notificacion?: boolean | UsuarioCountOutputTypeCountNotificacionArgs
    Receta?: boolean | UsuarioCountOutputTypeCountRecetaArgs
    Reporte?: boolean | UsuarioCountOutputTypeCountReporteArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCalificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCuentaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuentaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountFavoritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountListaCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListaCompraWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Calificacion
   */

  export type AggregateCalificacion = {
    _count: CalificacionCountAggregateOutputType | null
    _avg: CalificacionAvgAggregateOutputType | null
    _sum: CalificacionSumAggregateOutputType | null
    _min: CalificacionMinAggregateOutputType | null
    _max: CalificacionMaxAggregateOutputType | null
  }

  export type CalificacionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    puntuacion: number | null
  }

  export type CalificacionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    puntuacion: number | null
  }

  export type CalificacionMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    puntuacion: number | null
    fechaCalificacion: Date | null
  }

  export type CalificacionMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    puntuacion: number | null
    fechaCalificacion: Date | null
  }

  export type CalificacionCountAggregateOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    puntuacion: number
    fechaCalificacion: number
    _all: number
  }


  export type CalificacionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    puntuacion?: true
  }

  export type CalificacionSumAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    puntuacion?: true
  }

  export type CalificacionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    puntuacion?: true
    fechaCalificacion?: true
  }

  export type CalificacionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    puntuacion?: true
    fechaCalificacion?: true
  }

  export type CalificacionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    puntuacion?: true
    fechaCalificacion?: true
    _all?: true
  }

  export type CalificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calificacion to aggregate.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calificacions
    **/
    _count?: true | CalificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalificacionMaxAggregateInputType
  }

  export type GetCalificacionAggregateType<T extends CalificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateCalificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalificacion[P]>
      : GetScalarType<T[P], AggregateCalificacion[P]>
  }




  export type CalificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithAggregationInput | CalificacionOrderByWithAggregationInput[]
    by: CalificacionScalarFieldEnum[] | CalificacionScalarFieldEnum
    having?: CalificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalificacionCountAggregateInputType | true
    _avg?: CalificacionAvgAggregateInputType
    _sum?: CalificacionSumAggregateInputType
    _min?: CalificacionMinAggregateInputType
    _max?: CalificacionMaxAggregateInputType
  }

  export type CalificacionGroupByOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    puntuacion: number
    fechaCalificacion: Date
    _count: CalificacionCountAggregateOutputType | null
    _avg: CalificacionAvgAggregateOutputType | null
    _sum: CalificacionSumAggregateOutputType | null
    _min: CalificacionMinAggregateOutputType | null
    _max: CalificacionMaxAggregateOutputType | null
  }

  type GetCalificacionGroupByPayload<T extends CalificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalificacionGroupByOutputType[P]>
            : GetScalarType<T[P], CalificacionGroupByOutputType[P]>
        }
      >
    >


  export type CalificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    puntuacion?: boolean
    fechaCalificacion?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    puntuacion?: boolean
    fechaCalificacion?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    puntuacion?: boolean
    fechaCalificacion?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificacion"]>

  export type CalificacionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    puntuacion?: boolean
    fechaCalificacion?: boolean
  }

  export type CalificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "recetaId" | "puntuacion" | "fechaCalificacion", ExtArgs["result"]["calificacion"]>
  export type CalificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CalificacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CalificacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CalificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calificacion"
    objects: {
      Receta: Prisma.$RecetaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      recetaId: number
      puntuacion: number
      fechaCalificacion: Date
    }, ExtArgs["result"]["calificacion"]>
    composites: {}
  }

  type CalificacionGetPayload<S extends boolean | null | undefined | CalificacionDefaultArgs> = $Result.GetResult<Prisma.$CalificacionPayload, S>

  type CalificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalificacionCountAggregateInputType | true
    }

  export interface CalificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calificacion'], meta: { name: 'Calificacion' } }
    /**
     * Find zero or one Calificacion that matches the filter.
     * @param {CalificacionFindUniqueArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalificacionFindUniqueArgs>(args: SelectSubset<T, CalificacionFindUniqueArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalificacionFindUniqueOrThrowArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, CalificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindFirstArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalificacionFindFirstArgs>(args?: SelectSubset<T, CalificacionFindFirstArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindFirstOrThrowArgs} args - Arguments to find a Calificacion
     * @example
     * // Get one Calificacion
     * const calificacion = await prisma.calificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, CalificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calificacions
     * const calificacions = await prisma.calificacion.findMany()
     * 
     * // Get first 10 Calificacions
     * const calificacions = await prisma.calificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalificacionFindManyArgs>(args?: SelectSubset<T, CalificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calificacion.
     * @param {CalificacionCreateArgs} args - Arguments to create a Calificacion.
     * @example
     * // Create one Calificacion
     * const Calificacion = await prisma.calificacion.create({
     *   data: {
     *     // ... data to create a Calificacion
     *   }
     * })
     * 
     */
    create<T extends CalificacionCreateArgs>(args: SelectSubset<T, CalificacionCreateArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calificacions.
     * @param {CalificacionCreateManyArgs} args - Arguments to create many Calificacions.
     * @example
     * // Create many Calificacions
     * const calificacion = await prisma.calificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalificacionCreateManyArgs>(args?: SelectSubset<T, CalificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calificacions and returns the data saved in the database.
     * @param {CalificacionCreateManyAndReturnArgs} args - Arguments to create many Calificacions.
     * @example
     * // Create many Calificacions
     * const calificacion = await prisma.calificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calificacions and only return the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, CalificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calificacion.
     * @param {CalificacionDeleteArgs} args - Arguments to delete one Calificacion.
     * @example
     * // Delete one Calificacion
     * const Calificacion = await prisma.calificacion.delete({
     *   where: {
     *     // ... filter to delete one Calificacion
     *   }
     * })
     * 
     */
    delete<T extends CalificacionDeleteArgs>(args: SelectSubset<T, CalificacionDeleteArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calificacion.
     * @param {CalificacionUpdateArgs} args - Arguments to update one Calificacion.
     * @example
     * // Update one Calificacion
     * const calificacion = await prisma.calificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalificacionUpdateArgs>(args: SelectSubset<T, CalificacionUpdateArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calificacions.
     * @param {CalificacionDeleteManyArgs} args - Arguments to filter Calificacions to delete.
     * @example
     * // Delete a few Calificacions
     * const { count } = await prisma.calificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalificacionDeleteManyArgs>(args?: SelectSubset<T, CalificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calificacions
     * const calificacion = await prisma.calificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalificacionUpdateManyArgs>(args: SelectSubset<T, CalificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificacions and returns the data updated in the database.
     * @param {CalificacionUpdateManyAndReturnArgs} args - Arguments to update many Calificacions.
     * @example
     * // Update many Calificacions
     * const calificacion = await prisma.calificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calificacions and only return the `id`
     * const calificacionWithIdOnly = await prisma.calificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, CalificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calificacion.
     * @param {CalificacionUpsertArgs} args - Arguments to update or create a Calificacion.
     * @example
     * // Update or create a Calificacion
     * const calificacion = await prisma.calificacion.upsert({
     *   create: {
     *     // ... data to create a Calificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calificacion we want to update
     *   }
     * })
     */
    upsert<T extends CalificacionUpsertArgs>(args: SelectSubset<T, CalificacionUpsertArgs<ExtArgs>>): Prisma__CalificacionClient<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionCountArgs} args - Arguments to filter Calificacions to count.
     * @example
     * // Count the number of Calificacions
     * const count = await prisma.calificacion.count({
     *   where: {
     *     // ... the filter for the Calificacions we want to count
     *   }
     * })
    **/
    count<T extends CalificacionCountArgs>(
      args?: Subset<T, CalificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalificacionAggregateArgs>(args: Subset<T, CalificacionAggregateArgs>): Prisma.PrismaPromise<GetCalificacionAggregateType<T>>

    /**
     * Group by Calificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalificacionGroupByArgs['orderBy'] }
        : { orderBy?: CalificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calificacion model
   */
  readonly fields: CalificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Receta<T extends RecetaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecetaDefaultArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calificacion model
   */
  interface CalificacionFieldRefs {
    readonly id: FieldRef<"Calificacion", 'Int'>
    readonly usuarioId: FieldRef<"Calificacion", 'Int'>
    readonly recetaId: FieldRef<"Calificacion", 'Int'>
    readonly puntuacion: FieldRef<"Calificacion", 'Int'>
    readonly fechaCalificacion: FieldRef<"Calificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calificacion findUnique
   */
  export type CalificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion findUniqueOrThrow
   */
  export type CalificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion findFirst
   */
  export type CalificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calificacions.
     */
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion findFirstOrThrow
   */
  export type CalificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacion to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calificacions.
     */
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion findMany
   */
  export type CalificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter, which Calificacions to fetch.
     */
    where?: CalificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calificacions to fetch.
     */
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calificacions.
     */
    cursor?: CalificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calificacions.
     */
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Calificacion create
   */
  export type CalificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Calificacion.
     */
    data: XOR<CalificacionCreateInput, CalificacionUncheckedCreateInput>
  }

  /**
   * Calificacion createMany
   */
  export type CalificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calificacions.
     */
    data: CalificacionCreateManyInput | CalificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Calificacion createManyAndReturn
   */
  export type CalificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Calificacions.
     */
    data: CalificacionCreateManyInput | CalificacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calificacion update
   */
  export type CalificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Calificacion.
     */
    data: XOR<CalificacionUpdateInput, CalificacionUncheckedUpdateInput>
    /**
     * Choose, which Calificacion to update.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion updateMany
   */
  export type CalificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calificacions.
     */
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyInput>
    /**
     * Filter which Calificacions to update
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to update.
     */
    limit?: number
  }

  /**
   * Calificacion updateManyAndReturn
   */
  export type CalificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * The data used to update Calificacions.
     */
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyInput>
    /**
     * Filter which Calificacions to update
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calificacion upsert
   */
  export type CalificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Calificacion to update in case it exists.
     */
    where: CalificacionWhereUniqueInput
    /**
     * In case the Calificacion found by the `where` argument doesn't exist, create a new Calificacion with this data.
     */
    create: XOR<CalificacionCreateInput, CalificacionUncheckedCreateInput>
    /**
     * In case the Calificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalificacionUpdateInput, CalificacionUncheckedUpdateInput>
  }

  /**
   * Calificacion delete
   */
  export type CalificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    /**
     * Filter which Calificacion to delete.
     */
    where: CalificacionWhereUniqueInput
  }

  /**
   * Calificacion deleteMany
   */
  export type CalificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calificacions to delete
     */
    where?: CalificacionWhereInput
    /**
     * Limit how many Calificacions to delete.
     */
    limit?: number
  }

  /**
   * Calificacion without action
   */
  export type CalificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
  }


  /**
   * Model Comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentario: string | null
    fechaComentario: Date | null
  }

  export type ComentarioMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentario: string | null
    fechaComentario: Date | null
  }

  export type ComentarioCountAggregateOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    comentario: number
    fechaComentario: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
  }

  export type ComentarioSumAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
  }

  export type ComentarioMinAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentario?: true
    fechaComentario?: true
  }

  export type ComentarioMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentario?: true
    fechaComentario?: true
  }

  export type ComentarioCountAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentario?: true
    fechaComentario?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentario to aggregate.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type ComentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithAggregationInput | ComentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: ComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    comentario: string
    fechaComentario: Date
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends ComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Reporte?: boolean | Comentario$ReporteArgs<ExtArgs>
    _count?: boolean | ComentarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type ComentarioSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentario?: boolean
    fechaComentario?: boolean
  }

  export type ComentarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "recetaId" | "comentario" | "fechaComentario", ExtArgs["result"]["comentario"]>
  export type ComentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Reporte?: boolean | Comentario$ReporteArgs<ExtArgs>
    _count?: boolean | ComentarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComentarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ComentarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comentario"
    objects: {
      Receta: Prisma.$RecetaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Reporte: Prisma.$ReportePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      recetaId: number
      comentario: string
      fechaComentario: Date
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type ComentarioGetPayload<S extends boolean | null | undefined | ComentarioDefaultArgs> = $Result.GetResult<Prisma.$ComentarioPayload, S>

  type ComentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComentarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface ComentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentario'], meta: { name: 'Comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {ComentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioFindUniqueArgs>(args: SelectSubset<T, ComentarioFindUniqueArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioFindFirstArgs>(args?: SelectSubset<T, ComentarioFindFirstArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioWithIdOnly = await prisma.comentario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComentarioFindManyArgs>(args?: SelectSubset<T, ComentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comentario.
     * @param {ComentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends ComentarioCreateArgs>(args: SelectSubset<T, ComentarioCreateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comentarios.
     * @param {ComentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioCreateManyArgs>(args?: SelectSubset<T, ComentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comentarios and returns the data saved in the database.
     * @param {ComentarioCreateManyAndReturnArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comentarios and only return the `id`
     * const comentarioWithIdOnly = await prisma.comentario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComentarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ComentarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comentario.
     * @param {ComentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends ComentarioDeleteArgs>(args: SelectSubset<T, ComentarioDeleteArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comentario.
     * @param {ComentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioUpdateArgs>(args: SelectSubset<T, ComentarioUpdateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioDeleteManyArgs>(args?: SelectSubset<T, ComentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioUpdateManyArgs>(args: SelectSubset<T, ComentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios and returns the data updated in the database.
     * @param {ComentarioUpdateManyAndReturnArgs} args - Arguments to update many Comentarios.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comentarios and only return the `id`
     * const comentarioWithIdOnly = await prisma.comentario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComentarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ComentarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comentario.
     * @param {ComentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioUpsertArgs>(args: SelectSubset<T, ComentarioUpsertArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentarioCountArgs>(
      args?: Subset<T, ComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comentario model
   */
  readonly fields: ComentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Receta<T extends RecetaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecetaDefaultArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Reporte<T extends Comentario$ReporteArgs<ExtArgs> = {}>(args?: Subset<T, Comentario$ReporteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comentario model
   */
  interface ComentarioFieldRefs {
    readonly id: FieldRef<"Comentario", 'Int'>
    readonly usuarioId: FieldRef<"Comentario", 'Int'>
    readonly recetaId: FieldRef<"Comentario", 'Int'>
    readonly comentario: FieldRef<"Comentario", 'String'>
    readonly fechaComentario: FieldRef<"Comentario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comentario findUnique
   */
  export type ComentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findUniqueOrThrow
   */
  export type ComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findFirst
   */
  export type ComentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findFirstOrThrow
   */
  export type ComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findMany
   */
  export type ComentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario create
   */
  export type ComentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentario.
     */
    data: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
  }

  /**
   * Comentario createMany
   */
  export type ComentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comentario createManyAndReturn
   */
  export type ComentarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comentario update
   */
  export type ComentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentario.
     */
    data: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
    /**
     * Choose, which Comentario to update.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario updateMany
   */
  export type ComentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
    /**
     * Limit how many Comentarios to update.
     */
    limit?: number
  }

  /**
   * Comentario updateManyAndReturn
   */
  export type ComentarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
    /**
     * Limit how many Comentarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comentario upsert
   */
  export type ComentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentario to update in case it exists.
     */
    where: ComentarioWhereUniqueInput
    /**
     * In case the Comentario found by the `where` argument doesn't exist, create a new Comentario with this data.
     */
    create: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
    /**
     * In case the Comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
  }

  /**
   * Comentario delete
   */
  export type ComentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter which Comentario to delete.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario deleteMany
   */
  export type ComentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentarioWhereInput
    /**
     * Limit how many Comentarios to delete.
     */
    limit?: number
  }

  /**
   * Comentario.Reporte
   */
  export type Comentario$ReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    where?: ReporteWhereInput
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    cursor?: ReporteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Comentario without action
   */
  export type ComentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
  }


  /**
   * Model Cuenta
   */

  export type AggregateCuenta = {
    _count: CuentaCountAggregateOutputType | null
    _avg: CuentaAvgAggregateOutputType | null
    _sum: CuentaSumAggregateOutputType | null
    _min: CuentaMinAggregateOutputType | null
    _max: CuentaMaxAggregateOutputType | null
  }

  export type CuentaAvgAggregateOutputType = {
    idUsuario: number | null
    expires_at: number | null
  }

  export type CuentaSumAggregateOutputType = {
    idUsuario: number | null
    expires_at: number | null
  }

  export type CuentaMinAggregateOutputType = {
    idUsuario: number | null
    tipo: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuentaMaxAggregateOutputType = {
    idUsuario: number | null
    tipo: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CuentaCountAggregateOutputType = {
    idUsuario: number
    tipo: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CuentaAvgAggregateInputType = {
    idUsuario?: true
    expires_at?: true
  }

  export type CuentaSumAggregateInputType = {
    idUsuario?: true
    expires_at?: true
  }

  export type CuentaMinAggregateInputType = {
    idUsuario?: true
    tipo?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuentaMaxAggregateInputType = {
    idUsuario?: true
    tipo?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CuentaCountAggregateInputType = {
    idUsuario?: true
    tipo?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CuentaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuenta to aggregate.
     */
    where?: CuentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuentas to fetch.
     */
    orderBy?: CuentaOrderByWithRelationInput | CuentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuentas
    **/
    _count?: true | CuentaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuentaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuentaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuentaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuentaMaxAggregateInputType
  }

  export type GetCuentaAggregateType<T extends CuentaAggregateArgs> = {
        [P in keyof T & keyof AggregateCuenta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuenta[P]>
      : GetScalarType<T[P], AggregateCuenta[P]>
  }




  export type CuentaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuentaWhereInput
    orderBy?: CuentaOrderByWithAggregationInput | CuentaOrderByWithAggregationInput[]
    by: CuentaScalarFieldEnum[] | CuentaScalarFieldEnum
    having?: CuentaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuentaCountAggregateInputType | true
    _avg?: CuentaAvgAggregateInputType
    _sum?: CuentaSumAggregateInputType
    _min?: CuentaMinAggregateInputType
    _max?: CuentaMaxAggregateInputType
  }

  export type CuentaGroupByOutputType = {
    idUsuario: number
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: CuentaCountAggregateOutputType | null
    _avg: CuentaAvgAggregateOutputType | null
    _sum: CuentaSumAggregateOutputType | null
    _min: CuentaMinAggregateOutputType | null
    _max: CuentaMaxAggregateOutputType | null
  }

  type GetCuentaGroupByPayload<T extends CuentaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuentaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuentaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuentaGroupByOutputType[P]>
            : GetScalarType<T[P], CuentaGroupByOutputType[P]>
        }
      >
    >


  export type CuentaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    tipo?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuenta"]>

  export type CuentaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    tipo?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuenta"]>

  export type CuentaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    tipo?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuenta"]>

  export type CuentaSelectScalar = {
    idUsuario?: boolean
    tipo?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CuentaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idUsuario" | "tipo" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["cuenta"]>
  export type CuentaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CuentaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CuentaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CuentaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cuenta"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idUsuario: number
      tipo: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cuenta"]>
    composites: {}
  }

  type CuentaGetPayload<S extends boolean | null | undefined | CuentaDefaultArgs> = $Result.GetResult<Prisma.$CuentaPayload, S>

  type CuentaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CuentaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CuentaCountAggregateInputType | true
    }

  export interface CuentaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuenta'], meta: { name: 'Cuenta' } }
    /**
     * Find zero or one Cuenta that matches the filter.
     * @param {CuentaFindUniqueArgs} args - Arguments to find a Cuenta
     * @example
     * // Get one Cuenta
     * const cuenta = await prisma.cuenta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CuentaFindUniqueArgs>(args: SelectSubset<T, CuentaFindUniqueArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cuenta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CuentaFindUniqueOrThrowArgs} args - Arguments to find a Cuenta
     * @example
     * // Get one Cuenta
     * const cuenta = await prisma.cuenta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CuentaFindUniqueOrThrowArgs>(args: SelectSubset<T, CuentaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cuenta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaFindFirstArgs} args - Arguments to find a Cuenta
     * @example
     * // Get one Cuenta
     * const cuenta = await prisma.cuenta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CuentaFindFirstArgs>(args?: SelectSubset<T, CuentaFindFirstArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cuenta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaFindFirstOrThrowArgs} args - Arguments to find a Cuenta
     * @example
     * // Get one Cuenta
     * const cuenta = await prisma.cuenta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CuentaFindFirstOrThrowArgs>(args?: SelectSubset<T, CuentaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuentas
     * const cuentas = await prisma.cuenta.findMany()
     * 
     * // Get first 10 Cuentas
     * const cuentas = await prisma.cuenta.findMany({ take: 10 })
     * 
     * // Only select the `idUsuario`
     * const cuentaWithIdUsuarioOnly = await prisma.cuenta.findMany({ select: { idUsuario: true } })
     * 
     */
    findMany<T extends CuentaFindManyArgs>(args?: SelectSubset<T, CuentaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cuenta.
     * @param {CuentaCreateArgs} args - Arguments to create a Cuenta.
     * @example
     * // Create one Cuenta
     * const Cuenta = await prisma.cuenta.create({
     *   data: {
     *     // ... data to create a Cuenta
     *   }
     * })
     * 
     */
    create<T extends CuentaCreateArgs>(args: SelectSubset<T, CuentaCreateArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cuentas.
     * @param {CuentaCreateManyArgs} args - Arguments to create many Cuentas.
     * @example
     * // Create many Cuentas
     * const cuenta = await prisma.cuenta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CuentaCreateManyArgs>(args?: SelectSubset<T, CuentaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cuentas and returns the data saved in the database.
     * @param {CuentaCreateManyAndReturnArgs} args - Arguments to create many Cuentas.
     * @example
     * // Create many Cuentas
     * const cuenta = await prisma.cuenta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cuentas and only return the `idUsuario`
     * const cuentaWithIdUsuarioOnly = await prisma.cuenta.createManyAndReturn({
     *   select: { idUsuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CuentaCreateManyAndReturnArgs>(args?: SelectSubset<T, CuentaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cuenta.
     * @param {CuentaDeleteArgs} args - Arguments to delete one Cuenta.
     * @example
     * // Delete one Cuenta
     * const Cuenta = await prisma.cuenta.delete({
     *   where: {
     *     // ... filter to delete one Cuenta
     *   }
     * })
     * 
     */
    delete<T extends CuentaDeleteArgs>(args: SelectSubset<T, CuentaDeleteArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cuenta.
     * @param {CuentaUpdateArgs} args - Arguments to update one Cuenta.
     * @example
     * // Update one Cuenta
     * const cuenta = await prisma.cuenta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CuentaUpdateArgs>(args: SelectSubset<T, CuentaUpdateArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cuentas.
     * @param {CuentaDeleteManyArgs} args - Arguments to filter Cuentas to delete.
     * @example
     * // Delete a few Cuentas
     * const { count } = await prisma.cuenta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CuentaDeleteManyArgs>(args?: SelectSubset<T, CuentaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuentas
     * const cuenta = await prisma.cuenta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CuentaUpdateManyArgs>(args: SelectSubset<T, CuentaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuentas and returns the data updated in the database.
     * @param {CuentaUpdateManyAndReturnArgs} args - Arguments to update many Cuentas.
     * @example
     * // Update many Cuentas
     * const cuenta = await prisma.cuenta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cuentas and only return the `idUsuario`
     * const cuentaWithIdUsuarioOnly = await prisma.cuenta.updateManyAndReturn({
     *   select: { idUsuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CuentaUpdateManyAndReturnArgs>(args: SelectSubset<T, CuentaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cuenta.
     * @param {CuentaUpsertArgs} args - Arguments to update or create a Cuenta.
     * @example
     * // Update or create a Cuenta
     * const cuenta = await prisma.cuenta.upsert({
     *   create: {
     *     // ... data to create a Cuenta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuenta we want to update
     *   }
     * })
     */
    upsert<T extends CuentaUpsertArgs>(args: SelectSubset<T, CuentaUpsertArgs<ExtArgs>>): Prisma__CuentaClient<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaCountArgs} args - Arguments to filter Cuentas to count.
     * @example
     * // Count the number of Cuentas
     * const count = await prisma.cuenta.count({
     *   where: {
     *     // ... the filter for the Cuentas we want to count
     *   }
     * })
    **/
    count<T extends CuentaCountArgs>(
      args?: Subset<T, CuentaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuentaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuenta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuentaAggregateArgs>(args: Subset<T, CuentaAggregateArgs>): Prisma.PrismaPromise<GetCuentaAggregateType<T>>

    /**
     * Group by Cuenta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuentaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuentaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuentaGroupByArgs['orderBy'] }
        : { orderBy?: CuentaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuentaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuentaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cuenta model
   */
  readonly fields: CuentaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuenta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CuentaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cuenta model
   */
  interface CuentaFieldRefs {
    readonly idUsuario: FieldRef<"Cuenta", 'Int'>
    readonly tipo: FieldRef<"Cuenta", 'String'>
    readonly provider: FieldRef<"Cuenta", 'String'>
    readonly providerAccountId: FieldRef<"Cuenta", 'String'>
    readonly refresh_token: FieldRef<"Cuenta", 'String'>
    readonly access_token: FieldRef<"Cuenta", 'String'>
    readonly expires_at: FieldRef<"Cuenta", 'Int'>
    readonly token_type: FieldRef<"Cuenta", 'String'>
    readonly scope: FieldRef<"Cuenta", 'String'>
    readonly id_token: FieldRef<"Cuenta", 'String'>
    readonly session_state: FieldRef<"Cuenta", 'String'>
    readonly createdAt: FieldRef<"Cuenta", 'DateTime'>
    readonly updatedAt: FieldRef<"Cuenta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cuenta findUnique
   */
  export type CuentaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter, which Cuenta to fetch.
     */
    where: CuentaWhereUniqueInput
  }

  /**
   * Cuenta findUniqueOrThrow
   */
  export type CuentaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter, which Cuenta to fetch.
     */
    where: CuentaWhereUniqueInput
  }

  /**
   * Cuenta findFirst
   */
  export type CuentaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter, which Cuenta to fetch.
     */
    where?: CuentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuentas to fetch.
     */
    orderBy?: CuentaOrderByWithRelationInput | CuentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuentas.
     */
    cursor?: CuentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuentas.
     */
    distinct?: CuentaScalarFieldEnum | CuentaScalarFieldEnum[]
  }

  /**
   * Cuenta findFirstOrThrow
   */
  export type CuentaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter, which Cuenta to fetch.
     */
    where?: CuentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuentas to fetch.
     */
    orderBy?: CuentaOrderByWithRelationInput | CuentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuentas.
     */
    cursor?: CuentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuentas.
     */
    distinct?: CuentaScalarFieldEnum | CuentaScalarFieldEnum[]
  }

  /**
   * Cuenta findMany
   */
  export type CuentaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter, which Cuentas to fetch.
     */
    where?: CuentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuentas to fetch.
     */
    orderBy?: CuentaOrderByWithRelationInput | CuentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuentas.
     */
    cursor?: CuentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuentas.
     */
    skip?: number
    distinct?: CuentaScalarFieldEnum | CuentaScalarFieldEnum[]
  }

  /**
   * Cuenta create
   */
  export type CuentaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * The data needed to create a Cuenta.
     */
    data: XOR<CuentaCreateInput, CuentaUncheckedCreateInput>
  }

  /**
   * Cuenta createMany
   */
  export type CuentaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuentas.
     */
    data: CuentaCreateManyInput | CuentaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuenta createManyAndReturn
   */
  export type CuentaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * The data used to create many Cuentas.
     */
    data: CuentaCreateManyInput | CuentaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cuenta update
   */
  export type CuentaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * The data needed to update a Cuenta.
     */
    data: XOR<CuentaUpdateInput, CuentaUncheckedUpdateInput>
    /**
     * Choose, which Cuenta to update.
     */
    where: CuentaWhereUniqueInput
  }

  /**
   * Cuenta updateMany
   */
  export type CuentaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuentas.
     */
    data: XOR<CuentaUpdateManyMutationInput, CuentaUncheckedUpdateManyInput>
    /**
     * Filter which Cuentas to update
     */
    where?: CuentaWhereInput
    /**
     * Limit how many Cuentas to update.
     */
    limit?: number
  }

  /**
   * Cuenta updateManyAndReturn
   */
  export type CuentaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * The data used to update Cuentas.
     */
    data: XOR<CuentaUpdateManyMutationInput, CuentaUncheckedUpdateManyInput>
    /**
     * Filter which Cuentas to update
     */
    where?: CuentaWhereInput
    /**
     * Limit how many Cuentas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cuenta upsert
   */
  export type CuentaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * The filter to search for the Cuenta to update in case it exists.
     */
    where: CuentaWhereUniqueInput
    /**
     * In case the Cuenta found by the `where` argument doesn't exist, create a new Cuenta with this data.
     */
    create: XOR<CuentaCreateInput, CuentaUncheckedCreateInput>
    /**
     * In case the Cuenta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuentaUpdateInput, CuentaUncheckedUpdateInput>
  }

  /**
   * Cuenta delete
   */
  export type CuentaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    /**
     * Filter which Cuenta to delete.
     */
    where: CuentaWhereUniqueInput
  }

  /**
   * Cuenta deleteMany
   */
  export type CuentaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuentas to delete
     */
    where?: CuentaWhereInput
    /**
     * Limit how many Cuentas to delete.
     */
    limit?: number
  }

  /**
   * Cuenta without action
   */
  export type CuentaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
  }


  /**
   * Model Favorito
   */

  export type AggregateFavorito = {
    _count: FavoritoCountAggregateOutputType | null
    _avg: FavoritoAvgAggregateOutputType | null
    _sum: FavoritoSumAggregateOutputType | null
    _min: FavoritoMinAggregateOutputType | null
    _max: FavoritoMaxAggregateOutputType | null
  }

  export type FavoritoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
  }

  export type FavoritoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
  }

  export type FavoritoMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    fechaGuardado: Date | null
  }

  export type FavoritoMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    fechaGuardado: Date | null
  }

  export type FavoritoCountAggregateOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    fechaGuardado: number
    _all: number
  }


  export type FavoritoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
  }

  export type FavoritoSumAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
  }

  export type FavoritoMinAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    fechaGuardado?: true
  }

  export type FavoritoMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    fechaGuardado?: true
  }

  export type FavoritoCountAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    fechaGuardado?: true
    _all?: true
  }

  export type FavoritoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorito to aggregate.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favoritos
    **/
    _count?: true | FavoritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoritoMaxAggregateInputType
  }

  export type GetFavoritoAggregateType<T extends FavoritoAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorito[P]>
      : GetScalarType<T[P], AggregateFavorito[P]>
  }




  export type FavoritoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithAggregationInput | FavoritoOrderByWithAggregationInput[]
    by: FavoritoScalarFieldEnum[] | FavoritoScalarFieldEnum
    having?: FavoritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoritoCountAggregateInputType | true
    _avg?: FavoritoAvgAggregateInputType
    _sum?: FavoritoSumAggregateInputType
    _min?: FavoritoMinAggregateInputType
    _max?: FavoritoMaxAggregateInputType
  }

  export type FavoritoGroupByOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    fechaGuardado: Date
    _count: FavoritoCountAggregateOutputType | null
    _avg: FavoritoAvgAggregateOutputType | null
    _sum: FavoritoSumAggregateOutputType | null
    _min: FavoritoMinAggregateOutputType | null
    _max: FavoritoMaxAggregateOutputType | null
  }

  type GetFavoritoGroupByPayload<T extends FavoritoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoritoGroupByOutputType[P]>
            : GetScalarType<T[P], FavoritoGroupByOutputType[P]>
        }
      >
    >


  export type FavoritoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    fechaGuardado?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    fechaGuardado?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    fechaGuardado?: boolean
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    fechaGuardado?: boolean
  }

  export type FavoritoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "recetaId" | "fechaGuardado", ExtArgs["result"]["favorito"]>
  export type FavoritoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FavoritoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FavoritoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $FavoritoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorito"
    objects: {
      Receta: Prisma.$RecetaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      recetaId: number
      fechaGuardado: Date
    }, ExtArgs["result"]["favorito"]>
    composites: {}
  }

  type FavoritoGetPayload<S extends boolean | null | undefined | FavoritoDefaultArgs> = $Result.GetResult<Prisma.$FavoritoPayload, S>

  type FavoritoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoritoCountAggregateInputType | true
    }

  export interface FavoritoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorito'], meta: { name: 'Favorito' } }
    /**
     * Find zero or one Favorito that matches the filter.
     * @param {FavoritoFindUniqueArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoritoFindUniqueArgs>(args: SelectSubset<T, FavoritoFindUniqueArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoritoFindUniqueOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoritoFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoritoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoritoFindFirstArgs>(args?: SelectSubset<T, FavoritoFindFirstArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoritoFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoritoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favoritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favoritos
     * const favoritos = await prisma.favorito.findMany()
     * 
     * // Get first 10 Favoritos
     * const favoritos = await prisma.favorito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoritoWithIdOnly = await prisma.favorito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoritoFindManyArgs>(args?: SelectSubset<T, FavoritoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorito.
     * @param {FavoritoCreateArgs} args - Arguments to create a Favorito.
     * @example
     * // Create one Favorito
     * const Favorito = await prisma.favorito.create({
     *   data: {
     *     // ... data to create a Favorito
     *   }
     * })
     * 
     */
    create<T extends FavoritoCreateArgs>(args: SelectSubset<T, FavoritoCreateArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favoritos.
     * @param {FavoritoCreateManyArgs} args - Arguments to create many Favoritos.
     * @example
     * // Create many Favoritos
     * const favorito = await prisma.favorito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoritoCreateManyArgs>(args?: SelectSubset<T, FavoritoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favoritos and returns the data saved in the database.
     * @param {FavoritoCreateManyAndReturnArgs} args - Arguments to create many Favoritos.
     * @example
     * // Create many Favoritos
     * const favorito = await prisma.favorito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favoritos and only return the `id`
     * const favoritoWithIdOnly = await prisma.favorito.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoritoCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoritoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorito.
     * @param {FavoritoDeleteArgs} args - Arguments to delete one Favorito.
     * @example
     * // Delete one Favorito
     * const Favorito = await prisma.favorito.delete({
     *   where: {
     *     // ... filter to delete one Favorito
     *   }
     * })
     * 
     */
    delete<T extends FavoritoDeleteArgs>(args: SelectSubset<T, FavoritoDeleteArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorito.
     * @param {FavoritoUpdateArgs} args - Arguments to update one Favorito.
     * @example
     * // Update one Favorito
     * const favorito = await prisma.favorito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoritoUpdateArgs>(args: SelectSubset<T, FavoritoUpdateArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favoritos.
     * @param {FavoritoDeleteManyArgs} args - Arguments to filter Favoritos to delete.
     * @example
     * // Delete a few Favoritos
     * const { count } = await prisma.favorito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoritoDeleteManyArgs>(args?: SelectSubset<T, FavoritoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favoritos
     * const favorito = await prisma.favorito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoritoUpdateManyArgs>(args: SelectSubset<T, FavoritoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favoritos and returns the data updated in the database.
     * @param {FavoritoUpdateManyAndReturnArgs} args - Arguments to update many Favoritos.
     * @example
     * // Update many Favoritos
     * const favorito = await prisma.favorito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favoritos and only return the `id`
     * const favoritoWithIdOnly = await prisma.favorito.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoritoUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoritoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorito.
     * @param {FavoritoUpsertArgs} args - Arguments to update or create a Favorito.
     * @example
     * // Update or create a Favorito
     * const favorito = await prisma.favorito.upsert({
     *   create: {
     *     // ... data to create a Favorito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorito we want to update
     *   }
     * })
     */
    upsert<T extends FavoritoUpsertArgs>(args: SelectSubset<T, FavoritoUpsertArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoCountArgs} args - Arguments to filter Favoritos to count.
     * @example
     * // Count the number of Favoritos
     * const count = await prisma.favorito.count({
     *   where: {
     *     // ... the filter for the Favoritos we want to count
     *   }
     * })
    **/
    count<T extends FavoritoCountArgs>(
      args?: Subset<T, FavoritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoritoAggregateArgs>(args: Subset<T, FavoritoAggregateArgs>): Prisma.PrismaPromise<GetFavoritoAggregateType<T>>

    /**
     * Group by Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoritoGroupByArgs['orderBy'] }
        : { orderBy?: FavoritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoritoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorito model
   */
  readonly fields: FavoritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoritoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Receta<T extends RecetaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecetaDefaultArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorito model
   */
  interface FavoritoFieldRefs {
    readonly id: FieldRef<"Favorito", 'Int'>
    readonly usuarioId: FieldRef<"Favorito", 'Int'>
    readonly recetaId: FieldRef<"Favorito", 'Int'>
    readonly fechaGuardado: FieldRef<"Favorito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorito findUnique
   */
  export type FavoritoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito findUniqueOrThrow
   */
  export type FavoritoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito findFirst
   */
  export type FavoritoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito findFirstOrThrow
   */
  export type FavoritoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito findMany
   */
  export type FavoritoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favoritos to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito create
   */
  export type FavoritoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorito.
     */
    data: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>
  }

  /**
   * Favorito createMany
   */
  export type FavoritoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favoritos.
     */
    data: FavoritoCreateManyInput | FavoritoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorito createManyAndReturn
   */
  export type FavoritoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * The data used to create many Favoritos.
     */
    data: FavoritoCreateManyInput | FavoritoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorito update
   */
  export type FavoritoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorito.
     */
    data: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>
    /**
     * Choose, which Favorito to update.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito updateMany
   */
  export type FavoritoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favoritos.
     */
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyInput>
    /**
     * Filter which Favoritos to update
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to update.
     */
    limit?: number
  }

  /**
   * Favorito updateManyAndReturn
   */
  export type FavoritoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * The data used to update Favoritos.
     */
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyInput>
    /**
     * Filter which Favoritos to update
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorito upsert
   */
  export type FavoritoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorito to update in case it exists.
     */
    where: FavoritoWhereUniqueInput
    /**
     * In case the Favorito found by the `where` argument doesn't exist, create a new Favorito with this data.
     */
    create: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>
    /**
     * In case the Favorito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>
  }

  /**
   * Favorito delete
   */
  export type FavoritoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter which Favorito to delete.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito deleteMany
   */
  export type FavoritoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favoritos to delete
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to delete.
     */
    limit?: number
  }

  /**
   * Favorito without action
   */
  export type FavoritoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
  }


  /**
   * Model Ingrediente
   */

  export type AggregateIngrediente = {
    _count: IngredienteCountAggregateOutputType | null
    _avg: IngredienteAvgAggregateOutputType | null
    _sum: IngredienteSumAggregateOutputType | null
    _min: IngredienteMinAggregateOutputType | null
    _max: IngredienteMaxAggregateOutputType | null
  }

  export type IngredienteAvgAggregateOutputType = {
    id: number | null
  }

  export type IngredienteSumAggregateOutputType = {
    id: number | null
  }

  export type IngredienteMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    Tipo: $Enums.TipoIngrediente | null
  }

  export type IngredienteMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    Tipo: $Enums.TipoIngrediente | null
  }

  export type IngredienteCountAggregateOutputType = {
    id: number
    nombre: number
    Tipo: number
    _all: number
  }


  export type IngredienteAvgAggregateInputType = {
    id?: true
  }

  export type IngredienteSumAggregateInputType = {
    id?: true
  }

  export type IngredienteMinAggregateInputType = {
    id?: true
    nombre?: true
    Tipo?: true
  }

  export type IngredienteMaxAggregateInputType = {
    id?: true
    nombre?: true
    Tipo?: true
  }

  export type IngredienteCountAggregateInputType = {
    id?: true
    nombre?: true
    Tipo?: true
    _all?: true
  }

  export type IngredienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingrediente to aggregate.
     */
    where?: IngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredientes to fetch.
     */
    orderBy?: IngredienteOrderByWithRelationInput | IngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredientes
    **/
    _count?: true | IngredienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredienteMaxAggregateInputType
  }

  export type GetIngredienteAggregateType<T extends IngredienteAggregateArgs> = {
        [P in keyof T & keyof AggregateIngrediente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngrediente[P]>
      : GetScalarType<T[P], AggregateIngrediente[P]>
  }




  export type IngredienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredienteWhereInput
    orderBy?: IngredienteOrderByWithAggregationInput | IngredienteOrderByWithAggregationInput[]
    by: IngredienteScalarFieldEnum[] | IngredienteScalarFieldEnum
    having?: IngredienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredienteCountAggregateInputType | true
    _avg?: IngredienteAvgAggregateInputType
    _sum?: IngredienteSumAggregateInputType
    _min?: IngredienteMinAggregateInputType
    _max?: IngredienteMaxAggregateInputType
  }

  export type IngredienteGroupByOutputType = {
    id: number
    nombre: string
    Tipo: $Enums.TipoIngrediente
    _count: IngredienteCountAggregateOutputType | null
    _avg: IngredienteAvgAggregateOutputType | null
    _sum: IngredienteSumAggregateOutputType | null
    _min: IngredienteMinAggregateOutputType | null
    _max: IngredienteMaxAggregateOutputType | null
  }

  type GetIngredienteGroupByPayload<T extends IngredienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredienteGroupByOutputType[P]>
            : GetScalarType<T[P], IngredienteGroupByOutputType[P]>
        }
      >
    >


  export type IngredienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Tipo?: boolean
    RecetaIngrediente?: boolean | Ingrediente$RecetaIngredienteArgs<ExtArgs>
    _count?: boolean | IngredienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingrediente"]>

  export type IngredienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Tipo?: boolean
  }, ExtArgs["result"]["ingrediente"]>

  export type IngredienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Tipo?: boolean
  }, ExtArgs["result"]["ingrediente"]>

  export type IngredienteSelectScalar = {
    id?: boolean
    nombre?: boolean
    Tipo?: boolean
  }

  export type IngredienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "Tipo", ExtArgs["result"]["ingrediente"]>
  export type IngredienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RecetaIngrediente?: boolean | Ingrediente$RecetaIngredienteArgs<ExtArgs>
    _count?: boolean | IngredienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IngredienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IngredienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IngredientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingrediente"
    objects: {
      RecetaIngrediente: Prisma.$RecetaIngredientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      Tipo: $Enums.TipoIngrediente
    }, ExtArgs["result"]["ingrediente"]>
    composites: {}
  }

  type IngredienteGetPayload<S extends boolean | null | undefined | IngredienteDefaultArgs> = $Result.GetResult<Prisma.$IngredientePayload, S>

  type IngredienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngredienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IngredienteCountAggregateInputType | true
    }

  export interface IngredienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingrediente'], meta: { name: 'Ingrediente' } }
    /**
     * Find zero or one Ingrediente that matches the filter.
     * @param {IngredienteFindUniqueArgs} args - Arguments to find a Ingrediente
     * @example
     * // Get one Ingrediente
     * const ingrediente = await prisma.ingrediente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngredienteFindUniqueArgs>(args: SelectSubset<T, IngredienteFindUniqueArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ingrediente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngredienteFindUniqueOrThrowArgs} args - Arguments to find a Ingrediente
     * @example
     * // Get one Ingrediente
     * const ingrediente = await prisma.ingrediente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngredienteFindUniqueOrThrowArgs>(args: SelectSubset<T, IngredienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ingrediente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteFindFirstArgs} args - Arguments to find a Ingrediente
     * @example
     * // Get one Ingrediente
     * const ingrediente = await prisma.ingrediente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngredienteFindFirstArgs>(args?: SelectSubset<T, IngredienteFindFirstArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ingrediente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteFindFirstOrThrowArgs} args - Arguments to find a Ingrediente
     * @example
     * // Get one Ingrediente
     * const ingrediente = await prisma.ingrediente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngredienteFindFirstOrThrowArgs>(args?: SelectSubset<T, IngredienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ingredientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredientes
     * const ingredientes = await prisma.ingrediente.findMany()
     * 
     * // Get first 10 Ingredientes
     * const ingredientes = await prisma.ingrediente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredienteWithIdOnly = await prisma.ingrediente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngredienteFindManyArgs>(args?: SelectSubset<T, IngredienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ingrediente.
     * @param {IngredienteCreateArgs} args - Arguments to create a Ingrediente.
     * @example
     * // Create one Ingrediente
     * const Ingrediente = await prisma.ingrediente.create({
     *   data: {
     *     // ... data to create a Ingrediente
     *   }
     * })
     * 
     */
    create<T extends IngredienteCreateArgs>(args: SelectSubset<T, IngredienteCreateArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ingredientes.
     * @param {IngredienteCreateManyArgs} args - Arguments to create many Ingredientes.
     * @example
     * // Create many Ingredientes
     * const ingrediente = await prisma.ingrediente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngredienteCreateManyArgs>(args?: SelectSubset<T, IngredienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ingredientes and returns the data saved in the database.
     * @param {IngredienteCreateManyAndReturnArgs} args - Arguments to create many Ingredientes.
     * @example
     * // Create many Ingredientes
     * const ingrediente = await prisma.ingrediente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ingredientes and only return the `id`
     * const ingredienteWithIdOnly = await prisma.ingrediente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngredienteCreateManyAndReturnArgs>(args?: SelectSubset<T, IngredienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ingrediente.
     * @param {IngredienteDeleteArgs} args - Arguments to delete one Ingrediente.
     * @example
     * // Delete one Ingrediente
     * const Ingrediente = await prisma.ingrediente.delete({
     *   where: {
     *     // ... filter to delete one Ingrediente
     *   }
     * })
     * 
     */
    delete<T extends IngredienteDeleteArgs>(args: SelectSubset<T, IngredienteDeleteArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ingrediente.
     * @param {IngredienteUpdateArgs} args - Arguments to update one Ingrediente.
     * @example
     * // Update one Ingrediente
     * const ingrediente = await prisma.ingrediente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngredienteUpdateArgs>(args: SelectSubset<T, IngredienteUpdateArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ingredientes.
     * @param {IngredienteDeleteManyArgs} args - Arguments to filter Ingredientes to delete.
     * @example
     * // Delete a few Ingredientes
     * const { count } = await prisma.ingrediente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngredienteDeleteManyArgs>(args?: SelectSubset<T, IngredienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredientes
     * const ingrediente = await prisma.ingrediente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngredienteUpdateManyArgs>(args: SelectSubset<T, IngredienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredientes and returns the data updated in the database.
     * @param {IngredienteUpdateManyAndReturnArgs} args - Arguments to update many Ingredientes.
     * @example
     * // Update many Ingredientes
     * const ingrediente = await prisma.ingrediente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ingredientes and only return the `id`
     * const ingredienteWithIdOnly = await prisma.ingrediente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IngredienteUpdateManyAndReturnArgs>(args: SelectSubset<T, IngredienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ingrediente.
     * @param {IngredienteUpsertArgs} args - Arguments to update or create a Ingrediente.
     * @example
     * // Update or create a Ingrediente
     * const ingrediente = await prisma.ingrediente.upsert({
     *   create: {
     *     // ... data to create a Ingrediente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingrediente we want to update
     *   }
     * })
     */
    upsert<T extends IngredienteUpsertArgs>(args: SelectSubset<T, IngredienteUpsertArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ingredientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteCountArgs} args - Arguments to filter Ingredientes to count.
     * @example
     * // Count the number of Ingredientes
     * const count = await prisma.ingrediente.count({
     *   where: {
     *     // ... the filter for the Ingredientes we want to count
     *   }
     * })
    **/
    count<T extends IngredienteCountArgs>(
      args?: Subset<T, IngredienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingrediente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredienteAggregateArgs>(args: Subset<T, IngredienteAggregateArgs>): Prisma.PrismaPromise<GetIngredienteAggregateType<T>>

    /**
     * Group by Ingrediente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredienteGroupByArgs['orderBy'] }
        : { orderBy?: IngredienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingrediente model
   */
  readonly fields: IngredienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingrediente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RecetaIngrediente<T extends Ingrediente$RecetaIngredienteArgs<ExtArgs> = {}>(args?: Subset<T, Ingrediente$RecetaIngredienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ingrediente model
   */
  interface IngredienteFieldRefs {
    readonly id: FieldRef<"Ingrediente", 'Int'>
    readonly nombre: FieldRef<"Ingrediente", 'String'>
    readonly Tipo: FieldRef<"Ingrediente", 'TipoIngrediente'>
  }
    

  // Custom InputTypes
  /**
   * Ingrediente findUnique
   */
  export type IngredienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter, which Ingrediente to fetch.
     */
    where: IngredienteWhereUniqueInput
  }

  /**
   * Ingrediente findUniqueOrThrow
   */
  export type IngredienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter, which Ingrediente to fetch.
     */
    where: IngredienteWhereUniqueInput
  }

  /**
   * Ingrediente findFirst
   */
  export type IngredienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter, which Ingrediente to fetch.
     */
    where?: IngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredientes to fetch.
     */
    orderBy?: IngredienteOrderByWithRelationInput | IngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredientes.
     */
    cursor?: IngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredientes.
     */
    distinct?: IngredienteScalarFieldEnum | IngredienteScalarFieldEnum[]
  }

  /**
   * Ingrediente findFirstOrThrow
   */
  export type IngredienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter, which Ingrediente to fetch.
     */
    where?: IngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredientes to fetch.
     */
    orderBy?: IngredienteOrderByWithRelationInput | IngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredientes.
     */
    cursor?: IngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredientes.
     */
    distinct?: IngredienteScalarFieldEnum | IngredienteScalarFieldEnum[]
  }

  /**
   * Ingrediente findMany
   */
  export type IngredienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter, which Ingredientes to fetch.
     */
    where?: IngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredientes to fetch.
     */
    orderBy?: IngredienteOrderByWithRelationInput | IngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredientes.
     */
    cursor?: IngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredientes.
     */
    skip?: number
    distinct?: IngredienteScalarFieldEnum | IngredienteScalarFieldEnum[]
  }

  /**
   * Ingrediente create
   */
  export type IngredienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingrediente.
     */
    data: XOR<IngredienteCreateInput, IngredienteUncheckedCreateInput>
  }

  /**
   * Ingrediente createMany
   */
  export type IngredienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ingredientes.
     */
    data: IngredienteCreateManyInput | IngredienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ingrediente createManyAndReturn
   */
  export type IngredienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * The data used to create many Ingredientes.
     */
    data: IngredienteCreateManyInput | IngredienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ingrediente update
   */
  export type IngredienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingrediente.
     */
    data: XOR<IngredienteUpdateInput, IngredienteUncheckedUpdateInput>
    /**
     * Choose, which Ingrediente to update.
     */
    where: IngredienteWhereUniqueInput
  }

  /**
   * Ingrediente updateMany
   */
  export type IngredienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingredientes.
     */
    data: XOR<IngredienteUpdateManyMutationInput, IngredienteUncheckedUpdateManyInput>
    /**
     * Filter which Ingredientes to update
     */
    where?: IngredienteWhereInput
    /**
     * Limit how many Ingredientes to update.
     */
    limit?: number
  }

  /**
   * Ingrediente updateManyAndReturn
   */
  export type IngredienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * The data used to update Ingredientes.
     */
    data: XOR<IngredienteUpdateManyMutationInput, IngredienteUncheckedUpdateManyInput>
    /**
     * Filter which Ingredientes to update
     */
    where?: IngredienteWhereInput
    /**
     * Limit how many Ingredientes to update.
     */
    limit?: number
  }

  /**
   * Ingrediente upsert
   */
  export type IngredienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingrediente to update in case it exists.
     */
    where: IngredienteWhereUniqueInput
    /**
     * In case the Ingrediente found by the `where` argument doesn't exist, create a new Ingrediente with this data.
     */
    create: XOR<IngredienteCreateInput, IngredienteUncheckedCreateInput>
    /**
     * In case the Ingrediente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredienteUpdateInput, IngredienteUncheckedUpdateInput>
  }

  /**
   * Ingrediente delete
   */
  export type IngredienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
    /**
     * Filter which Ingrediente to delete.
     */
    where: IngredienteWhereUniqueInput
  }

  /**
   * Ingrediente deleteMany
   */
  export type IngredienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredientes to delete
     */
    where?: IngredienteWhereInput
    /**
     * Limit how many Ingredientes to delete.
     */
    limit?: number
  }

  /**
   * Ingrediente.RecetaIngrediente
   */
  export type Ingrediente$RecetaIngredienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    where?: RecetaIngredienteWhereInput
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    cursor?: RecetaIngredienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaIngredienteScalarFieldEnum | RecetaIngredienteScalarFieldEnum[]
  }

  /**
   * Ingrediente without action
   */
  export type IngredienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingrediente
     */
    select?: IngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingrediente
     */
    omit?: IngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredienteInclude<ExtArgs> | null
  }


  /**
   * Model ListaCompra
   */

  export type AggregateListaCompra = {
    _count: ListaCompraCountAggregateOutputType | null
    _avg: ListaCompraAvgAggregateOutputType | null
    _sum: ListaCompraSumAggregateOutputType | null
    _min: ListaCompraMinAggregateOutputType | null
    _max: ListaCompraMaxAggregateOutputType | null
  }

  export type ListaCompraAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    cantidad: number | null
  }

  export type ListaCompraSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    cantidad: number | null
  }

  export type ListaCompraMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nombreIngrediente: string | null
    cantidad: number | null
    fechaCreacion: Date | null
  }

  export type ListaCompraMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nombreIngrediente: string | null
    cantidad: number | null
    fechaCreacion: Date | null
  }

  export type ListaCompraCountAggregateOutputType = {
    id: number
    usuarioId: number
    nombreIngrediente: number
    cantidad: number
    fechaCreacion: number
    _all: number
  }


  export type ListaCompraAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    cantidad?: true
  }

  export type ListaCompraSumAggregateInputType = {
    id?: true
    usuarioId?: true
    cantidad?: true
  }

  export type ListaCompraMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nombreIngrediente?: true
    cantidad?: true
    fechaCreacion?: true
  }

  export type ListaCompraMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nombreIngrediente?: true
    cantidad?: true
    fechaCreacion?: true
  }

  export type ListaCompraCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nombreIngrediente?: true
    cantidad?: true
    fechaCreacion?: true
    _all?: true
  }

  export type ListaCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListaCompra to aggregate.
     */
    where?: ListaCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaCompras to fetch.
     */
    orderBy?: ListaCompraOrderByWithRelationInput | ListaCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListaCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListaCompras
    **/
    _count?: true | ListaCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListaCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListaCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListaCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListaCompraMaxAggregateInputType
  }

  export type GetListaCompraAggregateType<T extends ListaCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateListaCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListaCompra[P]>
      : GetScalarType<T[P], AggregateListaCompra[P]>
  }




  export type ListaCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListaCompraWhereInput
    orderBy?: ListaCompraOrderByWithAggregationInput | ListaCompraOrderByWithAggregationInput[]
    by: ListaCompraScalarFieldEnum[] | ListaCompraScalarFieldEnum
    having?: ListaCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListaCompraCountAggregateInputType | true
    _avg?: ListaCompraAvgAggregateInputType
    _sum?: ListaCompraSumAggregateInputType
    _min?: ListaCompraMinAggregateInputType
    _max?: ListaCompraMaxAggregateInputType
  }

  export type ListaCompraGroupByOutputType = {
    id: number
    usuarioId: number
    nombreIngrediente: string
    cantidad: number
    fechaCreacion: Date
    _count: ListaCompraCountAggregateOutputType | null
    _avg: ListaCompraAvgAggregateOutputType | null
    _sum: ListaCompraSumAggregateOutputType | null
    _min: ListaCompraMinAggregateOutputType | null
    _max: ListaCompraMaxAggregateOutputType | null
  }

  type GetListaCompraGroupByPayload<T extends ListaCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListaCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListaCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListaCompraGroupByOutputType[P]>
            : GetScalarType<T[P], ListaCompraGroupByOutputType[P]>
        }
      >
    >


  export type ListaCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombreIngrediente?: boolean
    cantidad?: boolean
    fechaCreacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaCompra"]>

  export type ListaCompraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombreIngrediente?: boolean
    cantidad?: boolean
    fechaCreacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaCompra"]>

  export type ListaCompraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombreIngrediente?: boolean
    cantidad?: boolean
    fechaCreacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaCompra"]>

  export type ListaCompraSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nombreIngrediente?: boolean
    cantidad?: boolean
    fechaCreacion?: boolean
  }

  export type ListaCompraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "nombreIngrediente" | "cantidad" | "fechaCreacion", ExtArgs["result"]["listaCompra"]>
  export type ListaCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ListaCompraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ListaCompraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ListaCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListaCompra"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      nombreIngrediente: string
      cantidad: number
      fechaCreacion: Date
    }, ExtArgs["result"]["listaCompra"]>
    composites: {}
  }

  type ListaCompraGetPayload<S extends boolean | null | undefined | ListaCompraDefaultArgs> = $Result.GetResult<Prisma.$ListaCompraPayload, S>

  type ListaCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListaCompraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListaCompraCountAggregateInputType | true
    }

  export interface ListaCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListaCompra'], meta: { name: 'ListaCompra' } }
    /**
     * Find zero or one ListaCompra that matches the filter.
     * @param {ListaCompraFindUniqueArgs} args - Arguments to find a ListaCompra
     * @example
     * // Get one ListaCompra
     * const listaCompra = await prisma.listaCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListaCompraFindUniqueArgs>(args: SelectSubset<T, ListaCompraFindUniqueArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListaCompra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListaCompraFindUniqueOrThrowArgs} args - Arguments to find a ListaCompra
     * @example
     * // Get one ListaCompra
     * const listaCompra = await prisma.listaCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListaCompraFindUniqueOrThrowArgs>(args: SelectSubset<T, ListaCompraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListaCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraFindFirstArgs} args - Arguments to find a ListaCompra
     * @example
     * // Get one ListaCompra
     * const listaCompra = await prisma.listaCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListaCompraFindFirstArgs>(args?: SelectSubset<T, ListaCompraFindFirstArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListaCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraFindFirstOrThrowArgs} args - Arguments to find a ListaCompra
     * @example
     * // Get one ListaCompra
     * const listaCompra = await prisma.listaCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListaCompraFindFirstOrThrowArgs>(args?: SelectSubset<T, ListaCompraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListaCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListaCompras
     * const listaCompras = await prisma.listaCompra.findMany()
     * 
     * // Get first 10 ListaCompras
     * const listaCompras = await prisma.listaCompra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listaCompraWithIdOnly = await prisma.listaCompra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListaCompraFindManyArgs>(args?: SelectSubset<T, ListaCompraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListaCompra.
     * @param {ListaCompraCreateArgs} args - Arguments to create a ListaCompra.
     * @example
     * // Create one ListaCompra
     * const ListaCompra = await prisma.listaCompra.create({
     *   data: {
     *     // ... data to create a ListaCompra
     *   }
     * })
     * 
     */
    create<T extends ListaCompraCreateArgs>(args: SelectSubset<T, ListaCompraCreateArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListaCompras.
     * @param {ListaCompraCreateManyArgs} args - Arguments to create many ListaCompras.
     * @example
     * // Create many ListaCompras
     * const listaCompra = await prisma.listaCompra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListaCompraCreateManyArgs>(args?: SelectSubset<T, ListaCompraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListaCompras and returns the data saved in the database.
     * @param {ListaCompraCreateManyAndReturnArgs} args - Arguments to create many ListaCompras.
     * @example
     * // Create many ListaCompras
     * const listaCompra = await prisma.listaCompra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListaCompras and only return the `id`
     * const listaCompraWithIdOnly = await prisma.listaCompra.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListaCompraCreateManyAndReturnArgs>(args?: SelectSubset<T, ListaCompraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListaCompra.
     * @param {ListaCompraDeleteArgs} args - Arguments to delete one ListaCompra.
     * @example
     * // Delete one ListaCompra
     * const ListaCompra = await prisma.listaCompra.delete({
     *   where: {
     *     // ... filter to delete one ListaCompra
     *   }
     * })
     * 
     */
    delete<T extends ListaCompraDeleteArgs>(args: SelectSubset<T, ListaCompraDeleteArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListaCompra.
     * @param {ListaCompraUpdateArgs} args - Arguments to update one ListaCompra.
     * @example
     * // Update one ListaCompra
     * const listaCompra = await prisma.listaCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListaCompraUpdateArgs>(args: SelectSubset<T, ListaCompraUpdateArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListaCompras.
     * @param {ListaCompraDeleteManyArgs} args - Arguments to filter ListaCompras to delete.
     * @example
     * // Delete a few ListaCompras
     * const { count } = await prisma.listaCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListaCompraDeleteManyArgs>(args?: SelectSubset<T, ListaCompraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListaCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListaCompras
     * const listaCompra = await prisma.listaCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListaCompraUpdateManyArgs>(args: SelectSubset<T, ListaCompraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListaCompras and returns the data updated in the database.
     * @param {ListaCompraUpdateManyAndReturnArgs} args - Arguments to update many ListaCompras.
     * @example
     * // Update many ListaCompras
     * const listaCompra = await prisma.listaCompra.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListaCompras and only return the `id`
     * const listaCompraWithIdOnly = await prisma.listaCompra.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListaCompraUpdateManyAndReturnArgs>(args: SelectSubset<T, ListaCompraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListaCompra.
     * @param {ListaCompraUpsertArgs} args - Arguments to update or create a ListaCompra.
     * @example
     * // Update or create a ListaCompra
     * const listaCompra = await prisma.listaCompra.upsert({
     *   create: {
     *     // ... data to create a ListaCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListaCompra we want to update
     *   }
     * })
     */
    upsert<T extends ListaCompraUpsertArgs>(args: SelectSubset<T, ListaCompraUpsertArgs<ExtArgs>>): Prisma__ListaCompraClient<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListaCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraCountArgs} args - Arguments to filter ListaCompras to count.
     * @example
     * // Count the number of ListaCompras
     * const count = await prisma.listaCompra.count({
     *   where: {
     *     // ... the filter for the ListaCompras we want to count
     *   }
     * })
    **/
    count<T extends ListaCompraCountArgs>(
      args?: Subset<T, ListaCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListaCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListaCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListaCompraAggregateArgs>(args: Subset<T, ListaCompraAggregateArgs>): Prisma.PrismaPromise<GetListaCompraAggregateType<T>>

    /**
     * Group by ListaCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListaCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListaCompraGroupByArgs['orderBy'] }
        : { orderBy?: ListaCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListaCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListaCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListaCompra model
   */
  readonly fields: ListaCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListaCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListaCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListaCompra model
   */
  interface ListaCompraFieldRefs {
    readonly id: FieldRef<"ListaCompra", 'Int'>
    readonly usuarioId: FieldRef<"ListaCompra", 'Int'>
    readonly nombreIngrediente: FieldRef<"ListaCompra", 'String'>
    readonly cantidad: FieldRef<"ListaCompra", 'Int'>
    readonly fechaCreacion: FieldRef<"ListaCompra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListaCompra findUnique
   */
  export type ListaCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter, which ListaCompra to fetch.
     */
    where: ListaCompraWhereUniqueInput
  }

  /**
   * ListaCompra findUniqueOrThrow
   */
  export type ListaCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter, which ListaCompra to fetch.
     */
    where: ListaCompraWhereUniqueInput
  }

  /**
   * ListaCompra findFirst
   */
  export type ListaCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter, which ListaCompra to fetch.
     */
    where?: ListaCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaCompras to fetch.
     */
    orderBy?: ListaCompraOrderByWithRelationInput | ListaCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListaCompras.
     */
    cursor?: ListaCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListaCompras.
     */
    distinct?: ListaCompraScalarFieldEnum | ListaCompraScalarFieldEnum[]
  }

  /**
   * ListaCompra findFirstOrThrow
   */
  export type ListaCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter, which ListaCompra to fetch.
     */
    where?: ListaCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaCompras to fetch.
     */
    orderBy?: ListaCompraOrderByWithRelationInput | ListaCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListaCompras.
     */
    cursor?: ListaCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListaCompras.
     */
    distinct?: ListaCompraScalarFieldEnum | ListaCompraScalarFieldEnum[]
  }

  /**
   * ListaCompra findMany
   */
  export type ListaCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter, which ListaCompras to fetch.
     */
    where?: ListaCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaCompras to fetch.
     */
    orderBy?: ListaCompraOrderByWithRelationInput | ListaCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListaCompras.
     */
    cursor?: ListaCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaCompras.
     */
    skip?: number
    distinct?: ListaCompraScalarFieldEnum | ListaCompraScalarFieldEnum[]
  }

  /**
   * ListaCompra create
   */
  export type ListaCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a ListaCompra.
     */
    data: XOR<ListaCompraCreateInput, ListaCompraUncheckedCreateInput>
  }

  /**
   * ListaCompra createMany
   */
  export type ListaCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListaCompras.
     */
    data: ListaCompraCreateManyInput | ListaCompraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListaCompra createManyAndReturn
   */
  export type ListaCompraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * The data used to create many ListaCompras.
     */
    data: ListaCompraCreateManyInput | ListaCompraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListaCompra update
   */
  export type ListaCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a ListaCompra.
     */
    data: XOR<ListaCompraUpdateInput, ListaCompraUncheckedUpdateInput>
    /**
     * Choose, which ListaCompra to update.
     */
    where: ListaCompraWhereUniqueInput
  }

  /**
   * ListaCompra updateMany
   */
  export type ListaCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListaCompras.
     */
    data: XOR<ListaCompraUpdateManyMutationInput, ListaCompraUncheckedUpdateManyInput>
    /**
     * Filter which ListaCompras to update
     */
    where?: ListaCompraWhereInput
    /**
     * Limit how many ListaCompras to update.
     */
    limit?: number
  }

  /**
   * ListaCompra updateManyAndReturn
   */
  export type ListaCompraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * The data used to update ListaCompras.
     */
    data: XOR<ListaCompraUpdateManyMutationInput, ListaCompraUncheckedUpdateManyInput>
    /**
     * Filter which ListaCompras to update
     */
    where?: ListaCompraWhereInput
    /**
     * Limit how many ListaCompras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListaCompra upsert
   */
  export type ListaCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the ListaCompra to update in case it exists.
     */
    where: ListaCompraWhereUniqueInput
    /**
     * In case the ListaCompra found by the `where` argument doesn't exist, create a new ListaCompra with this data.
     */
    create: XOR<ListaCompraCreateInput, ListaCompraUncheckedCreateInput>
    /**
     * In case the ListaCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListaCompraUpdateInput, ListaCompraUncheckedUpdateInput>
  }

  /**
   * ListaCompra delete
   */
  export type ListaCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    /**
     * Filter which ListaCompra to delete.
     */
    where: ListaCompraWhereUniqueInput
  }

  /**
   * ListaCompra deleteMany
   */
  export type ListaCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListaCompras to delete
     */
    where?: ListaCompraWhereInput
    /**
     * Limit how many ListaCompras to delete.
     */
    limit?: number
  }

  /**
   * ListaCompra without action
   */
  export type ListaCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NotificacionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    mensaje: string | null
    leida: boolean | null
    fechaNotificacion: Date | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    mensaje: string | null
    leida: boolean | null
    fechaNotificacion: Date | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    usuarioId: number
    mensaje: number
    leida: number
    fechaNotificacion: number
    _all: number
  }


  export type NotificacionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NotificacionSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NotificacionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    mensaje?: true
    leida?: true
    fechaNotificacion?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    mensaje?: true
    leida?: true
    fechaNotificacion?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    mensaje?: true
    leida?: true
    fechaNotificacion?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _avg?: NotificacionAvgAggregateInputType
    _sum?: NotificacionSumAggregateInputType
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: number
    usuarioId: number
    mensaje: string
    leida: boolean
    fechaNotificacion: Date
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    mensaje?: boolean
    leida?: boolean
    fechaNotificacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    mensaje?: boolean
    leida?: boolean
    fechaNotificacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    mensaje?: boolean
    leida?: boolean
    fechaNotificacion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    mensaje?: boolean
    leida?: boolean
    fechaNotificacion?: boolean
  }

  export type NotificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "mensaje" | "leida" | "fechaNotificacion", ExtArgs["result"]["notificacion"]>
  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      mensaje: string
      leida: boolean
      fechaNotificacion: Date
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificacions and returns the data saved in the database.
     * @param {NotificacionCreateManyAndReturnArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions and returns the data updated in the database.
     * @param {NotificacionUpdateManyAndReturnArgs} args - Arguments to update many Notificacions.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'Int'>
    readonly usuarioId: FieldRef<"Notificacion", 'Int'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly leida: FieldRef<"Notificacion", 'Boolean'>
    readonly fechaNotificacion: FieldRef<"Notificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion createManyAndReturn
   */
  export type NotificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion updateManyAndReturn
   */
  export type NotificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model Receta
   */

  export type AggregateReceta = {
    _count: RecetaCountAggregateOutputType | null
    _avg: RecetaAvgAggregateOutputType | null
    _sum: RecetaSumAggregateOutputType | null
    _min: RecetaMinAggregateOutputType | null
    _max: RecetaMaxAggregateOutputType | null
  }

  export type RecetaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    tiempoPreparacion: number | null
    porciones: number | null
    idTipoComida: number | null
    idTipoSabor: number | null
  }

  export type RecetaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    tiempoPreparacion: number | null
    porciones: number | null
    idTipoComida: number | null
    idTipoSabor: number | null
  }

  export type RecetaMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    titulo: string | null
    descripcion: string | null
    tiempoPreparacion: number | null
    porciones: number | null
    imagen: string | null
    fechaCreacion: Date | null
    idTipoComida: number | null
    idTipoSabor: number | null
    dificultad: $Enums.DificultadReceta | null
  }

  export type RecetaMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    titulo: string | null
    descripcion: string | null
    tiempoPreparacion: number | null
    porciones: number | null
    imagen: string | null
    fechaCreacion: Date | null
    idTipoComida: number | null
    idTipoSabor: number | null
    dificultad: $Enums.DificultadReceta | null
  }

  export type RecetaCountAggregateOutputType = {
    id: number
    usuarioId: number
    titulo: number
    descripcion: number
    tiempoPreparacion: number
    porciones: number
    imagen: number
    fechaCreacion: number
    idTipoComida: number
    idTipoSabor: number
    dificultad: number
    _all: number
  }


  export type RecetaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    tiempoPreparacion?: true
    porciones?: true
    idTipoComida?: true
    idTipoSabor?: true
  }

  export type RecetaSumAggregateInputType = {
    id?: true
    usuarioId?: true
    tiempoPreparacion?: true
    porciones?: true
    idTipoComida?: true
    idTipoSabor?: true
  }

  export type RecetaMinAggregateInputType = {
    id?: true
    usuarioId?: true
    titulo?: true
    descripcion?: true
    tiempoPreparacion?: true
    porciones?: true
    imagen?: true
    fechaCreacion?: true
    idTipoComida?: true
    idTipoSabor?: true
    dificultad?: true
  }

  export type RecetaMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    titulo?: true
    descripcion?: true
    tiempoPreparacion?: true
    porciones?: true
    imagen?: true
    fechaCreacion?: true
    idTipoComida?: true
    idTipoSabor?: true
    dificultad?: true
  }

  export type RecetaCountAggregateInputType = {
    id?: true
    usuarioId?: true
    titulo?: true
    descripcion?: true
    tiempoPreparacion?: true
    porciones?: true
    imagen?: true
    fechaCreacion?: true
    idTipoComida?: true
    idTipoSabor?: true
    dificultad?: true
    _all?: true
  }

  export type RecetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receta to aggregate.
     */
    where?: RecetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recetas to fetch.
     */
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recetas
    **/
    _count?: true | RecetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetaMaxAggregateInputType
  }

  export type GetRecetaAggregateType<T extends RecetaAggregateArgs> = {
        [P in keyof T & keyof AggregateReceta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceta[P]>
      : GetScalarType<T[P], AggregateReceta[P]>
  }




  export type RecetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaWhereInput
    orderBy?: RecetaOrderByWithAggregationInput | RecetaOrderByWithAggregationInput[]
    by: RecetaScalarFieldEnum[] | RecetaScalarFieldEnum
    having?: RecetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetaCountAggregateInputType | true
    _avg?: RecetaAvgAggregateInputType
    _sum?: RecetaSumAggregateInputType
    _min?: RecetaMinAggregateInputType
    _max?: RecetaMaxAggregateInputType
  }

  export type RecetaGroupByOutputType = {
    id: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion: Date
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    _count: RecetaCountAggregateOutputType | null
    _avg: RecetaAvgAggregateOutputType | null
    _sum: RecetaSumAggregateOutputType | null
    _min: RecetaMinAggregateOutputType | null
    _max: RecetaMaxAggregateOutputType | null
  }

  type GetRecetaGroupByPayload<T extends RecetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetaGroupByOutputType[P]>
            : GetScalarType<T[P], RecetaGroupByOutputType[P]>
        }
      >
    >


  export type RecetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tiempoPreparacion?: boolean
    porciones?: boolean
    imagen?: boolean
    fechaCreacion?: boolean
    idTipoComida?: boolean
    idTipoSabor?: boolean
    dificultad?: boolean
    Calificacion?: boolean | Receta$CalificacionArgs<ExtArgs>
    Comentario?: boolean | Receta$ComentarioArgs<ExtArgs>
    Favorito?: boolean | Receta$FavoritoArgs<ExtArgs>
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    RecetaIngrediente?: boolean | Receta$RecetaIngredienteArgs<ExtArgs>
    Reporte?: boolean | Receta$ReporteArgs<ExtArgs>
    _count?: boolean | RecetaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type RecetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tiempoPreparacion?: boolean
    porciones?: boolean
    imagen?: boolean
    fechaCreacion?: boolean
    idTipoComida?: boolean
    idTipoSabor?: boolean
    dificultad?: boolean
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type RecetaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tiempoPreparacion?: boolean
    porciones?: boolean
    imagen?: boolean
    fechaCreacion?: boolean
    idTipoComida?: boolean
    idTipoSabor?: boolean
    dificultad?: boolean
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receta"]>

  export type RecetaSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    titulo?: boolean
    descripcion?: boolean
    tiempoPreparacion?: boolean
    porciones?: boolean
    imagen?: boolean
    fechaCreacion?: boolean
    idTipoComida?: boolean
    idTipoSabor?: boolean
    dificultad?: boolean
  }

  export type RecetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "titulo" | "descripcion" | "tiempoPreparacion" | "porciones" | "imagen" | "fechaCreacion" | "idTipoComida" | "idTipoSabor" | "dificultad", ExtArgs["result"]["receta"]>
  export type RecetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Calificacion?: boolean | Receta$CalificacionArgs<ExtArgs>
    Comentario?: boolean | Receta$ComentarioArgs<ExtArgs>
    Favorito?: boolean | Receta$FavoritoArgs<ExtArgs>
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    RecetaIngrediente?: boolean | Receta$RecetaIngredienteArgs<ExtArgs>
    Reporte?: boolean | Receta$ReporteArgs<ExtArgs>
    _count?: boolean | RecetaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecetaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RecetaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TipoComida?: boolean | TipoComidaDefaultArgs<ExtArgs>
    TipoSabor?: boolean | TipoSaborDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RecetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receta"
    objects: {
      Calificacion: Prisma.$CalificacionPayload<ExtArgs>[]
      Comentario: Prisma.$ComentarioPayload<ExtArgs>[]
      Favorito: Prisma.$FavoritoPayload<ExtArgs>[]
      TipoComida: Prisma.$TipoComidaPayload<ExtArgs>
      TipoSabor: Prisma.$TipoSaborPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      RecetaIngrediente: Prisma.$RecetaIngredientePayload<ExtArgs>[]
      Reporte: Prisma.$ReportePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      titulo: string
      descripcion: string
      tiempoPreparacion: number
      porciones: number
      imagen: string
      fechaCreacion: Date
      idTipoComida: number
      idTipoSabor: number
      dificultad: $Enums.DificultadReceta
    }, ExtArgs["result"]["receta"]>
    composites: {}
  }

  type RecetaGetPayload<S extends boolean | null | undefined | RecetaDefaultArgs> = $Result.GetResult<Prisma.$RecetaPayload, S>

  type RecetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecetaCountAggregateInputType | true
    }

  export interface RecetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receta'], meta: { name: 'Receta' } }
    /**
     * Find zero or one Receta that matches the filter.
     * @param {RecetaFindUniqueArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecetaFindUniqueArgs>(args: SelectSubset<T, RecetaFindUniqueArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecetaFindUniqueOrThrowArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecetaFindUniqueOrThrowArgs>(args: SelectSubset<T, RecetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaFindFirstArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecetaFindFirstArgs>(args?: SelectSubset<T, RecetaFindFirstArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaFindFirstOrThrowArgs} args - Arguments to find a Receta
     * @example
     * // Get one Receta
     * const receta = await prisma.receta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecetaFindFirstOrThrowArgs>(args?: SelectSubset<T, RecetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recetas
     * const recetas = await prisma.receta.findMany()
     * 
     * // Get first 10 Recetas
     * const recetas = await prisma.receta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recetaWithIdOnly = await prisma.receta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecetaFindManyArgs>(args?: SelectSubset<T, RecetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receta.
     * @param {RecetaCreateArgs} args - Arguments to create a Receta.
     * @example
     * // Create one Receta
     * const Receta = await prisma.receta.create({
     *   data: {
     *     // ... data to create a Receta
     *   }
     * })
     * 
     */
    create<T extends RecetaCreateArgs>(args: SelectSubset<T, RecetaCreateArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recetas.
     * @param {RecetaCreateManyArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const receta = await prisma.receta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecetaCreateManyArgs>(args?: SelectSubset<T, RecetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recetas and returns the data saved in the database.
     * @param {RecetaCreateManyAndReturnArgs} args - Arguments to create many Recetas.
     * @example
     * // Create many Recetas
     * const receta = await prisma.receta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recetas and only return the `id`
     * const recetaWithIdOnly = await prisma.receta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecetaCreateManyAndReturnArgs>(args?: SelectSubset<T, RecetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receta.
     * @param {RecetaDeleteArgs} args - Arguments to delete one Receta.
     * @example
     * // Delete one Receta
     * const Receta = await prisma.receta.delete({
     *   where: {
     *     // ... filter to delete one Receta
     *   }
     * })
     * 
     */
    delete<T extends RecetaDeleteArgs>(args: SelectSubset<T, RecetaDeleteArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receta.
     * @param {RecetaUpdateArgs} args - Arguments to update one Receta.
     * @example
     * // Update one Receta
     * const receta = await prisma.receta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecetaUpdateArgs>(args: SelectSubset<T, RecetaUpdateArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recetas.
     * @param {RecetaDeleteManyArgs} args - Arguments to filter Recetas to delete.
     * @example
     * // Delete a few Recetas
     * const { count } = await prisma.receta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecetaDeleteManyArgs>(args?: SelectSubset<T, RecetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recetas
     * const receta = await prisma.receta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecetaUpdateManyArgs>(args: SelectSubset<T, RecetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetas and returns the data updated in the database.
     * @param {RecetaUpdateManyAndReturnArgs} args - Arguments to update many Recetas.
     * @example
     * // Update many Recetas
     * const receta = await prisma.receta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recetas and only return the `id`
     * const recetaWithIdOnly = await prisma.receta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecetaUpdateManyAndReturnArgs>(args: SelectSubset<T, RecetaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receta.
     * @param {RecetaUpsertArgs} args - Arguments to update or create a Receta.
     * @example
     * // Update or create a Receta
     * const receta = await prisma.receta.upsert({
     *   create: {
     *     // ... data to create a Receta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receta we want to update
     *   }
     * })
     */
    upsert<T extends RecetaUpsertArgs>(args: SelectSubset<T, RecetaUpsertArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaCountArgs} args - Arguments to filter Recetas to count.
     * @example
     * // Count the number of Recetas
     * const count = await prisma.receta.count({
     *   where: {
     *     // ... the filter for the Recetas we want to count
     *   }
     * })
    **/
    count<T extends RecetaCountArgs>(
      args?: Subset<T, RecetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetaAggregateArgs>(args: Subset<T, RecetaAggregateArgs>): Prisma.PrismaPromise<GetRecetaAggregateType<T>>

    /**
     * Group by Receta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetaGroupByArgs['orderBy'] }
        : { orderBy?: RecetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receta model
   */
  readonly fields: RecetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Calificacion<T extends Receta$CalificacionArgs<ExtArgs> = {}>(args?: Subset<T, Receta$CalificacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comentario<T extends Receta$ComentarioArgs<ExtArgs> = {}>(args?: Subset<T, Receta$ComentarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Favorito<T extends Receta$FavoritoArgs<ExtArgs> = {}>(args?: Subset<T, Receta$FavoritoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TipoComida<T extends TipoComidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoComidaDefaultArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TipoSabor<T extends TipoSaborDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoSaborDefaultArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RecetaIngrediente<T extends Receta$RecetaIngredienteArgs<ExtArgs> = {}>(args?: Subset<T, Receta$RecetaIngredienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reporte<T extends Receta$ReporteArgs<ExtArgs> = {}>(args?: Subset<T, Receta$ReporteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receta model
   */
  interface RecetaFieldRefs {
    readonly id: FieldRef<"Receta", 'Int'>
    readonly usuarioId: FieldRef<"Receta", 'Int'>
    readonly titulo: FieldRef<"Receta", 'String'>
    readonly descripcion: FieldRef<"Receta", 'String'>
    readonly tiempoPreparacion: FieldRef<"Receta", 'Int'>
    readonly porciones: FieldRef<"Receta", 'Int'>
    readonly imagen: FieldRef<"Receta", 'String'>
    readonly fechaCreacion: FieldRef<"Receta", 'DateTime'>
    readonly idTipoComida: FieldRef<"Receta", 'Int'>
    readonly idTipoSabor: FieldRef<"Receta", 'Int'>
    readonly dificultad: FieldRef<"Receta", 'DificultadReceta'>
  }
    

  // Custom InputTypes
  /**
   * Receta findUnique
   */
  export type RecetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter, which Receta to fetch.
     */
    where: RecetaWhereUniqueInput
  }

  /**
   * Receta findUniqueOrThrow
   */
  export type RecetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter, which Receta to fetch.
     */
    where: RecetaWhereUniqueInput
  }

  /**
   * Receta findFirst
   */
  export type RecetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter, which Receta to fetch.
     */
    where?: RecetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recetas to fetch.
     */
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recetas.
     */
    cursor?: RecetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recetas.
     */
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * Receta findFirstOrThrow
   */
  export type RecetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter, which Receta to fetch.
     */
    where?: RecetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recetas to fetch.
     */
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recetas.
     */
    cursor?: RecetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recetas.
     */
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * Receta findMany
   */
  export type RecetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter, which Recetas to fetch.
     */
    where?: RecetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recetas to fetch.
     */
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recetas.
     */
    cursor?: RecetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recetas.
     */
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * Receta create
   */
  export type RecetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * The data needed to create a Receta.
     */
    data: XOR<RecetaCreateInput, RecetaUncheckedCreateInput>
  }

  /**
   * Receta createMany
   */
  export type RecetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recetas.
     */
    data: RecetaCreateManyInput | RecetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receta createManyAndReturn
   */
  export type RecetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * The data used to create many Recetas.
     */
    data: RecetaCreateManyInput | RecetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receta update
   */
  export type RecetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * The data needed to update a Receta.
     */
    data: XOR<RecetaUpdateInput, RecetaUncheckedUpdateInput>
    /**
     * Choose, which Receta to update.
     */
    where: RecetaWhereUniqueInput
  }

  /**
   * Receta updateMany
   */
  export type RecetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recetas.
     */
    data: XOR<RecetaUpdateManyMutationInput, RecetaUncheckedUpdateManyInput>
    /**
     * Filter which Recetas to update
     */
    where?: RecetaWhereInput
    /**
     * Limit how many Recetas to update.
     */
    limit?: number
  }

  /**
   * Receta updateManyAndReturn
   */
  export type RecetaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * The data used to update Recetas.
     */
    data: XOR<RecetaUpdateManyMutationInput, RecetaUncheckedUpdateManyInput>
    /**
     * Filter which Recetas to update
     */
    where?: RecetaWhereInput
    /**
     * Limit how many Recetas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receta upsert
   */
  export type RecetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * The filter to search for the Receta to update in case it exists.
     */
    where: RecetaWhereUniqueInput
    /**
     * In case the Receta found by the `where` argument doesn't exist, create a new Receta with this data.
     */
    create: XOR<RecetaCreateInput, RecetaUncheckedCreateInput>
    /**
     * In case the Receta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecetaUpdateInput, RecetaUncheckedUpdateInput>
  }

  /**
   * Receta delete
   */
  export type RecetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    /**
     * Filter which Receta to delete.
     */
    where: RecetaWhereUniqueInput
  }

  /**
   * Receta deleteMany
   */
  export type RecetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recetas to delete
     */
    where?: RecetaWhereInput
    /**
     * Limit how many Recetas to delete.
     */
    limit?: number
  }

  /**
   * Receta.Calificacion
   */
  export type Receta$CalificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    cursor?: CalificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Receta.Comentario
   */
  export type Receta$ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Receta.Favorito
   */
  export type Receta$FavoritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    cursor?: FavoritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Receta.RecetaIngrediente
   */
  export type Receta$RecetaIngredienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    where?: RecetaIngredienteWhereInput
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    cursor?: RecetaIngredienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaIngredienteScalarFieldEnum | RecetaIngredienteScalarFieldEnum[]
  }

  /**
   * Receta.Reporte
   */
  export type Receta$ReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    where?: ReporteWhereInput
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    cursor?: ReporteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Receta without action
   */
  export type RecetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
  }


  /**
   * Model RecetaIngrediente
   */

  export type AggregateRecetaIngrediente = {
    _count: RecetaIngredienteCountAggregateOutputType | null
    _avg: RecetaIngredienteAvgAggregateOutputType | null
    _sum: RecetaIngredienteSumAggregateOutputType | null
    _min: RecetaIngredienteMinAggregateOutputType | null
    _max: RecetaIngredienteMaxAggregateOutputType | null
  }

  export type RecetaIngredienteAvgAggregateOutputType = {
    id: number | null
    recetaId: number | null
    ingredienteId: number | null
  }

  export type RecetaIngredienteSumAggregateOutputType = {
    id: number | null
    recetaId: number | null
    ingredienteId: number | null
  }

  export type RecetaIngredienteMinAggregateOutputType = {
    id: number | null
    recetaId: number | null
    ingredienteId: number | null
    cantidad: string | null
  }

  export type RecetaIngredienteMaxAggregateOutputType = {
    id: number | null
    recetaId: number | null
    ingredienteId: number | null
    cantidad: string | null
  }

  export type RecetaIngredienteCountAggregateOutputType = {
    id: number
    recetaId: number
    ingredienteId: number
    cantidad: number
    _all: number
  }


  export type RecetaIngredienteAvgAggregateInputType = {
    id?: true
    recetaId?: true
    ingredienteId?: true
  }

  export type RecetaIngredienteSumAggregateInputType = {
    id?: true
    recetaId?: true
    ingredienteId?: true
  }

  export type RecetaIngredienteMinAggregateInputType = {
    id?: true
    recetaId?: true
    ingredienteId?: true
    cantidad?: true
  }

  export type RecetaIngredienteMaxAggregateInputType = {
    id?: true
    recetaId?: true
    ingredienteId?: true
    cantidad?: true
  }

  export type RecetaIngredienteCountAggregateInputType = {
    id?: true
    recetaId?: true
    ingredienteId?: true
    cantidad?: true
    _all?: true
  }

  export type RecetaIngredienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetaIngrediente to aggregate.
     */
    where?: RecetaIngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetaIngredientes to fetch.
     */
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecetaIngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetaIngredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetaIngredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecetaIngredientes
    **/
    _count?: true | RecetaIngredienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetaIngredienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetaIngredienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetaIngredienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetaIngredienteMaxAggregateInputType
  }

  export type GetRecetaIngredienteAggregateType<T extends RecetaIngredienteAggregateArgs> = {
        [P in keyof T & keyof AggregateRecetaIngrediente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecetaIngrediente[P]>
      : GetScalarType<T[P], AggregateRecetaIngrediente[P]>
  }




  export type RecetaIngredienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecetaIngredienteWhereInput
    orderBy?: RecetaIngredienteOrderByWithAggregationInput | RecetaIngredienteOrderByWithAggregationInput[]
    by: RecetaIngredienteScalarFieldEnum[] | RecetaIngredienteScalarFieldEnum
    having?: RecetaIngredienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetaIngredienteCountAggregateInputType | true
    _avg?: RecetaIngredienteAvgAggregateInputType
    _sum?: RecetaIngredienteSumAggregateInputType
    _min?: RecetaIngredienteMinAggregateInputType
    _max?: RecetaIngredienteMaxAggregateInputType
  }

  export type RecetaIngredienteGroupByOutputType = {
    id: number
    recetaId: number
    ingredienteId: number
    cantidad: string
    _count: RecetaIngredienteCountAggregateOutputType | null
    _avg: RecetaIngredienteAvgAggregateOutputType | null
    _sum: RecetaIngredienteSumAggregateOutputType | null
    _min: RecetaIngredienteMinAggregateOutputType | null
    _max: RecetaIngredienteMaxAggregateOutputType | null
  }

  type GetRecetaIngredienteGroupByPayload<T extends RecetaIngredienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecetaIngredienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetaIngredienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetaIngredienteGroupByOutputType[P]>
            : GetScalarType<T[P], RecetaIngredienteGroupByOutputType[P]>
        }
      >
    >


  export type RecetaIngredienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recetaId?: boolean
    ingredienteId?: boolean
    cantidad?: boolean
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recetaIngrediente"]>

  export type RecetaIngredienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recetaId?: boolean
    ingredienteId?: boolean
    cantidad?: boolean
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recetaIngrediente"]>

  export type RecetaIngredienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recetaId?: boolean
    ingredienteId?: boolean
    cantidad?: boolean
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recetaIngrediente"]>

  export type RecetaIngredienteSelectScalar = {
    id?: boolean
    recetaId?: boolean
    ingredienteId?: boolean
    cantidad?: boolean
  }

  export type RecetaIngredienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recetaId" | "ingredienteId" | "cantidad", ExtArgs["result"]["recetaIngrediente"]>
  export type RecetaIngredienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }
  export type RecetaIngredienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }
  export type RecetaIngredienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ingrediente?: boolean | IngredienteDefaultArgs<ExtArgs>
    Receta?: boolean | RecetaDefaultArgs<ExtArgs>
  }

  export type $RecetaIngredientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecetaIngrediente"
    objects: {
      Ingrediente: Prisma.$IngredientePayload<ExtArgs>
      Receta: Prisma.$RecetaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recetaId: number
      ingredienteId: number
      cantidad: string
    }, ExtArgs["result"]["recetaIngrediente"]>
    composites: {}
  }

  type RecetaIngredienteGetPayload<S extends boolean | null | undefined | RecetaIngredienteDefaultArgs> = $Result.GetResult<Prisma.$RecetaIngredientePayload, S>

  type RecetaIngredienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecetaIngredienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecetaIngredienteCountAggregateInputType | true
    }

  export interface RecetaIngredienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecetaIngrediente'], meta: { name: 'RecetaIngrediente' } }
    /**
     * Find zero or one RecetaIngrediente that matches the filter.
     * @param {RecetaIngredienteFindUniqueArgs} args - Arguments to find a RecetaIngrediente
     * @example
     * // Get one RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecetaIngredienteFindUniqueArgs>(args: SelectSubset<T, RecetaIngredienteFindUniqueArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecetaIngrediente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecetaIngredienteFindUniqueOrThrowArgs} args - Arguments to find a RecetaIngrediente
     * @example
     * // Get one RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecetaIngredienteFindUniqueOrThrowArgs>(args: SelectSubset<T, RecetaIngredienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetaIngrediente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteFindFirstArgs} args - Arguments to find a RecetaIngrediente
     * @example
     * // Get one RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecetaIngredienteFindFirstArgs>(args?: SelectSubset<T, RecetaIngredienteFindFirstArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecetaIngrediente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteFindFirstOrThrowArgs} args - Arguments to find a RecetaIngrediente
     * @example
     * // Get one RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecetaIngredienteFindFirstOrThrowArgs>(args?: SelectSubset<T, RecetaIngredienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecetaIngredientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecetaIngredientes
     * const recetaIngredientes = await prisma.recetaIngrediente.findMany()
     * 
     * // Get first 10 RecetaIngredientes
     * const recetaIngredientes = await prisma.recetaIngrediente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recetaIngredienteWithIdOnly = await prisma.recetaIngrediente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecetaIngredienteFindManyArgs>(args?: SelectSubset<T, RecetaIngredienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecetaIngrediente.
     * @param {RecetaIngredienteCreateArgs} args - Arguments to create a RecetaIngrediente.
     * @example
     * // Create one RecetaIngrediente
     * const RecetaIngrediente = await prisma.recetaIngrediente.create({
     *   data: {
     *     // ... data to create a RecetaIngrediente
     *   }
     * })
     * 
     */
    create<T extends RecetaIngredienteCreateArgs>(args: SelectSubset<T, RecetaIngredienteCreateArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecetaIngredientes.
     * @param {RecetaIngredienteCreateManyArgs} args - Arguments to create many RecetaIngredientes.
     * @example
     * // Create many RecetaIngredientes
     * const recetaIngrediente = await prisma.recetaIngrediente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecetaIngredienteCreateManyArgs>(args?: SelectSubset<T, RecetaIngredienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecetaIngredientes and returns the data saved in the database.
     * @param {RecetaIngredienteCreateManyAndReturnArgs} args - Arguments to create many RecetaIngredientes.
     * @example
     * // Create many RecetaIngredientes
     * const recetaIngrediente = await prisma.recetaIngrediente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecetaIngredientes and only return the `id`
     * const recetaIngredienteWithIdOnly = await prisma.recetaIngrediente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecetaIngredienteCreateManyAndReturnArgs>(args?: SelectSubset<T, RecetaIngredienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecetaIngrediente.
     * @param {RecetaIngredienteDeleteArgs} args - Arguments to delete one RecetaIngrediente.
     * @example
     * // Delete one RecetaIngrediente
     * const RecetaIngrediente = await prisma.recetaIngrediente.delete({
     *   where: {
     *     // ... filter to delete one RecetaIngrediente
     *   }
     * })
     * 
     */
    delete<T extends RecetaIngredienteDeleteArgs>(args: SelectSubset<T, RecetaIngredienteDeleteArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecetaIngrediente.
     * @param {RecetaIngredienteUpdateArgs} args - Arguments to update one RecetaIngrediente.
     * @example
     * // Update one RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecetaIngredienteUpdateArgs>(args: SelectSubset<T, RecetaIngredienteUpdateArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecetaIngredientes.
     * @param {RecetaIngredienteDeleteManyArgs} args - Arguments to filter RecetaIngredientes to delete.
     * @example
     * // Delete a few RecetaIngredientes
     * const { count } = await prisma.recetaIngrediente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecetaIngredienteDeleteManyArgs>(args?: SelectSubset<T, RecetaIngredienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecetaIngredientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecetaIngredientes
     * const recetaIngrediente = await prisma.recetaIngrediente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecetaIngredienteUpdateManyArgs>(args: SelectSubset<T, RecetaIngredienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecetaIngredientes and returns the data updated in the database.
     * @param {RecetaIngredienteUpdateManyAndReturnArgs} args - Arguments to update many RecetaIngredientes.
     * @example
     * // Update many RecetaIngredientes
     * const recetaIngrediente = await prisma.recetaIngrediente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecetaIngredientes and only return the `id`
     * const recetaIngredienteWithIdOnly = await prisma.recetaIngrediente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecetaIngredienteUpdateManyAndReturnArgs>(args: SelectSubset<T, RecetaIngredienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecetaIngrediente.
     * @param {RecetaIngredienteUpsertArgs} args - Arguments to update or create a RecetaIngrediente.
     * @example
     * // Update or create a RecetaIngrediente
     * const recetaIngrediente = await prisma.recetaIngrediente.upsert({
     *   create: {
     *     // ... data to create a RecetaIngrediente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecetaIngrediente we want to update
     *   }
     * })
     */
    upsert<T extends RecetaIngredienteUpsertArgs>(args: SelectSubset<T, RecetaIngredienteUpsertArgs<ExtArgs>>): Prisma__RecetaIngredienteClient<$Result.GetResult<Prisma.$RecetaIngredientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecetaIngredientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteCountArgs} args - Arguments to filter RecetaIngredientes to count.
     * @example
     * // Count the number of RecetaIngredientes
     * const count = await prisma.recetaIngrediente.count({
     *   where: {
     *     // ... the filter for the RecetaIngredientes we want to count
     *   }
     * })
    **/
    count<T extends RecetaIngredienteCountArgs>(
      args?: Subset<T, RecetaIngredienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetaIngredienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecetaIngrediente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetaIngredienteAggregateArgs>(args: Subset<T, RecetaIngredienteAggregateArgs>): Prisma.PrismaPromise<GetRecetaIngredienteAggregateType<T>>

    /**
     * Group by RecetaIngrediente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetaIngredienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetaIngredienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetaIngredienteGroupByArgs['orderBy'] }
        : { orderBy?: RecetaIngredienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetaIngredienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetaIngredienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecetaIngrediente model
   */
  readonly fields: RecetaIngredienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecetaIngrediente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecetaIngredienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ingrediente<T extends IngredienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredienteDefaultArgs<ExtArgs>>): Prisma__IngredienteClient<$Result.GetResult<Prisma.$IngredientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receta<T extends RecetaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecetaDefaultArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecetaIngrediente model
   */
  interface RecetaIngredienteFieldRefs {
    readonly id: FieldRef<"RecetaIngrediente", 'Int'>
    readonly recetaId: FieldRef<"RecetaIngrediente", 'Int'>
    readonly ingredienteId: FieldRef<"RecetaIngrediente", 'Int'>
    readonly cantidad: FieldRef<"RecetaIngrediente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecetaIngrediente findUnique
   */
  export type RecetaIngredienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter, which RecetaIngrediente to fetch.
     */
    where: RecetaIngredienteWhereUniqueInput
  }

  /**
   * RecetaIngrediente findUniqueOrThrow
   */
  export type RecetaIngredienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter, which RecetaIngrediente to fetch.
     */
    where: RecetaIngredienteWhereUniqueInput
  }

  /**
   * RecetaIngrediente findFirst
   */
  export type RecetaIngredienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter, which RecetaIngrediente to fetch.
     */
    where?: RecetaIngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetaIngredientes to fetch.
     */
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetaIngredientes.
     */
    cursor?: RecetaIngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetaIngredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetaIngredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetaIngredientes.
     */
    distinct?: RecetaIngredienteScalarFieldEnum | RecetaIngredienteScalarFieldEnum[]
  }

  /**
   * RecetaIngrediente findFirstOrThrow
   */
  export type RecetaIngredienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter, which RecetaIngrediente to fetch.
     */
    where?: RecetaIngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetaIngredientes to fetch.
     */
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecetaIngredientes.
     */
    cursor?: RecetaIngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetaIngredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetaIngredientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecetaIngredientes.
     */
    distinct?: RecetaIngredienteScalarFieldEnum | RecetaIngredienteScalarFieldEnum[]
  }

  /**
   * RecetaIngrediente findMany
   */
  export type RecetaIngredienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter, which RecetaIngredientes to fetch.
     */
    where?: RecetaIngredienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecetaIngredientes to fetch.
     */
    orderBy?: RecetaIngredienteOrderByWithRelationInput | RecetaIngredienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecetaIngredientes.
     */
    cursor?: RecetaIngredienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecetaIngredientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecetaIngredientes.
     */
    skip?: number
    distinct?: RecetaIngredienteScalarFieldEnum | RecetaIngredienteScalarFieldEnum[]
  }

  /**
   * RecetaIngrediente create
   */
  export type RecetaIngredienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * The data needed to create a RecetaIngrediente.
     */
    data: XOR<RecetaIngredienteCreateInput, RecetaIngredienteUncheckedCreateInput>
  }

  /**
   * RecetaIngrediente createMany
   */
  export type RecetaIngredienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecetaIngredientes.
     */
    data: RecetaIngredienteCreateManyInput | RecetaIngredienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecetaIngrediente createManyAndReturn
   */
  export type RecetaIngredienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * The data used to create many RecetaIngredientes.
     */
    data: RecetaIngredienteCreateManyInput | RecetaIngredienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecetaIngrediente update
   */
  export type RecetaIngredienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * The data needed to update a RecetaIngrediente.
     */
    data: XOR<RecetaIngredienteUpdateInput, RecetaIngredienteUncheckedUpdateInput>
    /**
     * Choose, which RecetaIngrediente to update.
     */
    where: RecetaIngredienteWhereUniqueInput
  }

  /**
   * RecetaIngrediente updateMany
   */
  export type RecetaIngredienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecetaIngredientes.
     */
    data: XOR<RecetaIngredienteUpdateManyMutationInput, RecetaIngredienteUncheckedUpdateManyInput>
    /**
     * Filter which RecetaIngredientes to update
     */
    where?: RecetaIngredienteWhereInput
    /**
     * Limit how many RecetaIngredientes to update.
     */
    limit?: number
  }

  /**
   * RecetaIngrediente updateManyAndReturn
   */
  export type RecetaIngredienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * The data used to update RecetaIngredientes.
     */
    data: XOR<RecetaIngredienteUpdateManyMutationInput, RecetaIngredienteUncheckedUpdateManyInput>
    /**
     * Filter which RecetaIngredientes to update
     */
    where?: RecetaIngredienteWhereInput
    /**
     * Limit how many RecetaIngredientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecetaIngrediente upsert
   */
  export type RecetaIngredienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * The filter to search for the RecetaIngrediente to update in case it exists.
     */
    where: RecetaIngredienteWhereUniqueInput
    /**
     * In case the RecetaIngrediente found by the `where` argument doesn't exist, create a new RecetaIngrediente with this data.
     */
    create: XOR<RecetaIngredienteCreateInput, RecetaIngredienteUncheckedCreateInput>
    /**
     * In case the RecetaIngrediente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecetaIngredienteUpdateInput, RecetaIngredienteUncheckedUpdateInput>
  }

  /**
   * RecetaIngrediente delete
   */
  export type RecetaIngredienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
    /**
     * Filter which RecetaIngrediente to delete.
     */
    where: RecetaIngredienteWhereUniqueInput
  }

  /**
   * RecetaIngrediente deleteMany
   */
  export type RecetaIngredienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecetaIngredientes to delete
     */
    where?: RecetaIngredienteWhereInput
    /**
     * Limit how many RecetaIngredientes to delete.
     */
    limit?: number
  }

  /**
   * RecetaIngrediente without action
   */
  export type RecetaIngredienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecetaIngrediente
     */
    select?: RecetaIngredienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecetaIngrediente
     */
    omit?: RecetaIngredienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaIngredienteInclude<ExtArgs> | null
  }


  /**
   * Model Reporte
   */

  export type AggregateReporte = {
    _count: ReporteCountAggregateOutputType | null
    _avg: ReporteAvgAggregateOutputType | null
    _sum: ReporteSumAggregateOutputType | null
    _min: ReporteMinAggregateOutputType | null
    _max: ReporteMaxAggregateOutputType | null
  }

  export type ReporteAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentarioId: number | null
  }

  export type ReporteSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentarioId: number | null
  }

  export type ReporteMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentarioId: number | null
    motivo: string | null
    estado: string | null
    fechaReporte: Date | null
  }

  export type ReporteMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    recetaId: number | null
    comentarioId: number | null
    motivo: string | null
    estado: string | null
    fechaReporte: Date | null
  }

  export type ReporteCountAggregateOutputType = {
    id: number
    usuarioId: number
    recetaId: number
    comentarioId: number
    motivo: number
    estado: number
    fechaReporte: number
    _all: number
  }


  export type ReporteAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentarioId?: true
  }

  export type ReporteSumAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentarioId?: true
  }

  export type ReporteMinAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentarioId?: true
    motivo?: true
    estado?: true
    fechaReporte?: true
  }

  export type ReporteMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentarioId?: true
    motivo?: true
    estado?: true
    fechaReporte?: true
  }

  export type ReporteCountAggregateInputType = {
    id?: true
    usuarioId?: true
    recetaId?: true
    comentarioId?: true
    motivo?: true
    estado?: true
    fechaReporte?: true
    _all?: true
  }

  export type ReporteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reporte to aggregate.
     */
    where?: ReporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reportes
    **/
    _count?: true | ReporteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReporteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReporteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReporteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReporteMaxAggregateInputType
  }

  export type GetReporteAggregateType<T extends ReporteAggregateArgs> = {
        [P in keyof T & keyof AggregateReporte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReporte[P]>
      : GetScalarType<T[P], AggregateReporte[P]>
  }




  export type ReporteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteWhereInput
    orderBy?: ReporteOrderByWithAggregationInput | ReporteOrderByWithAggregationInput[]
    by: ReporteScalarFieldEnum[] | ReporteScalarFieldEnum
    having?: ReporteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReporteCountAggregateInputType | true
    _avg?: ReporteAvgAggregateInputType
    _sum?: ReporteSumAggregateInputType
    _min?: ReporteMinAggregateInputType
    _max?: ReporteMaxAggregateInputType
  }

  export type ReporteGroupByOutputType = {
    id: number
    usuarioId: number
    recetaId: number | null
    comentarioId: number | null
    motivo: string
    estado: string
    fechaReporte: Date
    _count: ReporteCountAggregateOutputType | null
    _avg: ReporteAvgAggregateOutputType | null
    _sum: ReporteSumAggregateOutputType | null
    _min: ReporteMinAggregateOutputType | null
    _max: ReporteMaxAggregateOutputType | null
  }

  type GetReporteGroupByPayload<T extends ReporteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReporteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReporteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReporteGroupByOutputType[P]>
            : GetScalarType<T[P], ReporteGroupByOutputType[P]>
        }
      >
    >


  export type ReporteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentarioId?: boolean
    motivo?: boolean
    estado?: boolean
    fechaReporte?: boolean
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reporte"]>

  export type ReporteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentarioId?: boolean
    motivo?: boolean
    estado?: boolean
    fechaReporte?: boolean
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reporte"]>

  export type ReporteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentarioId?: boolean
    motivo?: boolean
    estado?: boolean
    fechaReporte?: boolean
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reporte"]>

  export type ReporteSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    recetaId?: boolean
    comentarioId?: boolean
    motivo?: boolean
    estado?: boolean
    fechaReporte?: boolean
  }

  export type ReporteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "recetaId" | "comentarioId" | "motivo" | "estado" | "fechaReporte", ExtArgs["result"]["reporte"]>
  export type ReporteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ReporteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ReporteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comentario?: boolean | Reporte$ComentarioArgs<ExtArgs>
    Receta?: boolean | Reporte$RecetaArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ReportePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reporte"
    objects: {
      Comentario: Prisma.$ComentarioPayload<ExtArgs> | null
      Receta: Prisma.$RecetaPayload<ExtArgs> | null
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      recetaId: number | null
      comentarioId: number | null
      motivo: string
      estado: string
      fechaReporte: Date
    }, ExtArgs["result"]["reporte"]>
    composites: {}
  }

  type ReporteGetPayload<S extends boolean | null | undefined | ReporteDefaultArgs> = $Result.GetResult<Prisma.$ReportePayload, S>

  type ReporteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReporteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReporteCountAggregateInputType | true
    }

  export interface ReporteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reporte'], meta: { name: 'Reporte' } }
    /**
     * Find zero or one Reporte that matches the filter.
     * @param {ReporteFindUniqueArgs} args - Arguments to find a Reporte
     * @example
     * // Get one Reporte
     * const reporte = await prisma.reporte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReporteFindUniqueArgs>(args: SelectSubset<T, ReporteFindUniqueArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reporte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReporteFindUniqueOrThrowArgs} args - Arguments to find a Reporte
     * @example
     * // Get one Reporte
     * const reporte = await prisma.reporte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReporteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReporteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reporte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteFindFirstArgs} args - Arguments to find a Reporte
     * @example
     * // Get one Reporte
     * const reporte = await prisma.reporte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReporteFindFirstArgs>(args?: SelectSubset<T, ReporteFindFirstArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reporte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteFindFirstOrThrowArgs} args - Arguments to find a Reporte
     * @example
     * // Get one Reporte
     * const reporte = await prisma.reporte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReporteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReporteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reportes
     * const reportes = await prisma.reporte.findMany()
     * 
     * // Get first 10 Reportes
     * const reportes = await prisma.reporte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reporteWithIdOnly = await prisma.reporte.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReporteFindManyArgs>(args?: SelectSubset<T, ReporteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reporte.
     * @param {ReporteCreateArgs} args - Arguments to create a Reporte.
     * @example
     * // Create one Reporte
     * const Reporte = await prisma.reporte.create({
     *   data: {
     *     // ... data to create a Reporte
     *   }
     * })
     * 
     */
    create<T extends ReporteCreateArgs>(args: SelectSubset<T, ReporteCreateArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reportes.
     * @param {ReporteCreateManyArgs} args - Arguments to create many Reportes.
     * @example
     * // Create many Reportes
     * const reporte = await prisma.reporte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReporteCreateManyArgs>(args?: SelectSubset<T, ReporteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reportes and returns the data saved in the database.
     * @param {ReporteCreateManyAndReturnArgs} args - Arguments to create many Reportes.
     * @example
     * // Create many Reportes
     * const reporte = await prisma.reporte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reportes and only return the `id`
     * const reporteWithIdOnly = await prisma.reporte.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReporteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReporteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reporte.
     * @param {ReporteDeleteArgs} args - Arguments to delete one Reporte.
     * @example
     * // Delete one Reporte
     * const Reporte = await prisma.reporte.delete({
     *   where: {
     *     // ... filter to delete one Reporte
     *   }
     * })
     * 
     */
    delete<T extends ReporteDeleteArgs>(args: SelectSubset<T, ReporteDeleteArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reporte.
     * @param {ReporteUpdateArgs} args - Arguments to update one Reporte.
     * @example
     * // Update one Reporte
     * const reporte = await prisma.reporte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReporteUpdateArgs>(args: SelectSubset<T, ReporteUpdateArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reportes.
     * @param {ReporteDeleteManyArgs} args - Arguments to filter Reportes to delete.
     * @example
     * // Delete a few Reportes
     * const { count } = await prisma.reporte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReporteDeleteManyArgs>(args?: SelectSubset<T, ReporteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reportes
     * const reporte = await prisma.reporte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReporteUpdateManyArgs>(args: SelectSubset<T, ReporteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportes and returns the data updated in the database.
     * @param {ReporteUpdateManyAndReturnArgs} args - Arguments to update many Reportes.
     * @example
     * // Update many Reportes
     * const reporte = await prisma.reporte.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reportes and only return the `id`
     * const reporteWithIdOnly = await prisma.reporte.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReporteUpdateManyAndReturnArgs>(args: SelectSubset<T, ReporteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reporte.
     * @param {ReporteUpsertArgs} args - Arguments to update or create a Reporte.
     * @example
     * // Update or create a Reporte
     * const reporte = await prisma.reporte.upsert({
     *   create: {
     *     // ... data to create a Reporte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reporte we want to update
     *   }
     * })
     */
    upsert<T extends ReporteUpsertArgs>(args: SelectSubset<T, ReporteUpsertArgs<ExtArgs>>): Prisma__ReporteClient<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteCountArgs} args - Arguments to filter Reportes to count.
     * @example
     * // Count the number of Reportes
     * const count = await prisma.reporte.count({
     *   where: {
     *     // ... the filter for the Reportes we want to count
     *   }
     * })
    **/
    count<T extends ReporteCountArgs>(
      args?: Subset<T, ReporteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReporteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReporteAggregateArgs>(args: Subset<T, ReporteAggregateArgs>): Prisma.PrismaPromise<GetReporteAggregateType<T>>

    /**
     * Group by Reporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReporteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReporteGroupByArgs['orderBy'] }
        : { orderBy?: ReporteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReporteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReporteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reporte model
   */
  readonly fields: ReporteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reporte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReporteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comentario<T extends Reporte$ComentarioArgs<ExtArgs> = {}>(args?: Subset<T, Reporte$ComentarioArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Receta<T extends Reporte$RecetaArgs<ExtArgs> = {}>(args?: Subset<T, Reporte$RecetaArgs<ExtArgs>>): Prisma__RecetaClient<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reporte model
   */
  interface ReporteFieldRefs {
    readonly id: FieldRef<"Reporte", 'Int'>
    readonly usuarioId: FieldRef<"Reporte", 'Int'>
    readonly recetaId: FieldRef<"Reporte", 'Int'>
    readonly comentarioId: FieldRef<"Reporte", 'Int'>
    readonly motivo: FieldRef<"Reporte", 'String'>
    readonly estado: FieldRef<"Reporte", 'String'>
    readonly fechaReporte: FieldRef<"Reporte", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reporte findUnique
   */
  export type ReporteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter, which Reporte to fetch.
     */
    where: ReporteWhereUniqueInput
  }

  /**
   * Reporte findUniqueOrThrow
   */
  export type ReporteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter, which Reporte to fetch.
     */
    where: ReporteWhereUniqueInput
  }

  /**
   * Reporte findFirst
   */
  export type ReporteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter, which Reporte to fetch.
     */
    where?: ReporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reportes.
     */
    cursor?: ReporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reportes.
     */
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Reporte findFirstOrThrow
   */
  export type ReporteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter, which Reporte to fetch.
     */
    where?: ReporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reportes.
     */
    cursor?: ReporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reportes.
     */
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Reporte findMany
   */
  export type ReporteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where?: ReporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reportes.
     */
    cursor?: ReporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Reporte create
   */
  export type ReporteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * The data needed to create a Reporte.
     */
    data: XOR<ReporteCreateInput, ReporteUncheckedCreateInput>
  }

  /**
   * Reporte createMany
   */
  export type ReporteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reportes.
     */
    data: ReporteCreateManyInput | ReporteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reporte createManyAndReturn
   */
  export type ReporteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * The data used to create many Reportes.
     */
    data: ReporteCreateManyInput | ReporteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reporte update
   */
  export type ReporteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * The data needed to update a Reporte.
     */
    data: XOR<ReporteUpdateInput, ReporteUncheckedUpdateInput>
    /**
     * Choose, which Reporte to update.
     */
    where: ReporteWhereUniqueInput
  }

  /**
   * Reporte updateMany
   */
  export type ReporteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reportes.
     */
    data: XOR<ReporteUpdateManyMutationInput, ReporteUncheckedUpdateManyInput>
    /**
     * Filter which Reportes to update
     */
    where?: ReporteWhereInput
    /**
     * Limit how many Reportes to update.
     */
    limit?: number
  }

  /**
   * Reporte updateManyAndReturn
   */
  export type ReporteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * The data used to update Reportes.
     */
    data: XOR<ReporteUpdateManyMutationInput, ReporteUncheckedUpdateManyInput>
    /**
     * Filter which Reportes to update
     */
    where?: ReporteWhereInput
    /**
     * Limit how many Reportes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reporte upsert
   */
  export type ReporteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * The filter to search for the Reporte to update in case it exists.
     */
    where: ReporteWhereUniqueInput
    /**
     * In case the Reporte found by the `where` argument doesn't exist, create a new Reporte with this data.
     */
    create: XOR<ReporteCreateInput, ReporteUncheckedCreateInput>
    /**
     * In case the Reporte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReporteUpdateInput, ReporteUncheckedUpdateInput>
  }

  /**
   * Reporte delete
   */
  export type ReporteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    /**
     * Filter which Reporte to delete.
     */
    where: ReporteWhereUniqueInput
  }

  /**
   * Reporte deleteMany
   */
  export type ReporteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reportes to delete
     */
    where?: ReporteWhereInput
    /**
     * Limit how many Reportes to delete.
     */
    limit?: number
  }

  /**
   * Reporte.Comentario
   */
  export type Reporte$ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
  }

  /**
   * Reporte.Receta
   */
  export type Reporte$RecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    where?: RecetaWhereInput
  }

  /**
   * Reporte without action
   */
  export type ReporteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
  }


  /**
   * Model TipoComida
   */

  export type AggregateTipoComida = {
    _count: TipoComidaCountAggregateOutputType | null
    _avg: TipoComidaAvgAggregateOutputType | null
    _sum: TipoComidaSumAggregateOutputType | null
    _min: TipoComidaMinAggregateOutputType | null
    _max: TipoComidaMaxAggregateOutputType | null
  }

  export type TipoComidaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoComidaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoComidaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type TipoComidaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type TipoComidaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type TipoComidaAvgAggregateInputType = {
    id?: true
  }

  export type TipoComidaSumAggregateInputType = {
    id?: true
  }

  export type TipoComidaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type TipoComidaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type TipoComidaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type TipoComidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoComida to aggregate.
     */
    where?: TipoComidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoComidas to fetch.
     */
    orderBy?: TipoComidaOrderByWithRelationInput | TipoComidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoComidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoComidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoComidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoComidas
    **/
    _count?: true | TipoComidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoComidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoComidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoComidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoComidaMaxAggregateInputType
  }

  export type GetTipoComidaAggregateType<T extends TipoComidaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoComida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoComida[P]>
      : GetScalarType<T[P], AggregateTipoComida[P]>
  }




  export type TipoComidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoComidaWhereInput
    orderBy?: TipoComidaOrderByWithAggregationInput | TipoComidaOrderByWithAggregationInput[]
    by: TipoComidaScalarFieldEnum[] | TipoComidaScalarFieldEnum
    having?: TipoComidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoComidaCountAggregateInputType | true
    _avg?: TipoComidaAvgAggregateInputType
    _sum?: TipoComidaSumAggregateInputType
    _min?: TipoComidaMinAggregateInputType
    _max?: TipoComidaMaxAggregateInputType
  }

  export type TipoComidaGroupByOutputType = {
    id: number
    nombre: string
    _count: TipoComidaCountAggregateOutputType | null
    _avg: TipoComidaAvgAggregateOutputType | null
    _sum: TipoComidaSumAggregateOutputType | null
    _min: TipoComidaMinAggregateOutputType | null
    _max: TipoComidaMaxAggregateOutputType | null
  }

  type GetTipoComidaGroupByPayload<T extends TipoComidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoComidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoComidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoComidaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoComidaGroupByOutputType[P]>
        }
      >
    >


  export type TipoComidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Receta?: boolean | TipoComida$RecetaArgs<ExtArgs>
    _count?: boolean | TipoComidaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoComida"]>

  export type TipoComidaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["tipoComida"]>

  export type TipoComidaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["tipoComida"]>

  export type TipoComidaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type TipoComidaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["tipoComida"]>
  export type TipoComidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | TipoComida$RecetaArgs<ExtArgs>
    _count?: boolean | TipoComidaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoComidaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoComidaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoComidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoComida"
    objects: {
      Receta: Prisma.$RecetaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["tipoComida"]>
    composites: {}
  }

  type TipoComidaGetPayload<S extends boolean | null | undefined | TipoComidaDefaultArgs> = $Result.GetResult<Prisma.$TipoComidaPayload, S>

  type TipoComidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoComidaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoComidaCountAggregateInputType | true
    }

  export interface TipoComidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoComida'], meta: { name: 'TipoComida' } }
    /**
     * Find zero or one TipoComida that matches the filter.
     * @param {TipoComidaFindUniqueArgs} args - Arguments to find a TipoComida
     * @example
     * // Get one TipoComida
     * const tipoComida = await prisma.tipoComida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoComidaFindUniqueArgs>(args: SelectSubset<T, TipoComidaFindUniqueArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoComida that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoComidaFindUniqueOrThrowArgs} args - Arguments to find a TipoComida
     * @example
     * // Get one TipoComida
     * const tipoComida = await prisma.tipoComida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoComidaFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoComidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoComida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaFindFirstArgs} args - Arguments to find a TipoComida
     * @example
     * // Get one TipoComida
     * const tipoComida = await prisma.tipoComida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoComidaFindFirstArgs>(args?: SelectSubset<T, TipoComidaFindFirstArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoComida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaFindFirstOrThrowArgs} args - Arguments to find a TipoComida
     * @example
     * // Get one TipoComida
     * const tipoComida = await prisma.tipoComida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoComidaFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoComidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoComidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoComidas
     * const tipoComidas = await prisma.tipoComida.findMany()
     * 
     * // Get first 10 TipoComidas
     * const tipoComidas = await prisma.tipoComida.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoComidaWithIdOnly = await prisma.tipoComida.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoComidaFindManyArgs>(args?: SelectSubset<T, TipoComidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoComida.
     * @param {TipoComidaCreateArgs} args - Arguments to create a TipoComida.
     * @example
     * // Create one TipoComida
     * const TipoComida = await prisma.tipoComida.create({
     *   data: {
     *     // ... data to create a TipoComida
     *   }
     * })
     * 
     */
    create<T extends TipoComidaCreateArgs>(args: SelectSubset<T, TipoComidaCreateArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoComidas.
     * @param {TipoComidaCreateManyArgs} args - Arguments to create many TipoComidas.
     * @example
     * // Create many TipoComidas
     * const tipoComida = await prisma.tipoComida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoComidaCreateManyArgs>(args?: SelectSubset<T, TipoComidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoComidas and returns the data saved in the database.
     * @param {TipoComidaCreateManyAndReturnArgs} args - Arguments to create many TipoComidas.
     * @example
     * // Create many TipoComidas
     * const tipoComida = await prisma.tipoComida.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoComidas and only return the `id`
     * const tipoComidaWithIdOnly = await prisma.tipoComida.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoComidaCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoComidaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoComida.
     * @param {TipoComidaDeleteArgs} args - Arguments to delete one TipoComida.
     * @example
     * // Delete one TipoComida
     * const TipoComida = await prisma.tipoComida.delete({
     *   where: {
     *     // ... filter to delete one TipoComida
     *   }
     * })
     * 
     */
    delete<T extends TipoComidaDeleteArgs>(args: SelectSubset<T, TipoComidaDeleteArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoComida.
     * @param {TipoComidaUpdateArgs} args - Arguments to update one TipoComida.
     * @example
     * // Update one TipoComida
     * const tipoComida = await prisma.tipoComida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoComidaUpdateArgs>(args: SelectSubset<T, TipoComidaUpdateArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoComidas.
     * @param {TipoComidaDeleteManyArgs} args - Arguments to filter TipoComidas to delete.
     * @example
     * // Delete a few TipoComidas
     * const { count } = await prisma.tipoComida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoComidaDeleteManyArgs>(args?: SelectSubset<T, TipoComidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoComidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoComidas
     * const tipoComida = await prisma.tipoComida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoComidaUpdateManyArgs>(args: SelectSubset<T, TipoComidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoComidas and returns the data updated in the database.
     * @param {TipoComidaUpdateManyAndReturnArgs} args - Arguments to update many TipoComidas.
     * @example
     * // Update many TipoComidas
     * const tipoComida = await prisma.tipoComida.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoComidas and only return the `id`
     * const tipoComidaWithIdOnly = await prisma.tipoComida.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoComidaUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoComidaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoComida.
     * @param {TipoComidaUpsertArgs} args - Arguments to update or create a TipoComida.
     * @example
     * // Update or create a TipoComida
     * const tipoComida = await prisma.tipoComida.upsert({
     *   create: {
     *     // ... data to create a TipoComida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoComida we want to update
     *   }
     * })
     */
    upsert<T extends TipoComidaUpsertArgs>(args: SelectSubset<T, TipoComidaUpsertArgs<ExtArgs>>): Prisma__TipoComidaClient<$Result.GetResult<Prisma.$TipoComidaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoComidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaCountArgs} args - Arguments to filter TipoComidas to count.
     * @example
     * // Count the number of TipoComidas
     * const count = await prisma.tipoComida.count({
     *   where: {
     *     // ... the filter for the TipoComidas we want to count
     *   }
     * })
    **/
    count<T extends TipoComidaCountArgs>(
      args?: Subset<T, TipoComidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoComidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoComida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoComidaAggregateArgs>(args: Subset<T, TipoComidaAggregateArgs>): Prisma.PrismaPromise<GetTipoComidaAggregateType<T>>

    /**
     * Group by TipoComida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoComidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoComidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoComidaGroupByArgs['orderBy'] }
        : { orderBy?: TipoComidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoComidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoComidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoComida model
   */
  readonly fields: TipoComidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoComida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoComidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Receta<T extends TipoComida$RecetaArgs<ExtArgs> = {}>(args?: Subset<T, TipoComida$RecetaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoComida model
   */
  interface TipoComidaFieldRefs {
    readonly id: FieldRef<"TipoComida", 'Int'>
    readonly nombre: FieldRef<"TipoComida", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoComida findUnique
   */
  export type TipoComidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter, which TipoComida to fetch.
     */
    where: TipoComidaWhereUniqueInput
  }

  /**
   * TipoComida findUniqueOrThrow
   */
  export type TipoComidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter, which TipoComida to fetch.
     */
    where: TipoComidaWhereUniqueInput
  }

  /**
   * TipoComida findFirst
   */
  export type TipoComidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter, which TipoComida to fetch.
     */
    where?: TipoComidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoComidas to fetch.
     */
    orderBy?: TipoComidaOrderByWithRelationInput | TipoComidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoComidas.
     */
    cursor?: TipoComidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoComidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoComidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoComidas.
     */
    distinct?: TipoComidaScalarFieldEnum | TipoComidaScalarFieldEnum[]
  }

  /**
   * TipoComida findFirstOrThrow
   */
  export type TipoComidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter, which TipoComida to fetch.
     */
    where?: TipoComidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoComidas to fetch.
     */
    orderBy?: TipoComidaOrderByWithRelationInput | TipoComidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoComidas.
     */
    cursor?: TipoComidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoComidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoComidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoComidas.
     */
    distinct?: TipoComidaScalarFieldEnum | TipoComidaScalarFieldEnum[]
  }

  /**
   * TipoComida findMany
   */
  export type TipoComidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter, which TipoComidas to fetch.
     */
    where?: TipoComidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoComidas to fetch.
     */
    orderBy?: TipoComidaOrderByWithRelationInput | TipoComidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoComidas.
     */
    cursor?: TipoComidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoComidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoComidas.
     */
    skip?: number
    distinct?: TipoComidaScalarFieldEnum | TipoComidaScalarFieldEnum[]
  }

  /**
   * TipoComida create
   */
  export type TipoComidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoComida.
     */
    data: XOR<TipoComidaCreateInput, TipoComidaUncheckedCreateInput>
  }

  /**
   * TipoComida createMany
   */
  export type TipoComidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoComidas.
     */
    data: TipoComidaCreateManyInput | TipoComidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoComida createManyAndReturn
   */
  export type TipoComidaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * The data used to create many TipoComidas.
     */
    data: TipoComidaCreateManyInput | TipoComidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoComida update
   */
  export type TipoComidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoComida.
     */
    data: XOR<TipoComidaUpdateInput, TipoComidaUncheckedUpdateInput>
    /**
     * Choose, which TipoComida to update.
     */
    where: TipoComidaWhereUniqueInput
  }

  /**
   * TipoComida updateMany
   */
  export type TipoComidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoComidas.
     */
    data: XOR<TipoComidaUpdateManyMutationInput, TipoComidaUncheckedUpdateManyInput>
    /**
     * Filter which TipoComidas to update
     */
    where?: TipoComidaWhereInput
    /**
     * Limit how many TipoComidas to update.
     */
    limit?: number
  }

  /**
   * TipoComida updateManyAndReturn
   */
  export type TipoComidaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * The data used to update TipoComidas.
     */
    data: XOR<TipoComidaUpdateManyMutationInput, TipoComidaUncheckedUpdateManyInput>
    /**
     * Filter which TipoComidas to update
     */
    where?: TipoComidaWhereInput
    /**
     * Limit how many TipoComidas to update.
     */
    limit?: number
  }

  /**
   * TipoComida upsert
   */
  export type TipoComidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoComida to update in case it exists.
     */
    where: TipoComidaWhereUniqueInput
    /**
     * In case the TipoComida found by the `where` argument doesn't exist, create a new TipoComida with this data.
     */
    create: XOR<TipoComidaCreateInput, TipoComidaUncheckedCreateInput>
    /**
     * In case the TipoComida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoComidaUpdateInput, TipoComidaUncheckedUpdateInput>
  }

  /**
   * TipoComida delete
   */
  export type TipoComidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
    /**
     * Filter which TipoComida to delete.
     */
    where: TipoComidaWhereUniqueInput
  }

  /**
   * TipoComida deleteMany
   */
  export type TipoComidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoComidas to delete
     */
    where?: TipoComidaWhereInput
    /**
     * Limit how many TipoComidas to delete.
     */
    limit?: number
  }

  /**
   * TipoComida.Receta
   */
  export type TipoComida$RecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    where?: RecetaWhereInput
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    cursor?: RecetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * TipoComida without action
   */
  export type TipoComidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoComida
     */
    select?: TipoComidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoComida
     */
    omit?: TipoComidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoComidaInclude<ExtArgs> | null
  }


  /**
   * Model TipoSabor
   */

  export type AggregateTipoSabor = {
    _count: TipoSaborCountAggregateOutputType | null
    _avg: TipoSaborAvgAggregateOutputType | null
    _sum: TipoSaborSumAggregateOutputType | null
    _min: TipoSaborMinAggregateOutputType | null
    _max: TipoSaborMaxAggregateOutputType | null
  }

  export type TipoSaborAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoSaborSumAggregateOutputType = {
    id: number | null
  }

  export type TipoSaborMinAggregateOutputType = {
    id: number | null
    nombreSabor: $Enums.NombreSabor | null
  }

  export type TipoSaborMaxAggregateOutputType = {
    id: number | null
    nombreSabor: $Enums.NombreSabor | null
  }

  export type TipoSaborCountAggregateOutputType = {
    id: number
    nombreSabor: number
    _all: number
  }


  export type TipoSaborAvgAggregateInputType = {
    id?: true
  }

  export type TipoSaborSumAggregateInputType = {
    id?: true
  }

  export type TipoSaborMinAggregateInputType = {
    id?: true
    nombreSabor?: true
  }

  export type TipoSaborMaxAggregateInputType = {
    id?: true
    nombreSabor?: true
  }

  export type TipoSaborCountAggregateInputType = {
    id?: true
    nombreSabor?: true
    _all?: true
  }

  export type TipoSaborAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSabor to aggregate.
     */
    where?: TipoSaborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSabors to fetch.
     */
    orderBy?: TipoSaborOrderByWithRelationInput | TipoSaborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoSaborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSabors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSabors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoSabors
    **/
    _count?: true | TipoSaborCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoSaborAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoSaborSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoSaborMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoSaborMaxAggregateInputType
  }

  export type GetTipoSaborAggregateType<T extends TipoSaborAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoSabor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoSabor[P]>
      : GetScalarType<T[P], AggregateTipoSabor[P]>
  }




  export type TipoSaborGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoSaborWhereInput
    orderBy?: TipoSaborOrderByWithAggregationInput | TipoSaborOrderByWithAggregationInput[]
    by: TipoSaborScalarFieldEnum[] | TipoSaborScalarFieldEnum
    having?: TipoSaborScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoSaborCountAggregateInputType | true
    _avg?: TipoSaborAvgAggregateInputType
    _sum?: TipoSaborSumAggregateInputType
    _min?: TipoSaborMinAggregateInputType
    _max?: TipoSaborMaxAggregateInputType
  }

  export type TipoSaborGroupByOutputType = {
    id: number
    nombreSabor: $Enums.NombreSabor
    _count: TipoSaborCountAggregateOutputType | null
    _avg: TipoSaborAvgAggregateOutputType | null
    _sum: TipoSaborSumAggregateOutputType | null
    _min: TipoSaborMinAggregateOutputType | null
    _max: TipoSaborMaxAggregateOutputType | null
  }

  type GetTipoSaborGroupByPayload<T extends TipoSaborGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoSaborGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoSaborGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoSaborGroupByOutputType[P]>
            : GetScalarType<T[P], TipoSaborGroupByOutputType[P]>
        }
      >
    >


  export type TipoSaborSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreSabor?: boolean
    Receta?: boolean | TipoSabor$RecetaArgs<ExtArgs>
    _count?: boolean | TipoSaborCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoSabor"]>

  export type TipoSaborSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreSabor?: boolean
  }, ExtArgs["result"]["tipoSabor"]>

  export type TipoSaborSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreSabor?: boolean
  }, ExtArgs["result"]["tipoSabor"]>

  export type TipoSaborSelectScalar = {
    id?: boolean
    nombreSabor?: boolean
  }

  export type TipoSaborOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombreSabor", ExtArgs["result"]["tipoSabor"]>
  export type TipoSaborInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receta?: boolean | TipoSabor$RecetaArgs<ExtArgs>
    _count?: boolean | TipoSaborCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoSaborIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoSaborIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoSaborPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoSabor"
    objects: {
      Receta: Prisma.$RecetaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombreSabor: $Enums.NombreSabor
    }, ExtArgs["result"]["tipoSabor"]>
    composites: {}
  }

  type TipoSaborGetPayload<S extends boolean | null | undefined | TipoSaborDefaultArgs> = $Result.GetResult<Prisma.$TipoSaborPayload, S>

  type TipoSaborCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoSaborFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoSaborCountAggregateInputType | true
    }

  export interface TipoSaborDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoSabor'], meta: { name: 'TipoSabor' } }
    /**
     * Find zero or one TipoSabor that matches the filter.
     * @param {TipoSaborFindUniqueArgs} args - Arguments to find a TipoSabor
     * @example
     * // Get one TipoSabor
     * const tipoSabor = await prisma.tipoSabor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoSaborFindUniqueArgs>(args: SelectSubset<T, TipoSaborFindUniqueArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoSabor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoSaborFindUniqueOrThrowArgs} args - Arguments to find a TipoSabor
     * @example
     * // Get one TipoSabor
     * const tipoSabor = await prisma.tipoSabor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoSaborFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoSaborFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSabor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborFindFirstArgs} args - Arguments to find a TipoSabor
     * @example
     * // Get one TipoSabor
     * const tipoSabor = await prisma.tipoSabor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoSaborFindFirstArgs>(args?: SelectSubset<T, TipoSaborFindFirstArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSabor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborFindFirstOrThrowArgs} args - Arguments to find a TipoSabor
     * @example
     * // Get one TipoSabor
     * const tipoSabor = await prisma.tipoSabor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoSaborFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoSaborFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoSabors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoSabors
     * const tipoSabors = await prisma.tipoSabor.findMany()
     * 
     * // Get first 10 TipoSabors
     * const tipoSabors = await prisma.tipoSabor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoSaborWithIdOnly = await prisma.tipoSabor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoSaborFindManyArgs>(args?: SelectSubset<T, TipoSaborFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoSabor.
     * @param {TipoSaborCreateArgs} args - Arguments to create a TipoSabor.
     * @example
     * // Create one TipoSabor
     * const TipoSabor = await prisma.tipoSabor.create({
     *   data: {
     *     // ... data to create a TipoSabor
     *   }
     * })
     * 
     */
    create<T extends TipoSaborCreateArgs>(args: SelectSubset<T, TipoSaborCreateArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoSabors.
     * @param {TipoSaborCreateManyArgs} args - Arguments to create many TipoSabors.
     * @example
     * // Create many TipoSabors
     * const tipoSabor = await prisma.tipoSabor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoSaborCreateManyArgs>(args?: SelectSubset<T, TipoSaborCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoSabors and returns the data saved in the database.
     * @param {TipoSaborCreateManyAndReturnArgs} args - Arguments to create many TipoSabors.
     * @example
     * // Create many TipoSabors
     * const tipoSabor = await prisma.tipoSabor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoSabors and only return the `id`
     * const tipoSaborWithIdOnly = await prisma.tipoSabor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoSaborCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoSaborCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoSabor.
     * @param {TipoSaborDeleteArgs} args - Arguments to delete one TipoSabor.
     * @example
     * // Delete one TipoSabor
     * const TipoSabor = await prisma.tipoSabor.delete({
     *   where: {
     *     // ... filter to delete one TipoSabor
     *   }
     * })
     * 
     */
    delete<T extends TipoSaborDeleteArgs>(args: SelectSubset<T, TipoSaborDeleteArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoSabor.
     * @param {TipoSaborUpdateArgs} args - Arguments to update one TipoSabor.
     * @example
     * // Update one TipoSabor
     * const tipoSabor = await prisma.tipoSabor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoSaborUpdateArgs>(args: SelectSubset<T, TipoSaborUpdateArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoSabors.
     * @param {TipoSaborDeleteManyArgs} args - Arguments to filter TipoSabors to delete.
     * @example
     * // Delete a few TipoSabors
     * const { count } = await prisma.tipoSabor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoSaborDeleteManyArgs>(args?: SelectSubset<T, TipoSaborDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSabors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoSabors
     * const tipoSabor = await prisma.tipoSabor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoSaborUpdateManyArgs>(args: SelectSubset<T, TipoSaborUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSabors and returns the data updated in the database.
     * @param {TipoSaborUpdateManyAndReturnArgs} args - Arguments to update many TipoSabors.
     * @example
     * // Update many TipoSabors
     * const tipoSabor = await prisma.tipoSabor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoSabors and only return the `id`
     * const tipoSaborWithIdOnly = await prisma.tipoSabor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoSaborUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoSaborUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoSabor.
     * @param {TipoSaborUpsertArgs} args - Arguments to update or create a TipoSabor.
     * @example
     * // Update or create a TipoSabor
     * const tipoSabor = await prisma.tipoSabor.upsert({
     *   create: {
     *     // ... data to create a TipoSabor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoSabor we want to update
     *   }
     * })
     */
    upsert<T extends TipoSaborUpsertArgs>(args: SelectSubset<T, TipoSaborUpsertArgs<ExtArgs>>): Prisma__TipoSaborClient<$Result.GetResult<Prisma.$TipoSaborPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoSabors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborCountArgs} args - Arguments to filter TipoSabors to count.
     * @example
     * // Count the number of TipoSabors
     * const count = await prisma.tipoSabor.count({
     *   where: {
     *     // ... the filter for the TipoSabors we want to count
     *   }
     * })
    **/
    count<T extends TipoSaborCountArgs>(
      args?: Subset<T, TipoSaborCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoSaborCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoSabor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoSaborAggregateArgs>(args: Subset<T, TipoSaborAggregateArgs>): Prisma.PrismaPromise<GetTipoSaborAggregateType<T>>

    /**
     * Group by TipoSabor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSaborGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoSaborGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoSaborGroupByArgs['orderBy'] }
        : { orderBy?: TipoSaborGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoSaborGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoSaborGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoSabor model
   */
  readonly fields: TipoSaborFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoSabor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoSaborClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Receta<T extends TipoSabor$RecetaArgs<ExtArgs> = {}>(args?: Subset<T, TipoSabor$RecetaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoSabor model
   */
  interface TipoSaborFieldRefs {
    readonly id: FieldRef<"TipoSabor", 'Int'>
    readonly nombreSabor: FieldRef<"TipoSabor", 'NombreSabor'>
  }
    

  // Custom InputTypes
  /**
   * TipoSabor findUnique
   */
  export type TipoSaborFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter, which TipoSabor to fetch.
     */
    where: TipoSaborWhereUniqueInput
  }

  /**
   * TipoSabor findUniqueOrThrow
   */
  export type TipoSaborFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter, which TipoSabor to fetch.
     */
    where: TipoSaborWhereUniqueInput
  }

  /**
   * TipoSabor findFirst
   */
  export type TipoSaborFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter, which TipoSabor to fetch.
     */
    where?: TipoSaborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSabors to fetch.
     */
    orderBy?: TipoSaborOrderByWithRelationInput | TipoSaborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSabors.
     */
    cursor?: TipoSaborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSabors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSabors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSabors.
     */
    distinct?: TipoSaborScalarFieldEnum | TipoSaborScalarFieldEnum[]
  }

  /**
   * TipoSabor findFirstOrThrow
   */
  export type TipoSaborFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter, which TipoSabor to fetch.
     */
    where?: TipoSaborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSabors to fetch.
     */
    orderBy?: TipoSaborOrderByWithRelationInput | TipoSaborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSabors.
     */
    cursor?: TipoSaborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSabors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSabors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSabors.
     */
    distinct?: TipoSaborScalarFieldEnum | TipoSaborScalarFieldEnum[]
  }

  /**
   * TipoSabor findMany
   */
  export type TipoSaborFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter, which TipoSabors to fetch.
     */
    where?: TipoSaborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSabors to fetch.
     */
    orderBy?: TipoSaborOrderByWithRelationInput | TipoSaborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoSabors.
     */
    cursor?: TipoSaborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSabors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSabors.
     */
    skip?: number
    distinct?: TipoSaborScalarFieldEnum | TipoSaborScalarFieldEnum[]
  }

  /**
   * TipoSabor create
   */
  export type TipoSaborCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoSabor.
     */
    data: XOR<TipoSaborCreateInput, TipoSaborUncheckedCreateInput>
  }

  /**
   * TipoSabor createMany
   */
  export type TipoSaborCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoSabors.
     */
    data: TipoSaborCreateManyInput | TipoSaborCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSabor createManyAndReturn
   */
  export type TipoSaborCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * The data used to create many TipoSabors.
     */
    data: TipoSaborCreateManyInput | TipoSaborCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSabor update
   */
  export type TipoSaborUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoSabor.
     */
    data: XOR<TipoSaborUpdateInput, TipoSaborUncheckedUpdateInput>
    /**
     * Choose, which TipoSabor to update.
     */
    where: TipoSaborWhereUniqueInput
  }

  /**
   * TipoSabor updateMany
   */
  export type TipoSaborUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoSabors.
     */
    data: XOR<TipoSaborUpdateManyMutationInput, TipoSaborUncheckedUpdateManyInput>
    /**
     * Filter which TipoSabors to update
     */
    where?: TipoSaborWhereInput
    /**
     * Limit how many TipoSabors to update.
     */
    limit?: number
  }

  /**
   * TipoSabor updateManyAndReturn
   */
  export type TipoSaborUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * The data used to update TipoSabors.
     */
    data: XOR<TipoSaborUpdateManyMutationInput, TipoSaborUncheckedUpdateManyInput>
    /**
     * Filter which TipoSabors to update
     */
    where?: TipoSaborWhereInput
    /**
     * Limit how many TipoSabors to update.
     */
    limit?: number
  }

  /**
   * TipoSabor upsert
   */
  export type TipoSaborUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoSabor to update in case it exists.
     */
    where: TipoSaborWhereUniqueInput
    /**
     * In case the TipoSabor found by the `where` argument doesn't exist, create a new TipoSabor with this data.
     */
    create: XOR<TipoSaborCreateInput, TipoSaborUncheckedCreateInput>
    /**
     * In case the TipoSabor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoSaborUpdateInput, TipoSaborUncheckedUpdateInput>
  }

  /**
   * TipoSabor delete
   */
  export type TipoSaborDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
    /**
     * Filter which TipoSabor to delete.
     */
    where: TipoSaborWhereUniqueInput
  }

  /**
   * TipoSabor deleteMany
   */
  export type TipoSaborDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSabors to delete
     */
    where?: TipoSaborWhereInput
    /**
     * Limit how many TipoSabors to delete.
     */
    limit?: number
  }

  /**
   * TipoSabor.Receta
   */
  export type TipoSabor$RecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    where?: RecetaWhereInput
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    cursor?: RecetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * TipoSabor without action
   */
  export type TipoSaborDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSabor
     */
    select?: TipoSaborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSabor
     */
    omit?: TipoSaborOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSaborInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidoP: string | null
    apellidoM: string | null
    email: string | null
    contrase_a: string | null
    fotoPerfil: string | null
    fechaRegistro: Date | null
    nombreUsuario: string | null
    fechaActualizado: Date | null
    rol: $Enums.UserRole | null
    biografia: string | null
    primerInicioSesion: boolean | null
    titulo: string | null
    verificado: boolean | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidoP: string | null
    apellidoM: string | null
    email: string | null
    contrase_a: string | null
    fotoPerfil: string | null
    fechaRegistro: Date | null
    nombreUsuario: string | null
    fechaActualizado: Date | null
    rol: $Enums.UserRole | null
    biografia: string | null
    primerInicioSesion: boolean | null
    titulo: string | null
    verificado: boolean | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellidoP: number
    apellidoM: number
    email: number
    contrase_a: number
    fotoPerfil: number
    preferencias: number
    fechaRegistro: number
    nombreUsuario: number
    fechaActualizado: number
    rol: number
    biografia: number
    primerInicioSesion: number
    titulo: number
    verificado: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidoP?: true
    apellidoM?: true
    email?: true
    contrase_a?: true
    fotoPerfil?: true
    fechaRegistro?: true
    nombreUsuario?: true
    fechaActualizado?: true
    rol?: true
    biografia?: true
    primerInicioSesion?: true
    titulo?: true
    verificado?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidoP?: true
    apellidoM?: true
    email?: true
    contrase_a?: true
    fotoPerfil?: true
    fechaRegistro?: true
    nombreUsuario?: true
    fechaActualizado?: true
    rol?: true
    biografia?: true
    primerInicioSesion?: true
    titulo?: true
    verificado?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidoP?: true
    apellidoM?: true
    email?: true
    contrase_a?: true
    fotoPerfil?: true
    preferencias?: true
    fechaRegistro?: true
    nombreUsuario?: true
    fechaActualizado?: true
    rol?: true
    biografia?: true
    primerInicioSesion?: true
    titulo?: true
    verificado?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    apellidoP: string
    apellidoM: string | null
    email: string
    contrase_a: string
    fotoPerfil: string | null
    preferencias: JsonValue | null
    fechaRegistro: Date
    nombreUsuario: string
    fechaActualizado: Date
    rol: $Enums.UserRole
    biografia: string | null
    primerInicioSesion: boolean
    titulo: string | null
    verificado: boolean
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidoP?: boolean
    apellidoM?: boolean
    email?: boolean
    contrase_a?: boolean
    fotoPerfil?: boolean
    preferencias?: boolean
    fechaRegistro?: boolean
    nombreUsuario?: boolean
    fechaActualizado?: boolean
    rol?: boolean
    biografia?: boolean
    primerInicioSesion?: boolean
    titulo?: boolean
    verificado?: boolean
    Calificacion?: boolean | Usuario$CalificacionArgs<ExtArgs>
    Comentario?: boolean | Usuario$ComentarioArgs<ExtArgs>
    Cuenta?: boolean | Usuario$CuentaArgs<ExtArgs>
    Favorito?: boolean | Usuario$FavoritoArgs<ExtArgs>
    ListaCompra?: boolean | Usuario$ListaCompraArgs<ExtArgs>
    Notificacion?: boolean | Usuario$NotificacionArgs<ExtArgs>
    Receta?: boolean | Usuario$RecetaArgs<ExtArgs>
    Reporte?: boolean | Usuario$ReporteArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidoP?: boolean
    apellidoM?: boolean
    email?: boolean
    contrase_a?: boolean
    fotoPerfil?: boolean
    preferencias?: boolean
    fechaRegistro?: boolean
    nombreUsuario?: boolean
    fechaActualizado?: boolean
    rol?: boolean
    biografia?: boolean
    primerInicioSesion?: boolean
    titulo?: boolean
    verificado?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidoP?: boolean
    apellidoM?: boolean
    email?: boolean
    contrase_a?: boolean
    fotoPerfil?: boolean
    preferencias?: boolean
    fechaRegistro?: boolean
    nombreUsuario?: boolean
    fechaActualizado?: boolean
    rol?: boolean
    biografia?: boolean
    primerInicioSesion?: boolean
    titulo?: boolean
    verificado?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidoP?: boolean
    apellidoM?: boolean
    email?: boolean
    contrase_a?: boolean
    fotoPerfil?: boolean
    preferencias?: boolean
    fechaRegistro?: boolean
    nombreUsuario?: boolean
    fechaActualizado?: boolean
    rol?: boolean
    biografia?: boolean
    primerInicioSesion?: boolean
    titulo?: boolean
    verificado?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellidoP" | "apellidoM" | "email" | "contrase_a" | "fotoPerfil" | "preferencias" | "fechaRegistro" | "nombreUsuario" | "fechaActualizado" | "rol" | "biografia" | "primerInicioSesion" | "titulo" | "verificado", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Calificacion?: boolean | Usuario$CalificacionArgs<ExtArgs>
    Comentario?: boolean | Usuario$ComentarioArgs<ExtArgs>
    Cuenta?: boolean | Usuario$CuentaArgs<ExtArgs>
    Favorito?: boolean | Usuario$FavoritoArgs<ExtArgs>
    ListaCompra?: boolean | Usuario$ListaCompraArgs<ExtArgs>
    Notificacion?: boolean | Usuario$NotificacionArgs<ExtArgs>
    Receta?: boolean | Usuario$RecetaArgs<ExtArgs>
    Reporte?: boolean | Usuario$ReporteArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      Calificacion: Prisma.$CalificacionPayload<ExtArgs>[]
      Comentario: Prisma.$ComentarioPayload<ExtArgs>[]
      Cuenta: Prisma.$CuentaPayload<ExtArgs>[]
      Favorito: Prisma.$FavoritoPayload<ExtArgs>[]
      ListaCompra: Prisma.$ListaCompraPayload<ExtArgs>[]
      Notificacion: Prisma.$NotificacionPayload<ExtArgs>[]
      Receta: Prisma.$RecetaPayload<ExtArgs>[]
      Reporte: Prisma.$ReportePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellidoP: string
      apellidoM: string | null
      email: string
      contrase_a: string
      fotoPerfil: string | null
      preferencias: Prisma.JsonValue | null
      fechaRegistro: Date
      nombreUsuario: string
      fechaActualizado: Date
      rol: $Enums.UserRole
      biografia: string | null
      primerInicioSesion: boolean
      titulo: string | null
      verificado: boolean
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Calificacion<T extends Usuario$CalificacionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$CalificacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comentario<T extends Usuario$ComentarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$ComentarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Cuenta<T extends Usuario$CuentaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$CuentaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Favorito<T extends Usuario$FavoritoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$FavoritoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ListaCompra<T extends Usuario$ListaCompraArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$ListaCompraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaCompraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notificacion<T extends Usuario$NotificacionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$NotificacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Receta<T extends Usuario$RecetaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$RecetaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reporte<T extends Usuario$ReporteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$ReporteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellidoP: FieldRef<"Usuario", 'String'>
    readonly apellidoM: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly contrase_a: FieldRef<"Usuario", 'String'>
    readonly fotoPerfil: FieldRef<"Usuario", 'String'>
    readonly preferencias: FieldRef<"Usuario", 'Json'>
    readonly fechaRegistro: FieldRef<"Usuario", 'DateTime'>
    readonly nombreUsuario: FieldRef<"Usuario", 'String'>
    readonly fechaActualizado: FieldRef<"Usuario", 'DateTime'>
    readonly rol: FieldRef<"Usuario", 'UserRole'>
    readonly biografia: FieldRef<"Usuario", 'String'>
    readonly primerInicioSesion: FieldRef<"Usuario", 'Boolean'>
    readonly titulo: FieldRef<"Usuario", 'String'>
    readonly verificado: FieldRef<"Usuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.Calificacion
   */
  export type Usuario$CalificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calificacion
     */
    select?: CalificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calificacion
     */
    omit?: CalificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalificacionInclude<ExtArgs> | null
    where?: CalificacionWhereInput
    orderBy?: CalificacionOrderByWithRelationInput | CalificacionOrderByWithRelationInput[]
    cursor?: CalificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionScalarFieldEnum | CalificacionScalarFieldEnum[]
  }

  /**
   * Usuario.Comentario
   */
  export type Usuario$ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comentario
     */
    omit?: ComentarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Usuario.Cuenta
   */
  export type Usuario$CuentaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuenta
     */
    select?: CuentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuenta
     */
    omit?: CuentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuentaInclude<ExtArgs> | null
    where?: CuentaWhereInput
    orderBy?: CuentaOrderByWithRelationInput | CuentaOrderByWithRelationInput[]
    cursor?: CuentaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CuentaScalarFieldEnum | CuentaScalarFieldEnum[]
  }

  /**
   * Usuario.Favorito
   */
  export type Usuario$FavoritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    cursor?: FavoritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Usuario.ListaCompra
   */
  export type Usuario$ListaCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaCompra
     */
    select?: ListaCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaCompra
     */
    omit?: ListaCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaCompraInclude<ExtArgs> | null
    where?: ListaCompraWhereInput
    orderBy?: ListaCompraOrderByWithRelationInput | ListaCompraOrderByWithRelationInput[]
    cursor?: ListaCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListaCompraScalarFieldEnum | ListaCompraScalarFieldEnum[]
  }

  /**
   * Usuario.Notificacion
   */
  export type Usuario$NotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Usuario.Receta
   */
  export type Usuario$RecetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receta
     */
    select?: RecetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receta
     */
    omit?: RecetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecetaInclude<ExtArgs> | null
    where?: RecetaWhereInput
    orderBy?: RecetaOrderByWithRelationInput | RecetaOrderByWithRelationInput[]
    cursor?: RecetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecetaScalarFieldEnum | RecetaScalarFieldEnum[]
  }

  /**
   * Usuario.Reporte
   */
  export type Usuario$ReporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reporte
     */
    select?: ReporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reporte
     */
    omit?: ReporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteInclude<ExtArgs> | null
    where?: ReporteWhereInput
    orderBy?: ReporteOrderByWithRelationInput | ReporteOrderByWithRelationInput[]
    cursor?: ReporteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReporteScalarFieldEnum | ReporteScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _avg: VerificationTokenAvgAggregateOutputType | null
    _sum: VerificationTokenSumAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type VerificationTokenSumAggregateOutputType = {
    id: number | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    email: string | null
    token: string | null
    expires: Date | null
    id: number | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    email: string | null
    token: string | null
    expires: Date | null
    id: number | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    email: number
    token: number
    expires: number
    id: number
    _all: number
  }


  export type VerificationTokenAvgAggregateInputType = {
    id?: true
  }

  export type VerificationTokenSumAggregateInputType = {
    id?: true
  }

  export type VerificationTokenMinAggregateInputType = {
    email?: true
    token?: true
    expires?: true
    id?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    email?: true
    token?: true
    expires?: true
    id?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    email?: true
    token?: true
    expires?: true
    id?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _avg?: VerificationTokenAvgAggregateInputType
    _sum?: VerificationTokenSumAggregateInputType
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    email: string
    token: string
    expires: Date
    id: number
    _count: VerificationTokenCountAggregateOutputType | null
    _avg: VerificationTokenAvgAggregateOutputType | null
    _sum: VerificationTokenSumAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    expires?: boolean
    id?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    expires?: boolean
    id?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    expires?: boolean
    id?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    email?: boolean
    token?: boolean
    expires?: boolean
    id?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "token" | "expires" | "id", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      token: string
      expires: Date
      id: number
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const verificationTokenWithEmailOnly = await prisma.verificationToken.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `email`
     * const verificationTokenWithEmailOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `email`
     * const verificationTokenWithEmailOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { email: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
    readonly id: FieldRef<"VerificationToken", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CalificacionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    recetaId: 'recetaId',
    puntuacion: 'puntuacion',
    fechaCalificacion: 'fechaCalificacion'
  };

  export type CalificacionScalarFieldEnum = (typeof CalificacionScalarFieldEnum)[keyof typeof CalificacionScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    recetaId: 'recetaId',
    comentario: 'comentario',
    fechaComentario: 'fechaComentario'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const CuentaScalarFieldEnum: {
    idUsuario: 'idUsuario',
    tipo: 'tipo',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CuentaScalarFieldEnum = (typeof CuentaScalarFieldEnum)[keyof typeof CuentaScalarFieldEnum]


  export const FavoritoScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    recetaId: 'recetaId',
    fechaGuardado: 'fechaGuardado'
  };

  export type FavoritoScalarFieldEnum = (typeof FavoritoScalarFieldEnum)[keyof typeof FavoritoScalarFieldEnum]


  export const IngredienteScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    Tipo: 'Tipo'
  };

  export type IngredienteScalarFieldEnum = (typeof IngredienteScalarFieldEnum)[keyof typeof IngredienteScalarFieldEnum]


  export const ListaCompraScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nombreIngrediente: 'nombreIngrediente',
    cantidad: 'cantidad',
    fechaCreacion: 'fechaCreacion'
  };

  export type ListaCompraScalarFieldEnum = (typeof ListaCompraScalarFieldEnum)[keyof typeof ListaCompraScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    mensaje: 'mensaje',
    leida: 'leida',
    fechaNotificacion: 'fechaNotificacion'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const RecetaScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    titulo: 'titulo',
    descripcion: 'descripcion',
    tiempoPreparacion: 'tiempoPreparacion',
    porciones: 'porciones',
    imagen: 'imagen',
    fechaCreacion: 'fechaCreacion',
    idTipoComida: 'idTipoComida',
    idTipoSabor: 'idTipoSabor',
    dificultad: 'dificultad'
  };

  export type RecetaScalarFieldEnum = (typeof RecetaScalarFieldEnum)[keyof typeof RecetaScalarFieldEnum]


  export const RecetaIngredienteScalarFieldEnum: {
    id: 'id',
    recetaId: 'recetaId',
    ingredienteId: 'ingredienteId',
    cantidad: 'cantidad'
  };

  export type RecetaIngredienteScalarFieldEnum = (typeof RecetaIngredienteScalarFieldEnum)[keyof typeof RecetaIngredienteScalarFieldEnum]


  export const ReporteScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    recetaId: 'recetaId',
    comentarioId: 'comentarioId',
    motivo: 'motivo',
    estado: 'estado',
    fechaReporte: 'fechaReporte'
  };

  export type ReporteScalarFieldEnum = (typeof ReporteScalarFieldEnum)[keyof typeof ReporteScalarFieldEnum]


  export const TipoComidaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type TipoComidaScalarFieldEnum = (typeof TipoComidaScalarFieldEnum)[keyof typeof TipoComidaScalarFieldEnum]


  export const TipoSaborScalarFieldEnum: {
    id: 'id',
    nombreSabor: 'nombreSabor'
  };

  export type TipoSaborScalarFieldEnum = (typeof TipoSaborScalarFieldEnum)[keyof typeof TipoSaborScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidoP: 'apellidoP',
    apellidoM: 'apellidoM',
    email: 'email',
    contrase_a: 'contrase_a',
    fotoPerfil: 'fotoPerfil',
    preferencias: 'preferencias',
    fechaRegistro: 'fechaRegistro',
    nombreUsuario: 'nombreUsuario',
    fechaActualizado: 'fechaActualizado',
    rol: 'rol',
    biografia: 'biografia',
    primerInicioSesion: 'primerInicioSesion',
    titulo: 'titulo',
    verificado: 'verificado'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    email: 'email',
    token: 'token',
    expires: 'expires',
    id: 'id'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TipoIngrediente'
   */
  export type EnumTipoIngredienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoIngrediente'>
    


  /**
   * Reference to a field of type 'TipoIngrediente[]'
   */
  export type ListEnumTipoIngredienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoIngrediente[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DificultadReceta'
   */
  export type EnumDificultadRecetaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DificultadReceta'>
    


  /**
   * Reference to a field of type 'DificultadReceta[]'
   */
  export type ListEnumDificultadRecetaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DificultadReceta[]'>
    


  /**
   * Reference to a field of type 'NombreSabor'
   */
  export type EnumNombreSaborFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NombreSabor'>
    


  /**
   * Reference to a field of type 'NombreSabor[]'
   */
  export type ListEnumNombreSaborFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NombreSabor[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CalificacionWhereInput = {
    AND?: CalificacionWhereInput | CalificacionWhereInput[]
    OR?: CalificacionWhereInput[]
    NOT?: CalificacionWhereInput | CalificacionWhereInput[]
    id?: IntFilter<"Calificacion"> | number
    usuarioId?: IntFilter<"Calificacion"> | number
    recetaId?: IntFilter<"Calificacion"> | number
    puntuacion?: IntFilter<"Calificacion"> | number
    fechaCalificacion?: DateTimeFilter<"Calificacion"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type CalificacionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
    fechaCalificacion?: SortOrder
    Receta?: RecetaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type CalificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CalificacionWhereInput | CalificacionWhereInput[]
    OR?: CalificacionWhereInput[]
    NOT?: CalificacionWhereInput | CalificacionWhereInput[]
    usuarioId?: IntFilter<"Calificacion"> | number
    recetaId?: IntFilter<"Calificacion"> | number
    puntuacion?: IntFilter<"Calificacion"> | number
    fechaCalificacion?: DateTimeFilter<"Calificacion"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type CalificacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
    fechaCalificacion?: SortOrder
    _count?: CalificacionCountOrderByAggregateInput
    _avg?: CalificacionAvgOrderByAggregateInput
    _max?: CalificacionMaxOrderByAggregateInput
    _min?: CalificacionMinOrderByAggregateInput
    _sum?: CalificacionSumOrderByAggregateInput
  }

  export type CalificacionScalarWhereWithAggregatesInput = {
    AND?: CalificacionScalarWhereWithAggregatesInput | CalificacionScalarWhereWithAggregatesInput[]
    OR?: CalificacionScalarWhereWithAggregatesInput[]
    NOT?: CalificacionScalarWhereWithAggregatesInput | CalificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Calificacion"> | number
    usuarioId?: IntWithAggregatesFilter<"Calificacion"> | number
    recetaId?: IntWithAggregatesFilter<"Calificacion"> | number
    puntuacion?: IntWithAggregatesFilter<"Calificacion"> | number
    fechaCalificacion?: DateTimeWithAggregatesFilter<"Calificacion"> | Date | string
  }

  export type ComentarioWhereInput = {
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    id?: IntFilter<"Comentario"> | number
    usuarioId?: IntFilter<"Comentario"> | number
    recetaId?: IntFilter<"Comentario"> | number
    comentario?: StringFilter<"Comentario"> | string
    fechaComentario?: DateTimeFilter<"Comentario"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Reporte?: ReporteListRelationFilter
  }

  export type ComentarioOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    Receta?: RecetaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    Reporte?: ReporteOrderByRelationAggregateInput
  }

  export type ComentarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    usuarioId?: IntFilter<"Comentario"> | number
    recetaId?: IntFilter<"Comentario"> | number
    comentario?: StringFilter<"Comentario"> | string
    fechaComentario?: DateTimeFilter<"Comentario"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Reporte?: ReporteListRelationFilter
  }, "id">

  export type ComentarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    _count?: ComentarioCountOrderByAggregateInput
    _avg?: ComentarioAvgOrderByAggregateInput
    _max?: ComentarioMaxOrderByAggregateInput
    _min?: ComentarioMinOrderByAggregateInput
    _sum?: ComentarioSumOrderByAggregateInput
  }

  export type ComentarioScalarWhereWithAggregatesInput = {
    AND?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    OR?: ComentarioScalarWhereWithAggregatesInput[]
    NOT?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comentario"> | number
    usuarioId?: IntWithAggregatesFilter<"Comentario"> | number
    recetaId?: IntWithAggregatesFilter<"Comentario"> | number
    comentario?: StringWithAggregatesFilter<"Comentario"> | string
    fechaComentario?: DateTimeWithAggregatesFilter<"Comentario"> | Date | string
  }

  export type CuentaWhereInput = {
    AND?: CuentaWhereInput | CuentaWhereInput[]
    OR?: CuentaWhereInput[]
    NOT?: CuentaWhereInput | CuentaWhereInput[]
    idUsuario?: IntFilter<"Cuenta"> | number
    tipo?: StringFilter<"Cuenta"> | string
    provider?: StringFilter<"Cuenta"> | string
    providerAccountId?: StringFilter<"Cuenta"> | string
    refresh_token?: StringNullableFilter<"Cuenta"> | string | null
    access_token?: StringNullableFilter<"Cuenta"> | string | null
    expires_at?: IntNullableFilter<"Cuenta"> | number | null
    token_type?: StringNullableFilter<"Cuenta"> | string | null
    scope?: StringNullableFilter<"Cuenta"> | string | null
    id_token?: StringNullableFilter<"Cuenta"> | string | null
    session_state?: StringNullableFilter<"Cuenta"> | string | null
    createdAt?: DateTimeFilter<"Cuenta"> | Date | string
    updatedAt?: DateTimeFilter<"Cuenta"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type CuentaOrderByWithRelationInput = {
    idUsuario?: SortOrder
    tipo?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type CuentaWhereUniqueInput = Prisma.AtLeast<{
    provider_providerAccountId?: CuentaProviderProviderAccountIdCompoundUniqueInput
    AND?: CuentaWhereInput | CuentaWhereInput[]
    OR?: CuentaWhereInput[]
    NOT?: CuentaWhereInput | CuentaWhereInput[]
    idUsuario?: IntFilter<"Cuenta"> | number
    tipo?: StringFilter<"Cuenta"> | string
    provider?: StringFilter<"Cuenta"> | string
    providerAccountId?: StringFilter<"Cuenta"> | string
    refresh_token?: StringNullableFilter<"Cuenta"> | string | null
    access_token?: StringNullableFilter<"Cuenta"> | string | null
    expires_at?: IntNullableFilter<"Cuenta"> | number | null
    token_type?: StringNullableFilter<"Cuenta"> | string | null
    scope?: StringNullableFilter<"Cuenta"> | string | null
    id_token?: StringNullableFilter<"Cuenta"> | string | null
    session_state?: StringNullableFilter<"Cuenta"> | string | null
    createdAt?: DateTimeFilter<"Cuenta"> | Date | string
    updatedAt?: DateTimeFilter<"Cuenta"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "provider_providerAccountId">

  export type CuentaOrderByWithAggregationInput = {
    idUsuario?: SortOrder
    tipo?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CuentaCountOrderByAggregateInput
    _avg?: CuentaAvgOrderByAggregateInput
    _max?: CuentaMaxOrderByAggregateInput
    _min?: CuentaMinOrderByAggregateInput
    _sum?: CuentaSumOrderByAggregateInput
  }

  export type CuentaScalarWhereWithAggregatesInput = {
    AND?: CuentaScalarWhereWithAggregatesInput | CuentaScalarWhereWithAggregatesInput[]
    OR?: CuentaScalarWhereWithAggregatesInput[]
    NOT?: CuentaScalarWhereWithAggregatesInput | CuentaScalarWhereWithAggregatesInput[]
    idUsuario?: IntWithAggregatesFilter<"Cuenta"> | number
    tipo?: StringWithAggregatesFilter<"Cuenta"> | string
    provider?: StringWithAggregatesFilter<"Cuenta"> | string
    providerAccountId?: StringWithAggregatesFilter<"Cuenta"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Cuenta"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Cuenta"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cuenta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cuenta"> | Date | string
  }

  export type FavoritoWhereInput = {
    AND?: FavoritoWhereInput | FavoritoWhereInput[]
    OR?: FavoritoWhereInput[]
    NOT?: FavoritoWhereInput | FavoritoWhereInput[]
    id?: IntFilter<"Favorito"> | number
    usuarioId?: IntFilter<"Favorito"> | number
    recetaId?: IntFilter<"Favorito"> | number
    fechaGuardado?: DateTimeFilter<"Favorito"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type FavoritoOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    fechaGuardado?: SortOrder
    Receta?: RecetaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type FavoritoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FavoritoWhereInput | FavoritoWhereInput[]
    OR?: FavoritoWhereInput[]
    NOT?: FavoritoWhereInput | FavoritoWhereInput[]
    usuarioId?: IntFilter<"Favorito"> | number
    recetaId?: IntFilter<"Favorito"> | number
    fechaGuardado?: DateTimeFilter<"Favorito"> | Date | string
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type FavoritoOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    fechaGuardado?: SortOrder
    _count?: FavoritoCountOrderByAggregateInput
    _avg?: FavoritoAvgOrderByAggregateInput
    _max?: FavoritoMaxOrderByAggregateInput
    _min?: FavoritoMinOrderByAggregateInput
    _sum?: FavoritoSumOrderByAggregateInput
  }

  export type FavoritoScalarWhereWithAggregatesInput = {
    AND?: FavoritoScalarWhereWithAggregatesInput | FavoritoScalarWhereWithAggregatesInput[]
    OR?: FavoritoScalarWhereWithAggregatesInput[]
    NOT?: FavoritoScalarWhereWithAggregatesInput | FavoritoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Favorito"> | number
    usuarioId?: IntWithAggregatesFilter<"Favorito"> | number
    recetaId?: IntWithAggregatesFilter<"Favorito"> | number
    fechaGuardado?: DateTimeWithAggregatesFilter<"Favorito"> | Date | string
  }

  export type IngredienteWhereInput = {
    AND?: IngredienteWhereInput | IngredienteWhereInput[]
    OR?: IngredienteWhereInput[]
    NOT?: IngredienteWhereInput | IngredienteWhereInput[]
    id?: IntFilter<"Ingrediente"> | number
    nombre?: StringFilter<"Ingrediente"> | string
    Tipo?: EnumTipoIngredienteFilter<"Ingrediente"> | $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteListRelationFilter
  }

  export type IngredienteOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Tipo?: SortOrder
    RecetaIngrediente?: RecetaIngredienteOrderByRelationAggregateInput
  }

  export type IngredienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: IngredienteWhereInput | IngredienteWhereInput[]
    OR?: IngredienteWhereInput[]
    NOT?: IngredienteWhereInput | IngredienteWhereInput[]
    Tipo?: EnumTipoIngredienteFilter<"Ingrediente"> | $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteListRelationFilter
  }, "id" | "nombre">

  export type IngredienteOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Tipo?: SortOrder
    _count?: IngredienteCountOrderByAggregateInput
    _avg?: IngredienteAvgOrderByAggregateInput
    _max?: IngredienteMaxOrderByAggregateInput
    _min?: IngredienteMinOrderByAggregateInput
    _sum?: IngredienteSumOrderByAggregateInput
  }

  export type IngredienteScalarWhereWithAggregatesInput = {
    AND?: IngredienteScalarWhereWithAggregatesInput | IngredienteScalarWhereWithAggregatesInput[]
    OR?: IngredienteScalarWhereWithAggregatesInput[]
    NOT?: IngredienteScalarWhereWithAggregatesInput | IngredienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ingrediente"> | number
    nombre?: StringWithAggregatesFilter<"Ingrediente"> | string
    Tipo?: EnumTipoIngredienteWithAggregatesFilter<"Ingrediente"> | $Enums.TipoIngrediente
  }

  export type ListaCompraWhereInput = {
    AND?: ListaCompraWhereInput | ListaCompraWhereInput[]
    OR?: ListaCompraWhereInput[]
    NOT?: ListaCompraWhereInput | ListaCompraWhereInput[]
    id?: IntFilter<"ListaCompra"> | number
    usuarioId?: IntFilter<"ListaCompra"> | number
    nombreIngrediente?: StringFilter<"ListaCompra"> | string
    cantidad?: IntFilter<"ListaCompra"> | number
    fechaCreacion?: DateTimeFilter<"ListaCompra"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ListaCompraOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombreIngrediente?: SortOrder
    cantidad?: SortOrder
    fechaCreacion?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type ListaCompraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ListaCompraWhereInput | ListaCompraWhereInput[]
    OR?: ListaCompraWhereInput[]
    NOT?: ListaCompraWhereInput | ListaCompraWhereInput[]
    usuarioId?: IntFilter<"ListaCompra"> | number
    nombreIngrediente?: StringFilter<"ListaCompra"> | string
    cantidad?: IntFilter<"ListaCompra"> | number
    fechaCreacion?: DateTimeFilter<"ListaCompra"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ListaCompraOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombreIngrediente?: SortOrder
    cantidad?: SortOrder
    fechaCreacion?: SortOrder
    _count?: ListaCompraCountOrderByAggregateInput
    _avg?: ListaCompraAvgOrderByAggregateInput
    _max?: ListaCompraMaxOrderByAggregateInput
    _min?: ListaCompraMinOrderByAggregateInput
    _sum?: ListaCompraSumOrderByAggregateInput
  }

  export type ListaCompraScalarWhereWithAggregatesInput = {
    AND?: ListaCompraScalarWhereWithAggregatesInput | ListaCompraScalarWhereWithAggregatesInput[]
    OR?: ListaCompraScalarWhereWithAggregatesInput[]
    NOT?: ListaCompraScalarWhereWithAggregatesInput | ListaCompraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ListaCompra"> | number
    usuarioId?: IntWithAggregatesFilter<"ListaCompra"> | number
    nombreIngrediente?: StringWithAggregatesFilter<"ListaCompra"> | string
    cantidad?: IntWithAggregatesFilter<"ListaCompra"> | number
    fechaCreacion?: DateTimeWithAggregatesFilter<"ListaCompra"> | Date | string
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    usuarioId?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    fechaNotificacion?: DateTimeFilter<"Notificacion"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    fechaNotificacion?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    usuarioId?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    fechaNotificacion?: DateTimeFilter<"Notificacion"> | Date | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    fechaNotificacion?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _avg?: NotificacionAvgOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
    _sum?: NotificacionSumOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notificacion"> | number
    usuarioId?: IntWithAggregatesFilter<"Notificacion"> | number
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    leida?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    fechaNotificacion?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type RecetaWhereInput = {
    AND?: RecetaWhereInput | RecetaWhereInput[]
    OR?: RecetaWhereInput[]
    NOT?: RecetaWhereInput | RecetaWhereInput[]
    id?: IntFilter<"Receta"> | number
    usuarioId?: IntFilter<"Receta"> | number
    titulo?: StringFilter<"Receta"> | string
    descripcion?: StringFilter<"Receta"> | string
    tiempoPreparacion?: IntFilter<"Receta"> | number
    porciones?: IntFilter<"Receta"> | number
    imagen?: StringFilter<"Receta"> | string
    fechaCreacion?: DateTimeFilter<"Receta"> | Date | string
    idTipoComida?: IntFilter<"Receta"> | number
    idTipoSabor?: IntFilter<"Receta"> | number
    dificultad?: EnumDificultadRecetaFilter<"Receta"> | $Enums.DificultadReceta
    Calificacion?: CalificacionListRelationFilter
    Comentario?: ComentarioListRelationFilter
    Favorito?: FavoritoListRelationFilter
    TipoComida?: XOR<TipoComidaScalarRelationFilter, TipoComidaWhereInput>
    TipoSabor?: XOR<TipoSaborScalarRelationFilter, TipoSaborWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    RecetaIngrediente?: RecetaIngredienteListRelationFilter
    Reporte?: ReporteListRelationFilter
  }

  export type RecetaOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    imagen?: SortOrder
    fechaCreacion?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
    dificultad?: SortOrder
    Calificacion?: CalificacionOrderByRelationAggregateInput
    Comentario?: ComentarioOrderByRelationAggregateInput
    Favorito?: FavoritoOrderByRelationAggregateInput
    TipoComida?: TipoComidaOrderByWithRelationInput
    TipoSabor?: TipoSaborOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    RecetaIngrediente?: RecetaIngredienteOrderByRelationAggregateInput
    Reporte?: ReporteOrderByRelationAggregateInput
  }

  export type RecetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecetaWhereInput | RecetaWhereInput[]
    OR?: RecetaWhereInput[]
    NOT?: RecetaWhereInput | RecetaWhereInput[]
    usuarioId?: IntFilter<"Receta"> | number
    titulo?: StringFilter<"Receta"> | string
    descripcion?: StringFilter<"Receta"> | string
    tiempoPreparacion?: IntFilter<"Receta"> | number
    porciones?: IntFilter<"Receta"> | number
    imagen?: StringFilter<"Receta"> | string
    fechaCreacion?: DateTimeFilter<"Receta"> | Date | string
    idTipoComida?: IntFilter<"Receta"> | number
    idTipoSabor?: IntFilter<"Receta"> | number
    dificultad?: EnumDificultadRecetaFilter<"Receta"> | $Enums.DificultadReceta
    Calificacion?: CalificacionListRelationFilter
    Comentario?: ComentarioListRelationFilter
    Favorito?: FavoritoListRelationFilter
    TipoComida?: XOR<TipoComidaScalarRelationFilter, TipoComidaWhereInput>
    TipoSabor?: XOR<TipoSaborScalarRelationFilter, TipoSaborWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    RecetaIngrediente?: RecetaIngredienteListRelationFilter
    Reporte?: ReporteListRelationFilter
  }, "id">

  export type RecetaOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    imagen?: SortOrder
    fechaCreacion?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
    dificultad?: SortOrder
    _count?: RecetaCountOrderByAggregateInput
    _avg?: RecetaAvgOrderByAggregateInput
    _max?: RecetaMaxOrderByAggregateInput
    _min?: RecetaMinOrderByAggregateInput
    _sum?: RecetaSumOrderByAggregateInput
  }

  export type RecetaScalarWhereWithAggregatesInput = {
    AND?: RecetaScalarWhereWithAggregatesInput | RecetaScalarWhereWithAggregatesInput[]
    OR?: RecetaScalarWhereWithAggregatesInput[]
    NOT?: RecetaScalarWhereWithAggregatesInput | RecetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Receta"> | number
    usuarioId?: IntWithAggregatesFilter<"Receta"> | number
    titulo?: StringWithAggregatesFilter<"Receta"> | string
    descripcion?: StringWithAggregatesFilter<"Receta"> | string
    tiempoPreparacion?: IntWithAggregatesFilter<"Receta"> | number
    porciones?: IntWithAggregatesFilter<"Receta"> | number
    imagen?: StringWithAggregatesFilter<"Receta"> | string
    fechaCreacion?: DateTimeWithAggregatesFilter<"Receta"> | Date | string
    idTipoComida?: IntWithAggregatesFilter<"Receta"> | number
    idTipoSabor?: IntWithAggregatesFilter<"Receta"> | number
    dificultad?: EnumDificultadRecetaWithAggregatesFilter<"Receta"> | $Enums.DificultadReceta
  }

  export type RecetaIngredienteWhereInput = {
    AND?: RecetaIngredienteWhereInput | RecetaIngredienteWhereInput[]
    OR?: RecetaIngredienteWhereInput[]
    NOT?: RecetaIngredienteWhereInput | RecetaIngredienteWhereInput[]
    id?: IntFilter<"RecetaIngrediente"> | number
    recetaId?: IntFilter<"RecetaIngrediente"> | number
    ingredienteId?: IntFilter<"RecetaIngrediente"> | number
    cantidad?: StringFilter<"RecetaIngrediente"> | string
    Ingrediente?: XOR<IngredienteScalarRelationFilter, IngredienteWhereInput>
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
  }

  export type RecetaIngredienteOrderByWithRelationInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
    cantidad?: SortOrder
    Ingrediente?: IngredienteOrderByWithRelationInput
    Receta?: RecetaOrderByWithRelationInput
  }

  export type RecetaIngredienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecetaIngredienteWhereInput | RecetaIngredienteWhereInput[]
    OR?: RecetaIngredienteWhereInput[]
    NOT?: RecetaIngredienteWhereInput | RecetaIngredienteWhereInput[]
    recetaId?: IntFilter<"RecetaIngrediente"> | number
    ingredienteId?: IntFilter<"RecetaIngrediente"> | number
    cantidad?: StringFilter<"RecetaIngrediente"> | string
    Ingrediente?: XOR<IngredienteScalarRelationFilter, IngredienteWhereInput>
    Receta?: XOR<RecetaScalarRelationFilter, RecetaWhereInput>
  }, "id">

  export type RecetaIngredienteOrderByWithAggregationInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
    cantidad?: SortOrder
    _count?: RecetaIngredienteCountOrderByAggregateInput
    _avg?: RecetaIngredienteAvgOrderByAggregateInput
    _max?: RecetaIngredienteMaxOrderByAggregateInput
    _min?: RecetaIngredienteMinOrderByAggregateInput
    _sum?: RecetaIngredienteSumOrderByAggregateInput
  }

  export type RecetaIngredienteScalarWhereWithAggregatesInput = {
    AND?: RecetaIngredienteScalarWhereWithAggregatesInput | RecetaIngredienteScalarWhereWithAggregatesInput[]
    OR?: RecetaIngredienteScalarWhereWithAggregatesInput[]
    NOT?: RecetaIngredienteScalarWhereWithAggregatesInput | RecetaIngredienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecetaIngrediente"> | number
    recetaId?: IntWithAggregatesFilter<"RecetaIngrediente"> | number
    ingredienteId?: IntWithAggregatesFilter<"RecetaIngrediente"> | number
    cantidad?: StringWithAggregatesFilter<"RecetaIngrediente"> | string
  }

  export type ReporteWhereInput = {
    AND?: ReporteWhereInput | ReporteWhereInput[]
    OR?: ReporteWhereInput[]
    NOT?: ReporteWhereInput | ReporteWhereInput[]
    id?: IntFilter<"Reporte"> | number
    usuarioId?: IntFilter<"Reporte"> | number
    recetaId?: IntNullableFilter<"Reporte"> | number | null
    comentarioId?: IntNullableFilter<"Reporte"> | number | null
    motivo?: StringFilter<"Reporte"> | string
    estado?: StringFilter<"Reporte"> | string
    fechaReporte?: DateTimeFilter<"Reporte"> | Date | string
    Comentario?: XOR<ComentarioNullableScalarRelationFilter, ComentarioWhereInput> | null
    Receta?: XOR<RecetaNullableScalarRelationFilter, RecetaWhereInput> | null
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ReporteOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrderInput | SortOrder
    comentarioId?: SortOrderInput | SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    Comentario?: ComentarioOrderByWithRelationInput
    Receta?: RecetaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type ReporteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReporteWhereInput | ReporteWhereInput[]
    OR?: ReporteWhereInput[]
    NOT?: ReporteWhereInput | ReporteWhereInput[]
    usuarioId?: IntFilter<"Reporte"> | number
    recetaId?: IntNullableFilter<"Reporte"> | number | null
    comentarioId?: IntNullableFilter<"Reporte"> | number | null
    motivo?: StringFilter<"Reporte"> | string
    estado?: StringFilter<"Reporte"> | string
    fechaReporte?: DateTimeFilter<"Reporte"> | Date | string
    Comentario?: XOR<ComentarioNullableScalarRelationFilter, ComentarioWhereInput> | null
    Receta?: XOR<RecetaNullableScalarRelationFilter, RecetaWhereInput> | null
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ReporteOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrderInput | SortOrder
    comentarioId?: SortOrderInput | SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
    _count?: ReporteCountOrderByAggregateInput
    _avg?: ReporteAvgOrderByAggregateInput
    _max?: ReporteMaxOrderByAggregateInput
    _min?: ReporteMinOrderByAggregateInput
    _sum?: ReporteSumOrderByAggregateInput
  }

  export type ReporteScalarWhereWithAggregatesInput = {
    AND?: ReporteScalarWhereWithAggregatesInput | ReporteScalarWhereWithAggregatesInput[]
    OR?: ReporteScalarWhereWithAggregatesInput[]
    NOT?: ReporteScalarWhereWithAggregatesInput | ReporteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reporte"> | number
    usuarioId?: IntWithAggregatesFilter<"Reporte"> | number
    recetaId?: IntNullableWithAggregatesFilter<"Reporte"> | number | null
    comentarioId?: IntNullableWithAggregatesFilter<"Reporte"> | number | null
    motivo?: StringWithAggregatesFilter<"Reporte"> | string
    estado?: StringWithAggregatesFilter<"Reporte"> | string
    fechaReporte?: DateTimeWithAggregatesFilter<"Reporte"> | Date | string
  }

  export type TipoComidaWhereInput = {
    AND?: TipoComidaWhereInput | TipoComidaWhereInput[]
    OR?: TipoComidaWhereInput[]
    NOT?: TipoComidaWhereInput | TipoComidaWhereInput[]
    id?: IntFilter<"TipoComida"> | number
    nombre?: StringFilter<"TipoComida"> | string
    Receta?: RecetaListRelationFilter
  }

  export type TipoComidaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Receta?: RecetaOrderByRelationAggregateInput
  }

  export type TipoComidaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: TipoComidaWhereInput | TipoComidaWhereInput[]
    OR?: TipoComidaWhereInput[]
    NOT?: TipoComidaWhereInput | TipoComidaWhereInput[]
    Receta?: RecetaListRelationFilter
  }, "id" | "nombre">

  export type TipoComidaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: TipoComidaCountOrderByAggregateInput
    _avg?: TipoComidaAvgOrderByAggregateInput
    _max?: TipoComidaMaxOrderByAggregateInput
    _min?: TipoComidaMinOrderByAggregateInput
    _sum?: TipoComidaSumOrderByAggregateInput
  }

  export type TipoComidaScalarWhereWithAggregatesInput = {
    AND?: TipoComidaScalarWhereWithAggregatesInput | TipoComidaScalarWhereWithAggregatesInput[]
    OR?: TipoComidaScalarWhereWithAggregatesInput[]
    NOT?: TipoComidaScalarWhereWithAggregatesInput | TipoComidaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoComida"> | number
    nombre?: StringWithAggregatesFilter<"TipoComida"> | string
  }

  export type TipoSaborWhereInput = {
    AND?: TipoSaborWhereInput | TipoSaborWhereInput[]
    OR?: TipoSaborWhereInput[]
    NOT?: TipoSaborWhereInput | TipoSaborWhereInput[]
    id?: IntFilter<"TipoSabor"> | number
    nombreSabor?: EnumNombreSaborFilter<"TipoSabor"> | $Enums.NombreSabor
    Receta?: RecetaListRelationFilter
  }

  export type TipoSaborOrderByWithRelationInput = {
    id?: SortOrder
    nombreSabor?: SortOrder
    Receta?: RecetaOrderByRelationAggregateInput
  }

  export type TipoSaborWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TipoSaborWhereInput | TipoSaborWhereInput[]
    OR?: TipoSaborWhereInput[]
    NOT?: TipoSaborWhereInput | TipoSaborWhereInput[]
    nombreSabor?: EnumNombreSaborFilter<"TipoSabor"> | $Enums.NombreSabor
    Receta?: RecetaListRelationFilter
  }, "id">

  export type TipoSaborOrderByWithAggregationInput = {
    id?: SortOrder
    nombreSabor?: SortOrder
    _count?: TipoSaborCountOrderByAggregateInput
    _avg?: TipoSaborAvgOrderByAggregateInput
    _max?: TipoSaborMaxOrderByAggregateInput
    _min?: TipoSaborMinOrderByAggregateInput
    _sum?: TipoSaborSumOrderByAggregateInput
  }

  export type TipoSaborScalarWhereWithAggregatesInput = {
    AND?: TipoSaborScalarWhereWithAggregatesInput | TipoSaborScalarWhereWithAggregatesInput[]
    OR?: TipoSaborScalarWhereWithAggregatesInput[]
    NOT?: TipoSaborScalarWhereWithAggregatesInput | TipoSaborScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoSabor"> | number
    nombreSabor?: EnumNombreSaborWithAggregatesFilter<"TipoSabor"> | $Enums.NombreSabor
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellidoP?: StringFilter<"Usuario"> | string
    apellidoM?: StringNullableFilter<"Usuario"> | string | null
    email?: StringFilter<"Usuario"> | string
    contrase_a?: StringFilter<"Usuario"> | string
    fotoPerfil?: StringNullableFilter<"Usuario"> | string | null
    preferencias?: JsonNullableFilter<"Usuario">
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    nombreUsuario?: StringFilter<"Usuario"> | string
    fechaActualizado?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumUserRoleFilter<"Usuario"> | $Enums.UserRole
    biografia?: StringNullableFilter<"Usuario"> | string | null
    primerInicioSesion?: BoolFilter<"Usuario"> | boolean
    titulo?: StringNullableFilter<"Usuario"> | string | null
    verificado?: BoolFilter<"Usuario"> | boolean
    Calificacion?: CalificacionListRelationFilter
    Comentario?: ComentarioListRelationFilter
    Cuenta?: CuentaListRelationFilter
    Favorito?: FavoritoListRelationFilter
    ListaCompra?: ListaCompraListRelationFilter
    Notificacion?: NotificacionListRelationFilter
    Receta?: RecetaListRelationFilter
    Reporte?: ReporteListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidoP?: SortOrder
    apellidoM?: SortOrderInput | SortOrder
    email?: SortOrder
    contrase_a?: SortOrder
    fotoPerfil?: SortOrderInput | SortOrder
    preferencias?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrder
    nombreUsuario?: SortOrder
    fechaActualizado?: SortOrder
    rol?: SortOrder
    biografia?: SortOrderInput | SortOrder
    primerInicioSesion?: SortOrder
    titulo?: SortOrderInput | SortOrder
    verificado?: SortOrder
    Calificacion?: CalificacionOrderByRelationAggregateInput
    Comentario?: ComentarioOrderByRelationAggregateInput
    Cuenta?: CuentaOrderByRelationAggregateInput
    Favorito?: FavoritoOrderByRelationAggregateInput
    ListaCompra?: ListaCompraOrderByRelationAggregateInput
    Notificacion?: NotificacionOrderByRelationAggregateInput
    Receta?: RecetaOrderByRelationAggregateInput
    Reporte?: ReporteOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    nombreUsuario?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellidoP?: StringFilter<"Usuario"> | string
    apellidoM?: StringNullableFilter<"Usuario"> | string | null
    contrase_a?: StringFilter<"Usuario"> | string
    fotoPerfil?: StringNullableFilter<"Usuario"> | string | null
    preferencias?: JsonNullableFilter<"Usuario">
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    fechaActualizado?: DateTimeFilter<"Usuario"> | Date | string
    rol?: EnumUserRoleFilter<"Usuario"> | $Enums.UserRole
    biografia?: StringNullableFilter<"Usuario"> | string | null
    primerInicioSesion?: BoolFilter<"Usuario"> | boolean
    titulo?: StringNullableFilter<"Usuario"> | string | null
    verificado?: BoolFilter<"Usuario"> | boolean
    Calificacion?: CalificacionListRelationFilter
    Comentario?: ComentarioListRelationFilter
    Cuenta?: CuentaListRelationFilter
    Favorito?: FavoritoListRelationFilter
    ListaCompra?: ListaCompraListRelationFilter
    Notificacion?: NotificacionListRelationFilter
    Receta?: RecetaListRelationFilter
    Reporte?: ReporteListRelationFilter
  }, "id" | "email" | "nombreUsuario">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidoP?: SortOrder
    apellidoM?: SortOrderInput | SortOrder
    email?: SortOrder
    contrase_a?: SortOrder
    fotoPerfil?: SortOrderInput | SortOrder
    preferencias?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrder
    nombreUsuario?: SortOrder
    fechaActualizado?: SortOrder
    rol?: SortOrder
    biografia?: SortOrderInput | SortOrder
    primerInicioSesion?: SortOrder
    titulo?: SortOrderInput | SortOrder
    verificado?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellidoP?: StringWithAggregatesFilter<"Usuario"> | string
    apellidoM?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    email?: StringWithAggregatesFilter<"Usuario"> | string
    contrase_a?: StringWithAggregatesFilter<"Usuario"> | string
    fotoPerfil?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    preferencias?: JsonNullableWithAggregatesFilter<"Usuario">
    fechaRegistro?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    nombreUsuario?: StringWithAggregatesFilter<"Usuario"> | string
    fechaActualizado?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    rol?: EnumUserRoleWithAggregatesFilter<"Usuario"> | $Enums.UserRole
    biografia?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    primerInicioSesion?: BoolWithAggregatesFilter<"Usuario"> | boolean
    titulo?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    verificado?: BoolWithAggregatesFilter<"Usuario"> | boolean
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    id?: IntFilter<"VerificationToken"> | number
  }

  export type VerificationTokenOrderByWithRelationInput = {
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    id?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    token?: string
    id?: number
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "email" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    id?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _avg?: VerificationTokenAvgOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
    _sum?: VerificationTokenSumOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    id?: IntWithAggregatesFilter<"VerificationToken"> | number
  }

  export type CalificacionCreateInput = {
    puntuacion: number
    fechaCalificacion?: Date | string
    Receta: RecetaCreateNestedOneWithoutCalificacionInput
    Usuario: UsuarioCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateInput = {
    id?: number
    usuarioId: number
    recetaId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type CalificacionUpdateInput = {
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutCalificacionNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionCreateManyInput = {
    id?: number
    usuarioId: number
    recetaId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type CalificacionUpdateManyMutationInput = {
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioCreateInput = {
    comentario: string
    fechaComentario?: Date | string
    Receta: RecetaCreateNestedOneWithoutComentarioInput
    Usuario: UsuarioCreateNestedOneWithoutComentarioInput
    Reporte?: ReporteCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioUncheckedCreateInput = {
    id?: number
    usuarioId: number
    recetaId: number
    comentario: string
    fechaComentario?: Date | string
    Reporte?: ReporteUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutComentarioNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutComentarioNestedInput
    Reporte?: ReporteUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Reporte?: ReporteUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioCreateManyInput = {
    id?: number
    usuarioId: number
    recetaId: number
    comentario: string
    fechaComentario?: Date | string
  }

  export type ComentarioUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaCreateInput = {
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Usuario: UsuarioCreateNestedOneWithoutCuentaInput
  }

  export type CuentaUncheckedCreateInput = {
    idUsuario: number
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CuentaUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutCuentaNestedInput
  }

  export type CuentaUncheckedUpdateInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaCreateManyInput = {
    idUsuario: number
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CuentaUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaUncheckedUpdateManyInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoCreateInput = {
    fechaGuardado?: Date | string
    Receta: RecetaCreateNestedOneWithoutFavoritoInput
    Usuario: UsuarioCreateNestedOneWithoutFavoritoInput
  }

  export type FavoritoUncheckedCreateInput = {
    id?: number
    usuarioId: number
    recetaId: number
    fechaGuardado?: Date | string
  }

  export type FavoritoUpdateInput = {
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutFavoritoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutFavoritoNestedInput
  }

  export type FavoritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoCreateManyInput = {
    id?: number
    usuarioId: number
    recetaId: number
    fechaGuardado?: Date | string
  }

  export type FavoritoUpdateManyMutationInput = {
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredienteCreateInput = {
    nombre: string
    Tipo: $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutIngredienteInput
  }

  export type IngredienteUncheckedCreateInput = {
    id?: number
    nombre: string
    Tipo: $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutIngredienteInput
  }

  export type IngredienteUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutIngredienteNestedInput
  }

  export type IngredienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutIngredienteNestedInput
  }

  export type IngredienteCreateManyInput = {
    id?: number
    nombre: string
    Tipo: $Enums.TipoIngrediente
  }

  export type IngredienteUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
  }

  export type IngredienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
  }

  export type ListaCompraCreateInput = {
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
    Usuario: UsuarioCreateNestedOneWithoutListaCompraInput
  }

  export type ListaCompraUncheckedCreateInput = {
    id?: number
    usuarioId: number
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
  }

  export type ListaCompraUpdateInput = {
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutListaCompraNestedInput
  }

  export type ListaCompraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListaCompraCreateManyInput = {
    id?: number
    usuarioId: number
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
  }

  export type ListaCompraUpdateManyMutationInput = {
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListaCompraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateInput = {
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
    Usuario: UsuarioCreateNestedOneWithoutNotificacionInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: number
    usuarioId: number
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
  }

  export type NotificacionUpdateInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutNotificacionNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateManyInput = {
    id?: number
    usuarioId: number
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
  }

  export type NotificacionUpdateManyMutationInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaCreateInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaCreateManyInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
  }

  export type RecetaUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
  }

  export type RecetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
  }

  export type RecetaIngredienteCreateInput = {
    cantidad: string
    Ingrediente: IngredienteCreateNestedOneWithoutRecetaIngredienteInput
    Receta: RecetaCreateNestedOneWithoutRecetaIngredienteInput
  }

  export type RecetaIngredienteUncheckedCreateInput = {
    id?: number
    recetaId: number
    ingredienteId: number
    cantidad: string
  }

  export type RecetaIngredienteUpdateInput = {
    cantidad?: StringFieldUpdateOperationsInput | string
    Ingrediente?: IngredienteUpdateOneRequiredWithoutRecetaIngredienteNestedInput
    Receta?: RecetaUpdateOneRequiredWithoutRecetaIngredienteNestedInput
  }

  export type RecetaIngredienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    ingredienteId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type RecetaIngredienteCreateManyInput = {
    id?: number
    recetaId: number
    ingredienteId: number
    cantidad: string
  }

  export type RecetaIngredienteUpdateManyMutationInput = {
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type RecetaIngredienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    ingredienteId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteCreateInput = {
    motivo: string
    estado?: string
    fechaReporte?: Date | string
    Comentario?: ComentarioCreateNestedOneWithoutReporteInput
    Receta?: RecetaCreateNestedOneWithoutReporteInput
    Usuario: UsuarioCreateNestedOneWithoutReporteInput
  }

  export type ReporteUncheckedCreateInput = {
    id?: number
    usuarioId: number
    recetaId?: number | null
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteUpdateInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    Comentario?: ComentarioUpdateOneWithoutReporteNestedInput
    Receta?: RecetaUpdateOneWithoutReporteNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReporteNestedInput
  }

  export type ReporteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteCreateManyInput = {
    id?: number
    usuarioId: number
    recetaId?: number | null
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteUpdateManyMutationInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoComidaCreateInput = {
    nombre: string
    Receta?: RecetaCreateNestedManyWithoutTipoComidaInput
  }

  export type TipoComidaUncheckedCreateInput = {
    id?: number
    nombre: string
    Receta?: RecetaUncheckedCreateNestedManyWithoutTipoComidaInput
  }

  export type TipoComidaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Receta?: RecetaUpdateManyWithoutTipoComidaNestedInput
  }

  export type TipoComidaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Receta?: RecetaUncheckedUpdateManyWithoutTipoComidaNestedInput
  }

  export type TipoComidaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type TipoComidaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoComidaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoSaborCreateInput = {
    nombreSabor: $Enums.NombreSabor
    Receta?: RecetaCreateNestedManyWithoutTipoSaborInput
  }

  export type TipoSaborUncheckedCreateInput = {
    id?: number
    nombreSabor: $Enums.NombreSabor
    Receta?: RecetaUncheckedCreateNestedManyWithoutTipoSaborInput
  }

  export type TipoSaborUpdateInput = {
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
    Receta?: RecetaUpdateManyWithoutTipoSaborNestedInput
  }

  export type TipoSaborUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
    Receta?: RecetaUncheckedUpdateManyWithoutTipoSaborNestedInput
  }

  export type TipoSaborCreateManyInput = {
    id?: number
    nombreSabor: $Enums.NombreSabor
  }

  export type TipoSaborUpdateManyMutationInput = {
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
  }

  export type TipoSaborUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
  }

  export type UsuarioCreateInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VerificationTokenCreateInput = {
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    email: string
    token: string
    expires: Date | string
    id?: number
  }

  export type VerificationTokenUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VerificationTokenCreateManyInput = {
    email: string
    token: string
    expires: Date | string
    id?: number
  }

  export type VerificationTokenUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RecetaScalarRelationFilter = {
    is?: RecetaWhereInput
    isNot?: RecetaWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type CalificacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
    fechaCalificacion?: SortOrder
  }

  export type CalificacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
  }

  export type CalificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
    fechaCalificacion?: SortOrder
  }

  export type CalificacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
    fechaCalificacion?: SortOrder
  }

  export type CalificacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    puntuacion?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ReporteListRelationFilter = {
    every?: ReporteWhereInput
    some?: ReporteWhereInput
    none?: ReporteWhereInput
  }

  export type ReporteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
  }

  export type ComentarioAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
  }

  export type ComentarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
  }

  export type ComentarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
  }

  export type ComentarioSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CuentaProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type CuentaCountOrderByAggregateInput = {
    idUsuario?: SortOrder
    tipo?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuentaAvgOrderByAggregateInput = {
    idUsuario?: SortOrder
    expires_at?: SortOrder
  }

  export type CuentaMaxOrderByAggregateInput = {
    idUsuario?: SortOrder
    tipo?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuentaMinOrderByAggregateInput = {
    idUsuario?: SortOrder
    tipo?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CuentaSumOrderByAggregateInput = {
    idUsuario?: SortOrder
    expires_at?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FavoritoCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    fechaGuardado?: SortOrder
  }

  export type FavoritoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
  }

  export type FavoritoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    fechaGuardado?: SortOrder
  }

  export type FavoritoMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    fechaGuardado?: SortOrder
  }

  export type FavoritoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
  }

  export type EnumTipoIngredienteFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIngrediente | EnumTipoIngredienteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIngredienteFilter<$PrismaModel> | $Enums.TipoIngrediente
  }

  export type RecetaIngredienteListRelationFilter = {
    every?: RecetaIngredienteWhereInput
    some?: RecetaIngredienteWhereInput
    none?: RecetaIngredienteWhereInput
  }

  export type RecetaIngredienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredienteCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    Tipo?: SortOrder
  }

  export type IngredienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IngredienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    Tipo?: SortOrder
  }

  export type IngredienteMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    Tipo?: SortOrder
  }

  export type IngredienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoIngredienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIngrediente | EnumTipoIngredienteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIngredienteWithAggregatesFilter<$PrismaModel> | $Enums.TipoIngrediente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoIngredienteFilter<$PrismaModel>
    _max?: NestedEnumTipoIngredienteFilter<$PrismaModel>
  }

  export type ListaCompraCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombreIngrediente?: SortOrder
    cantidad?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ListaCompraAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    cantidad?: SortOrder
  }

  export type ListaCompraMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombreIngrediente?: SortOrder
    cantidad?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ListaCompraMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombreIngrediente?: SortOrder
    cantidad?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ListaCompraSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    cantidad?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    fechaNotificacion?: SortOrder
  }

  export type NotificacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    fechaNotificacion?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    mensaje?: SortOrder
    leida?: SortOrder
    fechaNotificacion?: SortOrder
  }

  export type NotificacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumDificultadRecetaFilter<$PrismaModel = never> = {
    equals?: $Enums.DificultadReceta | EnumDificultadRecetaFieldRefInput<$PrismaModel>
    in?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    notIn?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    not?: NestedEnumDificultadRecetaFilter<$PrismaModel> | $Enums.DificultadReceta
  }

  export type CalificacionListRelationFilter = {
    every?: CalificacionWhereInput
    some?: CalificacionWhereInput
    none?: CalificacionWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: ComentarioWhereInput
    some?: ComentarioWhereInput
    none?: ComentarioWhereInput
  }

  export type FavoritoListRelationFilter = {
    every?: FavoritoWhereInput
    some?: FavoritoWhereInput
    none?: FavoritoWhereInput
  }

  export type TipoComidaScalarRelationFilter = {
    is?: TipoComidaWhereInput
    isNot?: TipoComidaWhereInput
  }

  export type TipoSaborScalarRelationFilter = {
    is?: TipoSaborWhereInput
    isNot?: TipoSaborWhereInput
  }

  export type CalificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecetaCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    imagen?: SortOrder
    fechaCreacion?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
    dificultad?: SortOrder
  }

  export type RecetaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
  }

  export type RecetaMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    imagen?: SortOrder
    fechaCreacion?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
    dificultad?: SortOrder
  }

  export type RecetaMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    imagen?: SortOrder
    fechaCreacion?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
    dificultad?: SortOrder
  }

  export type RecetaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tiempoPreparacion?: SortOrder
    porciones?: SortOrder
    idTipoComida?: SortOrder
    idTipoSabor?: SortOrder
  }

  export type EnumDificultadRecetaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DificultadReceta | EnumDificultadRecetaFieldRefInput<$PrismaModel>
    in?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    notIn?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    not?: NestedEnumDificultadRecetaWithAggregatesFilter<$PrismaModel> | $Enums.DificultadReceta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDificultadRecetaFilter<$PrismaModel>
    _max?: NestedEnumDificultadRecetaFilter<$PrismaModel>
  }

  export type IngredienteScalarRelationFilter = {
    is?: IngredienteWhereInput
    isNot?: IngredienteWhereInput
  }

  export type RecetaIngredienteCountOrderByAggregateInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
    cantidad?: SortOrder
  }

  export type RecetaIngredienteAvgOrderByAggregateInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
  }

  export type RecetaIngredienteMaxOrderByAggregateInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
    cantidad?: SortOrder
  }

  export type RecetaIngredienteMinOrderByAggregateInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
    cantidad?: SortOrder
  }

  export type RecetaIngredienteSumOrderByAggregateInput = {
    id?: SortOrder
    recetaId?: SortOrder
    ingredienteId?: SortOrder
  }

  export type ComentarioNullableScalarRelationFilter = {
    is?: ComentarioWhereInput | null
    isNot?: ComentarioWhereInput | null
  }

  export type RecetaNullableScalarRelationFilter = {
    is?: RecetaWhereInput | null
    isNot?: RecetaWhereInput | null
  }

  export type ReporteCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentarioId?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
  }

  export type ReporteAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentarioId?: SortOrder
  }

  export type ReporteMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentarioId?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
  }

  export type ReporteMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentarioId?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    fechaReporte?: SortOrder
  }

  export type ReporteSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    recetaId?: SortOrder
    comentarioId?: SortOrder
  }

  export type RecetaListRelationFilter = {
    every?: RecetaWhereInput
    some?: RecetaWhereInput
    none?: RecetaWhereInput
  }

  export type RecetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoComidaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type TipoComidaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoComidaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type TipoComidaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type TipoComidaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNombreSaborFilter<$PrismaModel = never> = {
    equals?: $Enums.NombreSabor | EnumNombreSaborFieldRefInput<$PrismaModel>
    in?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    notIn?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    not?: NestedEnumNombreSaborFilter<$PrismaModel> | $Enums.NombreSabor
  }

  export type TipoSaborCountOrderByAggregateInput = {
    id?: SortOrder
    nombreSabor?: SortOrder
  }

  export type TipoSaborAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoSaborMaxOrderByAggregateInput = {
    id?: SortOrder
    nombreSabor?: SortOrder
  }

  export type TipoSaborMinOrderByAggregateInput = {
    id?: SortOrder
    nombreSabor?: SortOrder
  }

  export type TipoSaborSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNombreSaborWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NombreSabor | EnumNombreSaborFieldRefInput<$PrismaModel>
    in?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    notIn?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    not?: NestedEnumNombreSaborWithAggregatesFilter<$PrismaModel> | $Enums.NombreSabor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNombreSaborFilter<$PrismaModel>
    _max?: NestedEnumNombreSaborFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type CuentaListRelationFilter = {
    every?: CuentaWhereInput
    some?: CuentaWhereInput
    none?: CuentaWhereInput
  }

  export type ListaCompraListRelationFilter = {
    every?: ListaCompraWhereInput
    some?: ListaCompraWhereInput
    none?: ListaCompraWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type CuentaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListaCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidoP?: SortOrder
    apellidoM?: SortOrder
    email?: SortOrder
    contrase_a?: SortOrder
    fotoPerfil?: SortOrder
    preferencias?: SortOrder
    fechaRegistro?: SortOrder
    nombreUsuario?: SortOrder
    fechaActualizado?: SortOrder
    rol?: SortOrder
    biografia?: SortOrder
    primerInicioSesion?: SortOrder
    titulo?: SortOrder
    verificado?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidoP?: SortOrder
    apellidoM?: SortOrder
    email?: SortOrder
    contrase_a?: SortOrder
    fotoPerfil?: SortOrder
    fechaRegistro?: SortOrder
    nombreUsuario?: SortOrder
    fechaActualizado?: SortOrder
    rol?: SortOrder
    biografia?: SortOrder
    primerInicioSesion?: SortOrder
    titulo?: SortOrder
    verificado?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidoP?: SortOrder
    apellidoM?: SortOrder
    email?: SortOrder
    contrase_a?: SortOrder
    fotoPerfil?: SortOrder
    fechaRegistro?: SortOrder
    nombreUsuario?: SortOrder
    fechaActualizado?: SortOrder
    rol?: SortOrder
    biografia?: SortOrder
    primerInicioSesion?: SortOrder
    titulo?: SortOrder
    verificado?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    id?: SortOrder
  }

  export type VerificationTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    id?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    id?: SortOrder
  }

  export type VerificationTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecetaCreateNestedOneWithoutCalificacionInput = {
    create?: XOR<RecetaCreateWithoutCalificacionInput, RecetaUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutCalificacionInput
    connect?: RecetaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutCalificacionInput = {
    create?: XOR<UsuarioCreateWithoutCalificacionInput, UsuarioUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCalificacionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RecetaUpdateOneRequiredWithoutCalificacionNestedInput = {
    create?: XOR<RecetaCreateWithoutCalificacionInput, RecetaUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutCalificacionInput
    upsert?: RecetaUpsertWithoutCalificacionInput
    connect?: RecetaWhereUniqueInput
    update?: XOR<XOR<RecetaUpdateToOneWithWhereWithoutCalificacionInput, RecetaUpdateWithoutCalificacionInput>, RecetaUncheckedUpdateWithoutCalificacionInput>
  }

  export type UsuarioUpdateOneRequiredWithoutCalificacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutCalificacionInput, UsuarioUncheckedCreateWithoutCalificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCalificacionInput
    upsert?: UsuarioUpsertWithoutCalificacionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCalificacionInput, UsuarioUpdateWithoutCalificacionInput>, UsuarioUncheckedUpdateWithoutCalificacionInput>
  }

  export type RecetaCreateNestedOneWithoutComentarioInput = {
    create?: XOR<RecetaCreateWithoutComentarioInput, RecetaUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutComentarioInput
    connect?: RecetaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentarioInput = {
    create?: XOR<UsuarioCreateWithoutComentarioInput, UsuarioUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ReporteCreateNestedManyWithoutComentarioInput = {
    create?: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput> | ReporteCreateWithoutComentarioInput[] | ReporteUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutComentarioInput | ReporteCreateOrConnectWithoutComentarioInput[]
    createMany?: ReporteCreateManyComentarioInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type ReporteUncheckedCreateNestedManyWithoutComentarioInput = {
    create?: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput> | ReporteCreateWithoutComentarioInput[] | ReporteUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutComentarioInput | ReporteCreateOrConnectWithoutComentarioInput[]
    createMany?: ReporteCreateManyComentarioInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RecetaUpdateOneRequiredWithoutComentarioNestedInput = {
    create?: XOR<RecetaCreateWithoutComentarioInput, RecetaUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutComentarioInput
    upsert?: RecetaUpsertWithoutComentarioInput
    connect?: RecetaWhereUniqueInput
    update?: XOR<XOR<RecetaUpdateToOneWithWhereWithoutComentarioInput, RecetaUpdateWithoutComentarioInput>, RecetaUncheckedUpdateWithoutComentarioInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentarioInput, UsuarioUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentarioInput
    upsert?: UsuarioUpsertWithoutComentarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComentarioInput, UsuarioUpdateWithoutComentarioInput>, UsuarioUncheckedUpdateWithoutComentarioInput>
  }

  export type ReporteUpdateManyWithoutComentarioNestedInput = {
    create?: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput> | ReporteCreateWithoutComentarioInput[] | ReporteUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutComentarioInput | ReporteCreateOrConnectWithoutComentarioInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutComentarioInput | ReporteUpsertWithWhereUniqueWithoutComentarioInput[]
    createMany?: ReporteCreateManyComentarioInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutComentarioInput | ReporteUpdateWithWhereUniqueWithoutComentarioInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutComentarioInput | ReporteUpdateManyWithWhereWithoutComentarioInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type ReporteUncheckedUpdateManyWithoutComentarioNestedInput = {
    create?: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput> | ReporteCreateWithoutComentarioInput[] | ReporteUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutComentarioInput | ReporteCreateOrConnectWithoutComentarioInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutComentarioInput | ReporteUpsertWithWhereUniqueWithoutComentarioInput[]
    createMany?: ReporteCreateManyComentarioInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutComentarioInput | ReporteUpdateWithWhereUniqueWithoutComentarioInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutComentarioInput | ReporteUpdateManyWithWhereWithoutComentarioInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutCuentaInput = {
    create?: XOR<UsuarioCreateWithoutCuentaInput, UsuarioUncheckedCreateWithoutCuentaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCuentaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutCuentaNestedInput = {
    create?: XOR<UsuarioCreateWithoutCuentaInput, UsuarioUncheckedCreateWithoutCuentaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCuentaInput
    upsert?: UsuarioUpsertWithoutCuentaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCuentaInput, UsuarioUpdateWithoutCuentaInput>, UsuarioUncheckedUpdateWithoutCuentaInput>
  }

  export type RecetaCreateNestedOneWithoutFavoritoInput = {
    create?: XOR<RecetaCreateWithoutFavoritoInput, RecetaUncheckedCreateWithoutFavoritoInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutFavoritoInput
    connect?: RecetaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutFavoritoInput = {
    create?: XOR<UsuarioCreateWithoutFavoritoInput, UsuarioUncheckedCreateWithoutFavoritoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RecetaUpdateOneRequiredWithoutFavoritoNestedInput = {
    create?: XOR<RecetaCreateWithoutFavoritoInput, RecetaUncheckedCreateWithoutFavoritoInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutFavoritoInput
    upsert?: RecetaUpsertWithoutFavoritoInput
    connect?: RecetaWhereUniqueInput
    update?: XOR<XOR<RecetaUpdateToOneWithWhereWithoutFavoritoInput, RecetaUpdateWithoutFavoritoInput>, RecetaUncheckedUpdateWithoutFavoritoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutFavoritoNestedInput = {
    create?: XOR<UsuarioCreateWithoutFavoritoInput, UsuarioUncheckedCreateWithoutFavoritoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritoInput
    upsert?: UsuarioUpsertWithoutFavoritoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutFavoritoInput, UsuarioUpdateWithoutFavoritoInput>, UsuarioUncheckedUpdateWithoutFavoritoInput>
  }

  export type RecetaIngredienteCreateNestedManyWithoutIngredienteInput = {
    create?: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput> | RecetaIngredienteCreateWithoutIngredienteInput[] | RecetaIngredienteUncheckedCreateWithoutIngredienteInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutIngredienteInput | RecetaIngredienteCreateOrConnectWithoutIngredienteInput[]
    createMany?: RecetaIngredienteCreateManyIngredienteInputEnvelope
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
  }

  export type RecetaIngredienteUncheckedCreateNestedManyWithoutIngredienteInput = {
    create?: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput> | RecetaIngredienteCreateWithoutIngredienteInput[] | RecetaIngredienteUncheckedCreateWithoutIngredienteInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutIngredienteInput | RecetaIngredienteCreateOrConnectWithoutIngredienteInput[]
    createMany?: RecetaIngredienteCreateManyIngredienteInputEnvelope
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
  }

  export type EnumTipoIngredienteFieldUpdateOperationsInput = {
    set?: $Enums.TipoIngrediente
  }

  export type RecetaIngredienteUpdateManyWithoutIngredienteNestedInput = {
    create?: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput> | RecetaIngredienteCreateWithoutIngredienteInput[] | RecetaIngredienteUncheckedCreateWithoutIngredienteInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutIngredienteInput | RecetaIngredienteCreateOrConnectWithoutIngredienteInput[]
    upsert?: RecetaIngredienteUpsertWithWhereUniqueWithoutIngredienteInput | RecetaIngredienteUpsertWithWhereUniqueWithoutIngredienteInput[]
    createMany?: RecetaIngredienteCreateManyIngredienteInputEnvelope
    set?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    disconnect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    delete?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    update?: RecetaIngredienteUpdateWithWhereUniqueWithoutIngredienteInput | RecetaIngredienteUpdateWithWhereUniqueWithoutIngredienteInput[]
    updateMany?: RecetaIngredienteUpdateManyWithWhereWithoutIngredienteInput | RecetaIngredienteUpdateManyWithWhereWithoutIngredienteInput[]
    deleteMany?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
  }

  export type RecetaIngredienteUncheckedUpdateManyWithoutIngredienteNestedInput = {
    create?: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput> | RecetaIngredienteCreateWithoutIngredienteInput[] | RecetaIngredienteUncheckedCreateWithoutIngredienteInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutIngredienteInput | RecetaIngredienteCreateOrConnectWithoutIngredienteInput[]
    upsert?: RecetaIngredienteUpsertWithWhereUniqueWithoutIngredienteInput | RecetaIngredienteUpsertWithWhereUniqueWithoutIngredienteInput[]
    createMany?: RecetaIngredienteCreateManyIngredienteInputEnvelope
    set?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    disconnect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    delete?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    update?: RecetaIngredienteUpdateWithWhereUniqueWithoutIngredienteInput | RecetaIngredienteUpdateWithWhereUniqueWithoutIngredienteInput[]
    updateMany?: RecetaIngredienteUpdateManyWithWhereWithoutIngredienteInput | RecetaIngredienteUpdateManyWithWhereWithoutIngredienteInput[]
    deleteMany?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutListaCompraInput = {
    create?: XOR<UsuarioCreateWithoutListaCompraInput, UsuarioUncheckedCreateWithoutListaCompraInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutListaCompraInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutListaCompraNestedInput = {
    create?: XOR<UsuarioCreateWithoutListaCompraInput, UsuarioUncheckedCreateWithoutListaCompraInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutListaCompraInput
    upsert?: UsuarioUpsertWithoutListaCompraInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutListaCompraInput, UsuarioUpdateWithoutListaCompraInput>, UsuarioUncheckedUpdateWithoutListaCompraInput>
  }

  export type UsuarioCreateNestedOneWithoutNotificacionInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsuarioUpdateOneRequiredWithoutNotificacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionInput
    upsert?: UsuarioUpsertWithoutNotificacionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutNotificacionInput, UsuarioUpdateWithoutNotificacionInput>, UsuarioUncheckedUpdateWithoutNotificacionInput>
  }

  export type CalificacionCreateNestedManyWithoutRecetaInput = {
    create?: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput> | CalificacionCreateWithoutRecetaInput[] | CalificacionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutRecetaInput | CalificacionCreateOrConnectWithoutRecetaInput[]
    createMany?: CalificacionCreateManyRecetaInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutRecetaInput = {
    create?: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput> | ComentarioCreateWithoutRecetaInput[] | ComentarioUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutRecetaInput | ComentarioCreateOrConnectWithoutRecetaInput[]
    createMany?: ComentarioCreateManyRecetaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type FavoritoCreateNestedManyWithoutRecetaInput = {
    create?: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput> | FavoritoCreateWithoutRecetaInput[] | FavoritoUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutRecetaInput | FavoritoCreateOrConnectWithoutRecetaInput[]
    createMany?: FavoritoCreateManyRecetaInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type TipoComidaCreateNestedOneWithoutRecetaInput = {
    create?: XOR<TipoComidaCreateWithoutRecetaInput, TipoComidaUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: TipoComidaCreateOrConnectWithoutRecetaInput
    connect?: TipoComidaWhereUniqueInput
  }

  export type TipoSaborCreateNestedOneWithoutRecetaInput = {
    create?: XOR<TipoSaborCreateWithoutRecetaInput, TipoSaborUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: TipoSaborCreateOrConnectWithoutRecetaInput
    connect?: TipoSaborWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRecetaInput = {
    create?: XOR<UsuarioCreateWithoutRecetaInput, UsuarioUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRecetaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RecetaIngredienteCreateNestedManyWithoutRecetaInput = {
    create?: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput> | RecetaIngredienteCreateWithoutRecetaInput[] | RecetaIngredienteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutRecetaInput | RecetaIngredienteCreateOrConnectWithoutRecetaInput[]
    createMany?: RecetaIngredienteCreateManyRecetaInputEnvelope
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
  }

  export type ReporteCreateNestedManyWithoutRecetaInput = {
    create?: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput> | ReporteCreateWithoutRecetaInput[] | ReporteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutRecetaInput | ReporteCreateOrConnectWithoutRecetaInput[]
    createMany?: ReporteCreateManyRecetaInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type CalificacionUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput> | CalificacionCreateWithoutRecetaInput[] | CalificacionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutRecetaInput | CalificacionCreateOrConnectWithoutRecetaInput[]
    createMany?: CalificacionCreateManyRecetaInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput> | ComentarioCreateWithoutRecetaInput[] | ComentarioUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutRecetaInput | ComentarioCreateOrConnectWithoutRecetaInput[]
    createMany?: ComentarioCreateManyRecetaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type FavoritoUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput> | FavoritoCreateWithoutRecetaInput[] | FavoritoUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutRecetaInput | FavoritoCreateOrConnectWithoutRecetaInput[]
    createMany?: FavoritoCreateManyRecetaInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput> | RecetaIngredienteCreateWithoutRecetaInput[] | RecetaIngredienteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutRecetaInput | RecetaIngredienteCreateOrConnectWithoutRecetaInput[]
    createMany?: RecetaIngredienteCreateManyRecetaInputEnvelope
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
  }

  export type ReporteUncheckedCreateNestedManyWithoutRecetaInput = {
    create?: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput> | ReporteCreateWithoutRecetaInput[] | ReporteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutRecetaInput | ReporteCreateOrConnectWithoutRecetaInput[]
    createMany?: ReporteCreateManyRecetaInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type EnumDificultadRecetaFieldUpdateOperationsInput = {
    set?: $Enums.DificultadReceta
  }

  export type CalificacionUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput> | CalificacionCreateWithoutRecetaInput[] | CalificacionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutRecetaInput | CalificacionCreateOrConnectWithoutRecetaInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutRecetaInput | CalificacionUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: CalificacionCreateManyRecetaInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutRecetaInput | CalificacionUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutRecetaInput | CalificacionUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput> | ComentarioCreateWithoutRecetaInput[] | ComentarioUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutRecetaInput | ComentarioCreateOrConnectWithoutRecetaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutRecetaInput | ComentarioUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: ComentarioCreateManyRecetaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutRecetaInput | ComentarioUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutRecetaInput | ComentarioUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type FavoritoUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput> | FavoritoCreateWithoutRecetaInput[] | FavoritoUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutRecetaInput | FavoritoCreateOrConnectWithoutRecetaInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutRecetaInput | FavoritoUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: FavoritoCreateManyRecetaInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutRecetaInput | FavoritoUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutRecetaInput | FavoritoUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type TipoComidaUpdateOneRequiredWithoutRecetaNestedInput = {
    create?: XOR<TipoComidaCreateWithoutRecetaInput, TipoComidaUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: TipoComidaCreateOrConnectWithoutRecetaInput
    upsert?: TipoComidaUpsertWithoutRecetaInput
    connect?: TipoComidaWhereUniqueInput
    update?: XOR<XOR<TipoComidaUpdateToOneWithWhereWithoutRecetaInput, TipoComidaUpdateWithoutRecetaInput>, TipoComidaUncheckedUpdateWithoutRecetaInput>
  }

  export type TipoSaborUpdateOneRequiredWithoutRecetaNestedInput = {
    create?: XOR<TipoSaborCreateWithoutRecetaInput, TipoSaborUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: TipoSaborCreateOrConnectWithoutRecetaInput
    upsert?: TipoSaborUpsertWithoutRecetaInput
    connect?: TipoSaborWhereUniqueInput
    update?: XOR<XOR<TipoSaborUpdateToOneWithWhereWithoutRecetaInput, TipoSaborUpdateWithoutRecetaInput>, TipoSaborUncheckedUpdateWithoutRecetaInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRecetaNestedInput = {
    create?: XOR<UsuarioCreateWithoutRecetaInput, UsuarioUncheckedCreateWithoutRecetaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRecetaInput
    upsert?: UsuarioUpsertWithoutRecetaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRecetaInput, UsuarioUpdateWithoutRecetaInput>, UsuarioUncheckedUpdateWithoutRecetaInput>
  }

  export type RecetaIngredienteUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput> | RecetaIngredienteCreateWithoutRecetaInput[] | RecetaIngredienteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutRecetaInput | RecetaIngredienteCreateOrConnectWithoutRecetaInput[]
    upsert?: RecetaIngredienteUpsertWithWhereUniqueWithoutRecetaInput | RecetaIngredienteUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: RecetaIngredienteCreateManyRecetaInputEnvelope
    set?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    disconnect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    delete?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    update?: RecetaIngredienteUpdateWithWhereUniqueWithoutRecetaInput | RecetaIngredienteUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: RecetaIngredienteUpdateManyWithWhereWithoutRecetaInput | RecetaIngredienteUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
  }

  export type ReporteUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput> | ReporteCreateWithoutRecetaInput[] | ReporteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutRecetaInput | ReporteCreateOrConnectWithoutRecetaInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutRecetaInput | ReporteUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: ReporteCreateManyRecetaInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutRecetaInput | ReporteUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutRecetaInput | ReporteUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type CalificacionUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput> | CalificacionCreateWithoutRecetaInput[] | CalificacionUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutRecetaInput | CalificacionCreateOrConnectWithoutRecetaInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutRecetaInput | CalificacionUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: CalificacionCreateManyRecetaInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutRecetaInput | CalificacionUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutRecetaInput | CalificacionUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput> | ComentarioCreateWithoutRecetaInput[] | ComentarioUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutRecetaInput | ComentarioCreateOrConnectWithoutRecetaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutRecetaInput | ComentarioUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: ComentarioCreateManyRecetaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutRecetaInput | ComentarioUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutRecetaInput | ComentarioUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type FavoritoUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput> | FavoritoCreateWithoutRecetaInput[] | FavoritoUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutRecetaInput | FavoritoCreateOrConnectWithoutRecetaInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutRecetaInput | FavoritoUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: FavoritoCreateManyRecetaInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutRecetaInput | FavoritoUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutRecetaInput | FavoritoUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput> | RecetaIngredienteCreateWithoutRecetaInput[] | RecetaIngredienteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: RecetaIngredienteCreateOrConnectWithoutRecetaInput | RecetaIngredienteCreateOrConnectWithoutRecetaInput[]
    upsert?: RecetaIngredienteUpsertWithWhereUniqueWithoutRecetaInput | RecetaIngredienteUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: RecetaIngredienteCreateManyRecetaInputEnvelope
    set?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    disconnect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    delete?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    connect?: RecetaIngredienteWhereUniqueInput | RecetaIngredienteWhereUniqueInput[]
    update?: RecetaIngredienteUpdateWithWhereUniqueWithoutRecetaInput | RecetaIngredienteUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: RecetaIngredienteUpdateManyWithWhereWithoutRecetaInput | RecetaIngredienteUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
  }

  export type ReporteUncheckedUpdateManyWithoutRecetaNestedInput = {
    create?: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput> | ReporteCreateWithoutRecetaInput[] | ReporteUncheckedCreateWithoutRecetaInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutRecetaInput | ReporteCreateOrConnectWithoutRecetaInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutRecetaInput | ReporteUpsertWithWhereUniqueWithoutRecetaInput[]
    createMany?: ReporteCreateManyRecetaInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutRecetaInput | ReporteUpdateWithWhereUniqueWithoutRecetaInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutRecetaInput | ReporteUpdateManyWithWhereWithoutRecetaInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type IngredienteCreateNestedOneWithoutRecetaIngredienteInput = {
    create?: XOR<IngredienteCreateWithoutRecetaIngredienteInput, IngredienteUncheckedCreateWithoutRecetaIngredienteInput>
    connectOrCreate?: IngredienteCreateOrConnectWithoutRecetaIngredienteInput
    connect?: IngredienteWhereUniqueInput
  }

  export type RecetaCreateNestedOneWithoutRecetaIngredienteInput = {
    create?: XOR<RecetaCreateWithoutRecetaIngredienteInput, RecetaUncheckedCreateWithoutRecetaIngredienteInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutRecetaIngredienteInput
    connect?: RecetaWhereUniqueInput
  }

  export type IngredienteUpdateOneRequiredWithoutRecetaIngredienteNestedInput = {
    create?: XOR<IngredienteCreateWithoutRecetaIngredienteInput, IngredienteUncheckedCreateWithoutRecetaIngredienteInput>
    connectOrCreate?: IngredienteCreateOrConnectWithoutRecetaIngredienteInput
    upsert?: IngredienteUpsertWithoutRecetaIngredienteInput
    connect?: IngredienteWhereUniqueInput
    update?: XOR<XOR<IngredienteUpdateToOneWithWhereWithoutRecetaIngredienteInput, IngredienteUpdateWithoutRecetaIngredienteInput>, IngredienteUncheckedUpdateWithoutRecetaIngredienteInput>
  }

  export type RecetaUpdateOneRequiredWithoutRecetaIngredienteNestedInput = {
    create?: XOR<RecetaCreateWithoutRecetaIngredienteInput, RecetaUncheckedCreateWithoutRecetaIngredienteInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutRecetaIngredienteInput
    upsert?: RecetaUpsertWithoutRecetaIngredienteInput
    connect?: RecetaWhereUniqueInput
    update?: XOR<XOR<RecetaUpdateToOneWithWhereWithoutRecetaIngredienteInput, RecetaUpdateWithoutRecetaIngredienteInput>, RecetaUncheckedUpdateWithoutRecetaIngredienteInput>
  }

  export type ComentarioCreateNestedOneWithoutReporteInput = {
    create?: XOR<ComentarioCreateWithoutReporteInput, ComentarioUncheckedCreateWithoutReporteInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutReporteInput
    connect?: ComentarioWhereUniqueInput
  }

  export type RecetaCreateNestedOneWithoutReporteInput = {
    create?: XOR<RecetaCreateWithoutReporteInput, RecetaUncheckedCreateWithoutReporteInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutReporteInput
    connect?: RecetaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutReporteInput = {
    create?: XOR<UsuarioCreateWithoutReporteInput, UsuarioUncheckedCreateWithoutReporteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReporteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ComentarioUpdateOneWithoutReporteNestedInput = {
    create?: XOR<ComentarioCreateWithoutReporteInput, ComentarioUncheckedCreateWithoutReporteInput>
    connectOrCreate?: ComentarioCreateOrConnectWithoutReporteInput
    upsert?: ComentarioUpsertWithoutReporteInput
    disconnect?: ComentarioWhereInput | boolean
    delete?: ComentarioWhereInput | boolean
    connect?: ComentarioWhereUniqueInput
    update?: XOR<XOR<ComentarioUpdateToOneWithWhereWithoutReporteInput, ComentarioUpdateWithoutReporteInput>, ComentarioUncheckedUpdateWithoutReporteInput>
  }

  export type RecetaUpdateOneWithoutReporteNestedInput = {
    create?: XOR<RecetaCreateWithoutReporteInput, RecetaUncheckedCreateWithoutReporteInput>
    connectOrCreate?: RecetaCreateOrConnectWithoutReporteInput
    upsert?: RecetaUpsertWithoutReporteInput
    disconnect?: RecetaWhereInput | boolean
    delete?: RecetaWhereInput | boolean
    connect?: RecetaWhereUniqueInput
    update?: XOR<XOR<RecetaUpdateToOneWithWhereWithoutReporteInput, RecetaUpdateWithoutReporteInput>, RecetaUncheckedUpdateWithoutReporteInput>
  }

  export type UsuarioUpdateOneRequiredWithoutReporteNestedInput = {
    create?: XOR<UsuarioCreateWithoutReporteInput, UsuarioUncheckedCreateWithoutReporteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReporteInput
    upsert?: UsuarioUpsertWithoutReporteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutReporteInput, UsuarioUpdateWithoutReporteInput>, UsuarioUncheckedUpdateWithoutReporteInput>
  }

  export type RecetaCreateNestedManyWithoutTipoComidaInput = {
    create?: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput> | RecetaCreateWithoutTipoComidaInput[] | RecetaUncheckedCreateWithoutTipoComidaInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoComidaInput | RecetaCreateOrConnectWithoutTipoComidaInput[]
    createMany?: RecetaCreateManyTipoComidaInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type RecetaUncheckedCreateNestedManyWithoutTipoComidaInput = {
    create?: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput> | RecetaCreateWithoutTipoComidaInput[] | RecetaUncheckedCreateWithoutTipoComidaInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoComidaInput | RecetaCreateOrConnectWithoutTipoComidaInput[]
    createMany?: RecetaCreateManyTipoComidaInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type RecetaUpdateManyWithoutTipoComidaNestedInput = {
    create?: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput> | RecetaCreateWithoutTipoComidaInput[] | RecetaUncheckedCreateWithoutTipoComidaInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoComidaInput | RecetaCreateOrConnectWithoutTipoComidaInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutTipoComidaInput | RecetaUpsertWithWhereUniqueWithoutTipoComidaInput[]
    createMany?: RecetaCreateManyTipoComidaInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutTipoComidaInput | RecetaUpdateWithWhereUniqueWithoutTipoComidaInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutTipoComidaInput | RecetaUpdateManyWithWhereWithoutTipoComidaInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type RecetaUncheckedUpdateManyWithoutTipoComidaNestedInput = {
    create?: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput> | RecetaCreateWithoutTipoComidaInput[] | RecetaUncheckedCreateWithoutTipoComidaInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoComidaInput | RecetaCreateOrConnectWithoutTipoComidaInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutTipoComidaInput | RecetaUpsertWithWhereUniqueWithoutTipoComidaInput[]
    createMany?: RecetaCreateManyTipoComidaInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutTipoComidaInput | RecetaUpdateWithWhereUniqueWithoutTipoComidaInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutTipoComidaInput | RecetaUpdateManyWithWhereWithoutTipoComidaInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type RecetaCreateNestedManyWithoutTipoSaborInput = {
    create?: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput> | RecetaCreateWithoutTipoSaborInput[] | RecetaUncheckedCreateWithoutTipoSaborInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoSaborInput | RecetaCreateOrConnectWithoutTipoSaborInput[]
    createMany?: RecetaCreateManyTipoSaborInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type RecetaUncheckedCreateNestedManyWithoutTipoSaborInput = {
    create?: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput> | RecetaCreateWithoutTipoSaborInput[] | RecetaUncheckedCreateWithoutTipoSaborInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoSaborInput | RecetaCreateOrConnectWithoutTipoSaborInput[]
    createMany?: RecetaCreateManyTipoSaborInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type EnumNombreSaborFieldUpdateOperationsInput = {
    set?: $Enums.NombreSabor
  }

  export type RecetaUpdateManyWithoutTipoSaborNestedInput = {
    create?: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput> | RecetaCreateWithoutTipoSaborInput[] | RecetaUncheckedCreateWithoutTipoSaborInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoSaborInput | RecetaCreateOrConnectWithoutTipoSaborInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutTipoSaborInput | RecetaUpsertWithWhereUniqueWithoutTipoSaborInput[]
    createMany?: RecetaCreateManyTipoSaborInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutTipoSaborInput | RecetaUpdateWithWhereUniqueWithoutTipoSaborInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutTipoSaborInput | RecetaUpdateManyWithWhereWithoutTipoSaborInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type RecetaUncheckedUpdateManyWithoutTipoSaborNestedInput = {
    create?: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput> | RecetaCreateWithoutTipoSaborInput[] | RecetaUncheckedCreateWithoutTipoSaborInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutTipoSaborInput | RecetaCreateOrConnectWithoutTipoSaborInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutTipoSaborInput | RecetaUpsertWithWhereUniqueWithoutTipoSaborInput[]
    createMany?: RecetaCreateManyTipoSaborInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutTipoSaborInput | RecetaUpdateWithWhereUniqueWithoutTipoSaborInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutTipoSaborInput | RecetaUpdateManyWithWhereWithoutTipoSaborInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type CalificacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput> | CalificacionCreateWithoutUsuarioInput[] | CalificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutUsuarioInput | CalificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: CalificacionCreateManyUsuarioInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type CuentaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput> | CuentaCreateWithoutUsuarioInput[] | CuentaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CuentaCreateOrConnectWithoutUsuarioInput | CuentaCreateOrConnectWithoutUsuarioInput[]
    createMany?: CuentaCreateManyUsuarioInputEnvelope
    connect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
  }

  export type FavoritoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type ListaCompraCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput> | ListaCompraCreateWithoutUsuarioInput[] | ListaCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ListaCompraCreateOrConnectWithoutUsuarioInput | ListaCompraCreateOrConnectWithoutUsuarioInput[]
    createMany?: ListaCompraCreateManyUsuarioInputEnvelope
    connect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
  }

  export type NotificacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type RecetaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput> | RecetaCreateWithoutUsuarioInput[] | RecetaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutUsuarioInput | RecetaCreateOrConnectWithoutUsuarioInput[]
    createMany?: RecetaCreateManyUsuarioInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type ReporteCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput> | ReporteCreateWithoutUsuarioInput[] | ReporteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutUsuarioInput | ReporteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ReporteCreateManyUsuarioInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type CalificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput> | CalificacionCreateWithoutUsuarioInput[] | CalificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutUsuarioInput | CalificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: CalificacionCreateManyUsuarioInputEnvelope
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type CuentaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput> | CuentaCreateWithoutUsuarioInput[] | CuentaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CuentaCreateOrConnectWithoutUsuarioInput | CuentaCreateOrConnectWithoutUsuarioInput[]
    createMany?: CuentaCreateManyUsuarioInputEnvelope
    connect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
  }

  export type FavoritoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput> | ListaCompraCreateWithoutUsuarioInput[] | ListaCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ListaCompraCreateOrConnectWithoutUsuarioInput | ListaCompraCreateOrConnectWithoutUsuarioInput[]
    createMany?: ListaCompraCreateManyUsuarioInputEnvelope
    connect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
  }

  export type NotificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type RecetaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput> | RecetaCreateWithoutUsuarioInput[] | RecetaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutUsuarioInput | RecetaCreateOrConnectWithoutUsuarioInput[]
    createMany?: RecetaCreateManyUsuarioInputEnvelope
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
  }

  export type ReporteUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput> | ReporteCreateWithoutUsuarioInput[] | ReporteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutUsuarioInput | ReporteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ReporteCreateManyUsuarioInputEnvelope
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type CalificacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput> | CalificacionCreateWithoutUsuarioInput[] | CalificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutUsuarioInput | CalificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutUsuarioInput | CalificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CalificacionCreateManyUsuarioInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutUsuarioInput | CalificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutUsuarioInput | CalificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type CuentaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput> | CuentaCreateWithoutUsuarioInput[] | CuentaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CuentaCreateOrConnectWithoutUsuarioInput | CuentaCreateOrConnectWithoutUsuarioInput[]
    upsert?: CuentaUpsertWithWhereUniqueWithoutUsuarioInput | CuentaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CuentaCreateManyUsuarioInputEnvelope
    set?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    disconnect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    delete?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    connect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    update?: CuentaUpdateWithWhereUniqueWithoutUsuarioInput | CuentaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CuentaUpdateManyWithWhereWithoutUsuarioInput | CuentaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CuentaScalarWhereInput | CuentaScalarWhereInput[]
  }

  export type FavoritoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutUsuarioInput | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutUsuarioInput | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutUsuarioInput | FavoritoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type ListaCompraUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput> | ListaCompraCreateWithoutUsuarioInput[] | ListaCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ListaCompraCreateOrConnectWithoutUsuarioInput | ListaCompraCreateOrConnectWithoutUsuarioInput[]
    upsert?: ListaCompraUpsertWithWhereUniqueWithoutUsuarioInput | ListaCompraUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ListaCompraCreateManyUsuarioInputEnvelope
    set?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    disconnect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    delete?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    connect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    update?: ListaCompraUpdateWithWhereUniqueWithoutUsuarioInput | ListaCompraUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ListaCompraUpdateManyWithWhereWithoutUsuarioInput | ListaCompraUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ListaCompraScalarWhereInput | ListaCompraScalarWhereInput[]
  }

  export type NotificacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type RecetaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput> | RecetaCreateWithoutUsuarioInput[] | RecetaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutUsuarioInput | RecetaCreateOrConnectWithoutUsuarioInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutUsuarioInput | RecetaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RecetaCreateManyUsuarioInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutUsuarioInput | RecetaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutUsuarioInput | RecetaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type ReporteUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput> | ReporteCreateWithoutUsuarioInput[] | ReporteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutUsuarioInput | ReporteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutUsuarioInput | ReporteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ReporteCreateManyUsuarioInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutUsuarioInput | ReporteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutUsuarioInput | ReporteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput> | CalificacionCreateWithoutUsuarioInput[] | CalificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CalificacionCreateOrConnectWithoutUsuarioInput | CalificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: CalificacionUpsertWithWhereUniqueWithoutUsuarioInput | CalificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CalificacionCreateManyUsuarioInputEnvelope
    set?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    disconnect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    delete?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    connect?: CalificacionWhereUniqueInput | CalificacionWhereUniqueInput[]
    update?: CalificacionUpdateWithWhereUniqueWithoutUsuarioInput | CalificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CalificacionUpdateManyWithWhereWithoutUsuarioInput | CalificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type CuentaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput> | CuentaCreateWithoutUsuarioInput[] | CuentaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CuentaCreateOrConnectWithoutUsuarioInput | CuentaCreateOrConnectWithoutUsuarioInput[]
    upsert?: CuentaUpsertWithWhereUniqueWithoutUsuarioInput | CuentaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CuentaCreateManyUsuarioInputEnvelope
    set?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    disconnect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    delete?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    connect?: CuentaWhereUniqueInput | CuentaWhereUniqueInput[]
    update?: CuentaUpdateWithWhereUniqueWithoutUsuarioInput | CuentaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CuentaUpdateManyWithWhereWithoutUsuarioInput | CuentaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CuentaScalarWhereInput | CuentaScalarWhereInput[]
  }

  export type FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutUsuarioInput | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutUsuarioInput | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutUsuarioInput | FavoritoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput> | ListaCompraCreateWithoutUsuarioInput[] | ListaCompraUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ListaCompraCreateOrConnectWithoutUsuarioInput | ListaCompraCreateOrConnectWithoutUsuarioInput[]
    upsert?: ListaCompraUpsertWithWhereUniqueWithoutUsuarioInput | ListaCompraUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ListaCompraCreateManyUsuarioInputEnvelope
    set?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    disconnect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    delete?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    connect?: ListaCompraWhereUniqueInput | ListaCompraWhereUniqueInput[]
    update?: ListaCompraUpdateWithWhereUniqueWithoutUsuarioInput | ListaCompraUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ListaCompraUpdateManyWithWhereWithoutUsuarioInput | ListaCompraUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ListaCompraScalarWhereInput | ListaCompraScalarWhereInput[]
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type RecetaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput> | RecetaCreateWithoutUsuarioInput[] | RecetaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecetaCreateOrConnectWithoutUsuarioInput | RecetaCreateOrConnectWithoutUsuarioInput[]
    upsert?: RecetaUpsertWithWhereUniqueWithoutUsuarioInput | RecetaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RecetaCreateManyUsuarioInputEnvelope
    set?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    disconnect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    delete?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    connect?: RecetaWhereUniqueInput | RecetaWhereUniqueInput[]
    update?: RecetaUpdateWithWhereUniqueWithoutUsuarioInput | RecetaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RecetaUpdateManyWithWhereWithoutUsuarioInput | RecetaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
  }

  export type ReporteUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput> | ReporteCreateWithoutUsuarioInput[] | ReporteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteCreateOrConnectWithoutUsuarioInput | ReporteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ReporteUpsertWithWhereUniqueWithoutUsuarioInput | ReporteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ReporteCreateManyUsuarioInputEnvelope
    set?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    disconnect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    delete?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    connect?: ReporteWhereUniqueInput | ReporteWhereUniqueInput[]
    update?: ReporteUpdateWithWhereUniqueWithoutUsuarioInput | ReporteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ReporteUpdateManyWithWhereWithoutUsuarioInput | ReporteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoIngredienteFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIngrediente | EnumTipoIngredienteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIngredienteFilter<$PrismaModel> | $Enums.TipoIngrediente
  }

  export type NestedEnumTipoIngredienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIngrediente | EnumTipoIngredienteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIngrediente[] | ListEnumTipoIngredienteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIngredienteWithAggregatesFilter<$PrismaModel> | $Enums.TipoIngrediente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoIngredienteFilter<$PrismaModel>
    _max?: NestedEnumTipoIngredienteFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDificultadRecetaFilter<$PrismaModel = never> = {
    equals?: $Enums.DificultadReceta | EnumDificultadRecetaFieldRefInput<$PrismaModel>
    in?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    notIn?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    not?: NestedEnumDificultadRecetaFilter<$PrismaModel> | $Enums.DificultadReceta
  }

  export type NestedEnumDificultadRecetaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DificultadReceta | EnumDificultadRecetaFieldRefInput<$PrismaModel>
    in?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    notIn?: $Enums.DificultadReceta[] | ListEnumDificultadRecetaFieldRefInput<$PrismaModel>
    not?: NestedEnumDificultadRecetaWithAggregatesFilter<$PrismaModel> | $Enums.DificultadReceta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDificultadRecetaFilter<$PrismaModel>
    _max?: NestedEnumDificultadRecetaFilter<$PrismaModel>
  }

  export type NestedEnumNombreSaborFilter<$PrismaModel = never> = {
    equals?: $Enums.NombreSabor | EnumNombreSaborFieldRefInput<$PrismaModel>
    in?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    notIn?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    not?: NestedEnumNombreSaborFilter<$PrismaModel> | $Enums.NombreSabor
  }

  export type NestedEnumNombreSaborWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NombreSabor | EnumNombreSaborFieldRefInput<$PrismaModel>
    in?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    notIn?: $Enums.NombreSabor[] | ListEnumNombreSaborFieldRefInput<$PrismaModel>
    not?: NestedEnumNombreSaborWithAggregatesFilter<$PrismaModel> | $Enums.NombreSabor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNombreSaborFilter<$PrismaModel>
    _max?: NestedEnumNombreSaborFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type RecetaCreateWithoutCalificacionInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutCalificacionInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutCalificacionInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutCalificacionInput, RecetaUncheckedCreateWithoutCalificacionInput>
  }

  export type UsuarioCreateWithoutCalificacionInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCalificacionInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCalificacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCalificacionInput, UsuarioUncheckedCreateWithoutCalificacionInput>
  }

  export type RecetaUpsertWithoutCalificacionInput = {
    update: XOR<RecetaUpdateWithoutCalificacionInput, RecetaUncheckedUpdateWithoutCalificacionInput>
    create: XOR<RecetaCreateWithoutCalificacionInput, RecetaUncheckedCreateWithoutCalificacionInput>
    where?: RecetaWhereInput
  }

  export type RecetaUpdateToOneWithWhereWithoutCalificacionInput = {
    where?: RecetaWhereInput
    data: XOR<RecetaUpdateWithoutCalificacionInput, RecetaUncheckedUpdateWithoutCalificacionInput>
  }

  export type RecetaUpdateWithoutCalificacionInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutCalificacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type UsuarioUpsertWithoutCalificacionInput = {
    update: XOR<UsuarioUpdateWithoutCalificacionInput, UsuarioUncheckedUpdateWithoutCalificacionInput>
    create: XOR<UsuarioCreateWithoutCalificacionInput, UsuarioUncheckedCreateWithoutCalificacionInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCalificacionInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCalificacionInput, UsuarioUncheckedUpdateWithoutCalificacionInput>
  }

  export type UsuarioUpdateWithoutCalificacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCalificacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RecetaCreateWithoutComentarioInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutComentarioInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutComentarioInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutComentarioInput, RecetaUncheckedCreateWithoutComentarioInput>
  }

  export type UsuarioCreateWithoutComentarioInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComentarioInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComentarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentarioInput, UsuarioUncheckedCreateWithoutComentarioInput>
  }

  export type ReporteCreateWithoutComentarioInput = {
    motivo: string
    estado?: string
    fechaReporte?: Date | string
    Receta?: RecetaCreateNestedOneWithoutReporteInput
    Usuario: UsuarioCreateNestedOneWithoutReporteInput
  }

  export type ReporteUncheckedCreateWithoutComentarioInput = {
    id?: number
    usuarioId: number
    recetaId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteCreateOrConnectWithoutComentarioInput = {
    where: ReporteWhereUniqueInput
    create: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput>
  }

  export type ReporteCreateManyComentarioInputEnvelope = {
    data: ReporteCreateManyComentarioInput | ReporteCreateManyComentarioInput[]
    skipDuplicates?: boolean
  }

  export type RecetaUpsertWithoutComentarioInput = {
    update: XOR<RecetaUpdateWithoutComentarioInput, RecetaUncheckedUpdateWithoutComentarioInput>
    create: XOR<RecetaCreateWithoutComentarioInput, RecetaUncheckedCreateWithoutComentarioInput>
    where?: RecetaWhereInput
  }

  export type RecetaUpdateToOneWithWhereWithoutComentarioInput = {
    where?: RecetaWhereInput
    data: XOR<RecetaUpdateWithoutComentarioInput, RecetaUncheckedUpdateWithoutComentarioInput>
  }

  export type RecetaUpdateWithoutComentarioInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutComentarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type UsuarioUpsertWithoutComentarioInput = {
    update: XOR<UsuarioUpdateWithoutComentarioInput, UsuarioUncheckedUpdateWithoutComentarioInput>
    create: XOR<UsuarioCreateWithoutComentarioInput, UsuarioUncheckedCreateWithoutComentarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComentarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComentarioInput, UsuarioUncheckedUpdateWithoutComentarioInput>
  }

  export type UsuarioUpdateWithoutComentarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ReporteUpsertWithWhereUniqueWithoutComentarioInput = {
    where: ReporteWhereUniqueInput
    update: XOR<ReporteUpdateWithoutComentarioInput, ReporteUncheckedUpdateWithoutComentarioInput>
    create: XOR<ReporteCreateWithoutComentarioInput, ReporteUncheckedCreateWithoutComentarioInput>
  }

  export type ReporteUpdateWithWhereUniqueWithoutComentarioInput = {
    where: ReporteWhereUniqueInput
    data: XOR<ReporteUpdateWithoutComentarioInput, ReporteUncheckedUpdateWithoutComentarioInput>
  }

  export type ReporteUpdateManyWithWhereWithoutComentarioInput = {
    where: ReporteScalarWhereInput
    data: XOR<ReporteUpdateManyMutationInput, ReporteUncheckedUpdateManyWithoutComentarioInput>
  }

  export type ReporteScalarWhereInput = {
    AND?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
    OR?: ReporteScalarWhereInput[]
    NOT?: ReporteScalarWhereInput | ReporteScalarWhereInput[]
    id?: IntFilter<"Reporte"> | number
    usuarioId?: IntFilter<"Reporte"> | number
    recetaId?: IntNullableFilter<"Reporte"> | number | null
    comentarioId?: IntNullableFilter<"Reporte"> | number | null
    motivo?: StringFilter<"Reporte"> | string
    estado?: StringFilter<"Reporte"> | string
    fechaReporte?: DateTimeFilter<"Reporte"> | Date | string
  }

  export type UsuarioCreateWithoutCuentaInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCuentaInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCuentaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCuentaInput, UsuarioUncheckedCreateWithoutCuentaInput>
  }

  export type UsuarioUpsertWithoutCuentaInput = {
    update: XOR<UsuarioUpdateWithoutCuentaInput, UsuarioUncheckedUpdateWithoutCuentaInput>
    create: XOR<UsuarioCreateWithoutCuentaInput, UsuarioUncheckedCreateWithoutCuentaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCuentaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCuentaInput, UsuarioUncheckedUpdateWithoutCuentaInput>
  }

  export type UsuarioUpdateWithoutCuentaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCuentaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RecetaCreateWithoutFavoritoInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutFavoritoInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutFavoritoInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutFavoritoInput, RecetaUncheckedCreateWithoutFavoritoInput>
  }

  export type UsuarioCreateWithoutFavoritoInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFavoritoInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFavoritoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFavoritoInput, UsuarioUncheckedCreateWithoutFavoritoInput>
  }

  export type RecetaUpsertWithoutFavoritoInput = {
    update: XOR<RecetaUpdateWithoutFavoritoInput, RecetaUncheckedUpdateWithoutFavoritoInput>
    create: XOR<RecetaCreateWithoutFavoritoInput, RecetaUncheckedCreateWithoutFavoritoInput>
    where?: RecetaWhereInput
  }

  export type RecetaUpdateToOneWithWhereWithoutFavoritoInput = {
    where?: RecetaWhereInput
    data: XOR<RecetaUpdateWithoutFavoritoInput, RecetaUncheckedUpdateWithoutFavoritoInput>
  }

  export type RecetaUpdateWithoutFavoritoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutFavoritoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type UsuarioUpsertWithoutFavoritoInput = {
    update: XOR<UsuarioUpdateWithoutFavoritoInput, UsuarioUncheckedUpdateWithoutFavoritoInput>
    create: XOR<UsuarioCreateWithoutFavoritoInput, UsuarioUncheckedCreateWithoutFavoritoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutFavoritoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutFavoritoInput, UsuarioUncheckedUpdateWithoutFavoritoInput>
  }

  export type UsuarioUpdateWithoutFavoritoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFavoritoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RecetaIngredienteCreateWithoutIngredienteInput = {
    cantidad: string
    Receta: RecetaCreateNestedOneWithoutRecetaIngredienteInput
  }

  export type RecetaIngredienteUncheckedCreateWithoutIngredienteInput = {
    id?: number
    recetaId: number
    cantidad: string
  }

  export type RecetaIngredienteCreateOrConnectWithoutIngredienteInput = {
    where: RecetaIngredienteWhereUniqueInput
    create: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput>
  }

  export type RecetaIngredienteCreateManyIngredienteInputEnvelope = {
    data: RecetaIngredienteCreateManyIngredienteInput | RecetaIngredienteCreateManyIngredienteInput[]
    skipDuplicates?: boolean
  }

  export type RecetaIngredienteUpsertWithWhereUniqueWithoutIngredienteInput = {
    where: RecetaIngredienteWhereUniqueInput
    update: XOR<RecetaIngredienteUpdateWithoutIngredienteInput, RecetaIngredienteUncheckedUpdateWithoutIngredienteInput>
    create: XOR<RecetaIngredienteCreateWithoutIngredienteInput, RecetaIngredienteUncheckedCreateWithoutIngredienteInput>
  }

  export type RecetaIngredienteUpdateWithWhereUniqueWithoutIngredienteInput = {
    where: RecetaIngredienteWhereUniqueInput
    data: XOR<RecetaIngredienteUpdateWithoutIngredienteInput, RecetaIngredienteUncheckedUpdateWithoutIngredienteInput>
  }

  export type RecetaIngredienteUpdateManyWithWhereWithoutIngredienteInput = {
    where: RecetaIngredienteScalarWhereInput
    data: XOR<RecetaIngredienteUpdateManyMutationInput, RecetaIngredienteUncheckedUpdateManyWithoutIngredienteInput>
  }

  export type RecetaIngredienteScalarWhereInput = {
    AND?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
    OR?: RecetaIngredienteScalarWhereInput[]
    NOT?: RecetaIngredienteScalarWhereInput | RecetaIngredienteScalarWhereInput[]
    id?: IntFilter<"RecetaIngrediente"> | number
    recetaId?: IntFilter<"RecetaIngrediente"> | number
    ingredienteId?: IntFilter<"RecetaIngrediente"> | number
    cantidad?: StringFilter<"RecetaIngrediente"> | string
  }

  export type UsuarioCreateWithoutListaCompraInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutListaCompraInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutListaCompraInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutListaCompraInput, UsuarioUncheckedCreateWithoutListaCompraInput>
  }

  export type UsuarioUpsertWithoutListaCompraInput = {
    update: XOR<UsuarioUpdateWithoutListaCompraInput, UsuarioUncheckedUpdateWithoutListaCompraInput>
    create: XOR<UsuarioCreateWithoutListaCompraInput, UsuarioUncheckedCreateWithoutListaCompraInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutListaCompraInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutListaCompraInput, UsuarioUncheckedUpdateWithoutListaCompraInput>
  }

  export type UsuarioUpdateWithoutListaCompraInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutListaCompraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutNotificacionInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutNotificacionInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutNotificacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
  }

  export type UsuarioUpsertWithoutNotificacionInput = {
    update: XOR<UsuarioUpdateWithoutNotificacionInput, UsuarioUncheckedUpdateWithoutNotificacionInput>
    create: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutNotificacionInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutNotificacionInput, UsuarioUncheckedUpdateWithoutNotificacionInput>
  }

  export type UsuarioUpdateWithoutNotificacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutNotificacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CalificacionCreateWithoutRecetaInput = {
    puntuacion: number
    fechaCalificacion?: Date | string
    Usuario: UsuarioCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateWithoutRecetaInput = {
    id?: number
    usuarioId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type CalificacionCreateOrConnectWithoutRecetaInput = {
    where: CalificacionWhereUniqueInput
    create: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput>
  }

  export type CalificacionCreateManyRecetaInputEnvelope = {
    data: CalificacionCreateManyRecetaInput | CalificacionCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutRecetaInput = {
    comentario: string
    fechaComentario?: Date | string
    Usuario: UsuarioCreateNestedOneWithoutComentarioInput
    Reporte?: ReporteCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioUncheckedCreateWithoutRecetaInput = {
    id?: number
    usuarioId: number
    comentario: string
    fechaComentario?: Date | string
    Reporte?: ReporteUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioCreateOrConnectWithoutRecetaInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput>
  }

  export type ComentarioCreateManyRecetaInputEnvelope = {
    data: ComentarioCreateManyRecetaInput | ComentarioCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type FavoritoCreateWithoutRecetaInput = {
    fechaGuardado?: Date | string
    Usuario: UsuarioCreateNestedOneWithoutFavoritoInput
  }

  export type FavoritoUncheckedCreateWithoutRecetaInput = {
    id?: number
    usuarioId: number
    fechaGuardado?: Date | string
  }

  export type FavoritoCreateOrConnectWithoutRecetaInput = {
    where: FavoritoWhereUniqueInput
    create: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput>
  }

  export type FavoritoCreateManyRecetaInputEnvelope = {
    data: FavoritoCreateManyRecetaInput | FavoritoCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type TipoComidaCreateWithoutRecetaInput = {
    nombre: string
  }

  export type TipoComidaUncheckedCreateWithoutRecetaInput = {
    id?: number
    nombre: string
  }

  export type TipoComidaCreateOrConnectWithoutRecetaInput = {
    where: TipoComidaWhereUniqueInput
    create: XOR<TipoComidaCreateWithoutRecetaInput, TipoComidaUncheckedCreateWithoutRecetaInput>
  }

  export type TipoSaborCreateWithoutRecetaInput = {
    nombreSabor: $Enums.NombreSabor
  }

  export type TipoSaborUncheckedCreateWithoutRecetaInput = {
    id?: number
    nombreSabor: $Enums.NombreSabor
  }

  export type TipoSaborCreateOrConnectWithoutRecetaInput = {
    where: TipoSaborWhereUniqueInput
    create: XOR<TipoSaborCreateWithoutRecetaInput, TipoSaborUncheckedCreateWithoutRecetaInput>
  }

  export type UsuarioCreateWithoutRecetaInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRecetaInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRecetaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRecetaInput, UsuarioUncheckedCreateWithoutRecetaInput>
  }

  export type RecetaIngredienteCreateWithoutRecetaInput = {
    cantidad: string
    Ingrediente: IngredienteCreateNestedOneWithoutRecetaIngredienteInput
  }

  export type RecetaIngredienteUncheckedCreateWithoutRecetaInput = {
    id?: number
    ingredienteId: number
    cantidad: string
  }

  export type RecetaIngredienteCreateOrConnectWithoutRecetaInput = {
    where: RecetaIngredienteWhereUniqueInput
    create: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput>
  }

  export type RecetaIngredienteCreateManyRecetaInputEnvelope = {
    data: RecetaIngredienteCreateManyRecetaInput | RecetaIngredienteCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type ReporteCreateWithoutRecetaInput = {
    motivo: string
    estado?: string
    fechaReporte?: Date | string
    Comentario?: ComentarioCreateNestedOneWithoutReporteInput
    Usuario: UsuarioCreateNestedOneWithoutReporteInput
  }

  export type ReporteUncheckedCreateWithoutRecetaInput = {
    id?: number
    usuarioId: number
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteCreateOrConnectWithoutRecetaInput = {
    where: ReporteWhereUniqueInput
    create: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput>
  }

  export type ReporteCreateManyRecetaInputEnvelope = {
    data: ReporteCreateManyRecetaInput | ReporteCreateManyRecetaInput[]
    skipDuplicates?: boolean
  }

  export type CalificacionUpsertWithWhereUniqueWithoutRecetaInput = {
    where: CalificacionWhereUniqueInput
    update: XOR<CalificacionUpdateWithoutRecetaInput, CalificacionUncheckedUpdateWithoutRecetaInput>
    create: XOR<CalificacionCreateWithoutRecetaInput, CalificacionUncheckedCreateWithoutRecetaInput>
  }

  export type CalificacionUpdateWithWhereUniqueWithoutRecetaInput = {
    where: CalificacionWhereUniqueInput
    data: XOR<CalificacionUpdateWithoutRecetaInput, CalificacionUncheckedUpdateWithoutRecetaInput>
  }

  export type CalificacionUpdateManyWithWhereWithoutRecetaInput = {
    where: CalificacionScalarWhereInput
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyWithoutRecetaInput>
  }

  export type CalificacionScalarWhereInput = {
    AND?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
    OR?: CalificacionScalarWhereInput[]
    NOT?: CalificacionScalarWhereInput | CalificacionScalarWhereInput[]
    id?: IntFilter<"Calificacion"> | number
    usuarioId?: IntFilter<"Calificacion"> | number
    recetaId?: IntFilter<"Calificacion"> | number
    puntuacion?: IntFilter<"Calificacion"> | number
    fechaCalificacion?: DateTimeFilter<"Calificacion"> | Date | string
  }

  export type ComentarioUpsertWithWhereUniqueWithoutRecetaInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutRecetaInput, ComentarioUncheckedUpdateWithoutRecetaInput>
    create: XOR<ComentarioCreateWithoutRecetaInput, ComentarioUncheckedCreateWithoutRecetaInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutRecetaInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutRecetaInput, ComentarioUncheckedUpdateWithoutRecetaInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutRecetaInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutRecetaInput>
  }

  export type ComentarioScalarWhereInput = {
    AND?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    OR?: ComentarioScalarWhereInput[]
    NOT?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    id?: IntFilter<"Comentario"> | number
    usuarioId?: IntFilter<"Comentario"> | number
    recetaId?: IntFilter<"Comentario"> | number
    comentario?: StringFilter<"Comentario"> | string
    fechaComentario?: DateTimeFilter<"Comentario"> | Date | string
  }

  export type FavoritoUpsertWithWhereUniqueWithoutRecetaInput = {
    where: FavoritoWhereUniqueInput
    update: XOR<FavoritoUpdateWithoutRecetaInput, FavoritoUncheckedUpdateWithoutRecetaInput>
    create: XOR<FavoritoCreateWithoutRecetaInput, FavoritoUncheckedCreateWithoutRecetaInput>
  }

  export type FavoritoUpdateWithWhereUniqueWithoutRecetaInput = {
    where: FavoritoWhereUniqueInput
    data: XOR<FavoritoUpdateWithoutRecetaInput, FavoritoUncheckedUpdateWithoutRecetaInput>
  }

  export type FavoritoUpdateManyWithWhereWithoutRecetaInput = {
    where: FavoritoScalarWhereInput
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyWithoutRecetaInput>
  }

  export type FavoritoScalarWhereInput = {
    AND?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
    OR?: FavoritoScalarWhereInput[]
    NOT?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
    id?: IntFilter<"Favorito"> | number
    usuarioId?: IntFilter<"Favorito"> | number
    recetaId?: IntFilter<"Favorito"> | number
    fechaGuardado?: DateTimeFilter<"Favorito"> | Date | string
  }

  export type TipoComidaUpsertWithoutRecetaInput = {
    update: XOR<TipoComidaUpdateWithoutRecetaInput, TipoComidaUncheckedUpdateWithoutRecetaInput>
    create: XOR<TipoComidaCreateWithoutRecetaInput, TipoComidaUncheckedCreateWithoutRecetaInput>
    where?: TipoComidaWhereInput
  }

  export type TipoComidaUpdateToOneWithWhereWithoutRecetaInput = {
    where?: TipoComidaWhereInput
    data: XOR<TipoComidaUpdateWithoutRecetaInput, TipoComidaUncheckedUpdateWithoutRecetaInput>
  }

  export type TipoComidaUpdateWithoutRecetaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoComidaUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoSaborUpsertWithoutRecetaInput = {
    update: XOR<TipoSaborUpdateWithoutRecetaInput, TipoSaborUncheckedUpdateWithoutRecetaInput>
    create: XOR<TipoSaborCreateWithoutRecetaInput, TipoSaborUncheckedCreateWithoutRecetaInput>
    where?: TipoSaborWhereInput
  }

  export type TipoSaborUpdateToOneWithWhereWithoutRecetaInput = {
    where?: TipoSaborWhereInput
    data: XOR<TipoSaborUpdateWithoutRecetaInput, TipoSaborUncheckedUpdateWithoutRecetaInput>
  }

  export type TipoSaborUpdateWithoutRecetaInput = {
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
  }

  export type TipoSaborUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreSabor?: EnumNombreSaborFieldUpdateOperationsInput | $Enums.NombreSabor
  }

  export type UsuarioUpsertWithoutRecetaInput = {
    update: XOR<UsuarioUpdateWithoutRecetaInput, UsuarioUncheckedUpdateWithoutRecetaInput>
    create: XOR<UsuarioCreateWithoutRecetaInput, UsuarioUncheckedCreateWithoutRecetaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRecetaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRecetaInput, UsuarioUncheckedUpdateWithoutRecetaInput>
  }

  export type UsuarioUpdateWithoutRecetaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RecetaIngredienteUpsertWithWhereUniqueWithoutRecetaInput = {
    where: RecetaIngredienteWhereUniqueInput
    update: XOR<RecetaIngredienteUpdateWithoutRecetaInput, RecetaIngredienteUncheckedUpdateWithoutRecetaInput>
    create: XOR<RecetaIngredienteCreateWithoutRecetaInput, RecetaIngredienteUncheckedCreateWithoutRecetaInput>
  }

  export type RecetaIngredienteUpdateWithWhereUniqueWithoutRecetaInput = {
    where: RecetaIngredienteWhereUniqueInput
    data: XOR<RecetaIngredienteUpdateWithoutRecetaInput, RecetaIngredienteUncheckedUpdateWithoutRecetaInput>
  }

  export type RecetaIngredienteUpdateManyWithWhereWithoutRecetaInput = {
    where: RecetaIngredienteScalarWhereInput
    data: XOR<RecetaIngredienteUpdateManyMutationInput, RecetaIngredienteUncheckedUpdateManyWithoutRecetaInput>
  }

  export type ReporteUpsertWithWhereUniqueWithoutRecetaInput = {
    where: ReporteWhereUniqueInput
    update: XOR<ReporteUpdateWithoutRecetaInput, ReporteUncheckedUpdateWithoutRecetaInput>
    create: XOR<ReporteCreateWithoutRecetaInput, ReporteUncheckedCreateWithoutRecetaInput>
  }

  export type ReporteUpdateWithWhereUniqueWithoutRecetaInput = {
    where: ReporteWhereUniqueInput
    data: XOR<ReporteUpdateWithoutRecetaInput, ReporteUncheckedUpdateWithoutRecetaInput>
  }

  export type ReporteUpdateManyWithWhereWithoutRecetaInput = {
    where: ReporteScalarWhereInput
    data: XOR<ReporteUpdateManyMutationInput, ReporteUncheckedUpdateManyWithoutRecetaInput>
  }

  export type IngredienteCreateWithoutRecetaIngredienteInput = {
    nombre: string
    Tipo: $Enums.TipoIngrediente
  }

  export type IngredienteUncheckedCreateWithoutRecetaIngredienteInput = {
    id?: number
    nombre: string
    Tipo: $Enums.TipoIngrediente
  }

  export type IngredienteCreateOrConnectWithoutRecetaIngredienteInput = {
    where: IngredienteWhereUniqueInput
    create: XOR<IngredienteCreateWithoutRecetaIngredienteInput, IngredienteUncheckedCreateWithoutRecetaIngredienteInput>
  }

  export type RecetaCreateWithoutRecetaIngredienteInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutRecetaIngredienteInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutRecetaIngredienteInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutRecetaIngredienteInput, RecetaUncheckedCreateWithoutRecetaIngredienteInput>
  }

  export type IngredienteUpsertWithoutRecetaIngredienteInput = {
    update: XOR<IngredienteUpdateWithoutRecetaIngredienteInput, IngredienteUncheckedUpdateWithoutRecetaIngredienteInput>
    create: XOR<IngredienteCreateWithoutRecetaIngredienteInput, IngredienteUncheckedCreateWithoutRecetaIngredienteInput>
    where?: IngredienteWhereInput
  }

  export type IngredienteUpdateToOneWithWhereWithoutRecetaIngredienteInput = {
    where?: IngredienteWhereInput
    data: XOR<IngredienteUpdateWithoutRecetaIngredienteInput, IngredienteUncheckedUpdateWithoutRecetaIngredienteInput>
  }

  export type IngredienteUpdateWithoutRecetaIngredienteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
  }

  export type IngredienteUncheckedUpdateWithoutRecetaIngredienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Tipo?: EnumTipoIngredienteFieldUpdateOperationsInput | $Enums.TipoIngrediente
  }

  export type RecetaUpsertWithoutRecetaIngredienteInput = {
    update: XOR<RecetaUpdateWithoutRecetaIngredienteInput, RecetaUncheckedUpdateWithoutRecetaIngredienteInput>
    create: XOR<RecetaCreateWithoutRecetaIngredienteInput, RecetaUncheckedCreateWithoutRecetaIngredienteInput>
    where?: RecetaWhereInput
  }

  export type RecetaUpdateToOneWithWhereWithoutRecetaIngredienteInput = {
    where?: RecetaWhereInput
    data: XOR<RecetaUpdateWithoutRecetaIngredienteInput, RecetaUncheckedUpdateWithoutRecetaIngredienteInput>
  }

  export type RecetaUpdateWithoutRecetaIngredienteInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutRecetaIngredienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type ComentarioCreateWithoutReporteInput = {
    comentario: string
    fechaComentario?: Date | string
    Receta: RecetaCreateNestedOneWithoutComentarioInput
    Usuario: UsuarioCreateNestedOneWithoutComentarioInput
  }

  export type ComentarioUncheckedCreateWithoutReporteInput = {
    id?: number
    usuarioId: number
    recetaId: number
    comentario: string
    fechaComentario?: Date | string
  }

  export type ComentarioCreateOrConnectWithoutReporteInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutReporteInput, ComentarioUncheckedCreateWithoutReporteInput>
  }

  export type RecetaCreateWithoutReporteInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutReporteInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutReporteInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutReporteInput, RecetaUncheckedCreateWithoutReporteInput>
  }

  export type UsuarioCreateWithoutReporteInput = {
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutReporteInput = {
    id?: number
    nombre: string
    apellidoP: string
    apellidoM?: string | null
    email: string
    contrase_a: string
    fotoPerfil?: string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: Date | string
    nombreUsuario: string
    fechaActualizado: Date | string
    rol?: $Enums.UserRole
    biografia?: string | null
    primerInicioSesion?: boolean
    titulo?: string | null
    verificado?: boolean
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    Cuenta?: CuentaUncheckedCreateNestedManyWithoutUsuarioInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    ListaCompra?: ListaCompraUncheckedCreateNestedManyWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    Receta?: RecetaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutReporteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutReporteInput, UsuarioUncheckedCreateWithoutReporteInput>
  }

  export type ComentarioUpsertWithoutReporteInput = {
    update: XOR<ComentarioUpdateWithoutReporteInput, ComentarioUncheckedUpdateWithoutReporteInput>
    create: XOR<ComentarioCreateWithoutReporteInput, ComentarioUncheckedCreateWithoutReporteInput>
    where?: ComentarioWhereInput
  }

  export type ComentarioUpdateToOneWithWhereWithoutReporteInput = {
    where?: ComentarioWhereInput
    data: XOR<ComentarioUpdateWithoutReporteInput, ComentarioUncheckedUpdateWithoutReporteInput>
  }

  export type ComentarioUpdateWithoutReporteInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutComentarioNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutReporteInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaUpsertWithoutReporteInput = {
    update: XOR<RecetaUpdateWithoutReporteInput, RecetaUncheckedUpdateWithoutReporteInput>
    create: XOR<RecetaCreateWithoutReporteInput, RecetaUncheckedCreateWithoutReporteInput>
    where?: RecetaWhereInput
  }

  export type RecetaUpdateToOneWithWhereWithoutReporteInput = {
    where?: RecetaWhereInput
    data: XOR<RecetaUpdateWithoutReporteInput, RecetaUncheckedUpdateWithoutReporteInput>
  }

  export type RecetaUpdateWithoutReporteInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutReporteInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type UsuarioUpsertWithoutReporteInput = {
    update: XOR<UsuarioUpdateWithoutReporteInput, UsuarioUncheckedUpdateWithoutReporteInput>
    create: XOR<UsuarioCreateWithoutReporteInput, UsuarioUncheckedCreateWithoutReporteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutReporteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutReporteInput, UsuarioUncheckedUpdateWithoutReporteInput>
  }

  export type UsuarioUpdateWithoutReporteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutReporteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidoP?: StringFieldUpdateOperationsInput | string
    apellidoM?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contrase_a?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    preferencias?: NullableJsonNullValueInput | InputJsonValue
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    fechaActualizado?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    biografia?: NullableStringFieldUpdateOperationsInput | string | null
    primerInicioSesion?: BoolFieldUpdateOperationsInput | boolean
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    verificado?: BoolFieldUpdateOperationsInput | boolean
    Calificacion?: CalificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    Cuenta?: CuentaUncheckedUpdateManyWithoutUsuarioNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    ListaCompra?: ListaCompraUncheckedUpdateManyWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    Receta?: RecetaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RecetaCreateWithoutTipoComidaInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutTipoComidaInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutTipoComidaInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput>
  }

  export type RecetaCreateManyTipoComidaInputEnvelope = {
    data: RecetaCreateManyTipoComidaInput | RecetaCreateManyTipoComidaInput[]
    skipDuplicates?: boolean
  }

  export type RecetaUpsertWithWhereUniqueWithoutTipoComidaInput = {
    where: RecetaWhereUniqueInput
    update: XOR<RecetaUpdateWithoutTipoComidaInput, RecetaUncheckedUpdateWithoutTipoComidaInput>
    create: XOR<RecetaCreateWithoutTipoComidaInput, RecetaUncheckedCreateWithoutTipoComidaInput>
  }

  export type RecetaUpdateWithWhereUniqueWithoutTipoComidaInput = {
    where: RecetaWhereUniqueInput
    data: XOR<RecetaUpdateWithoutTipoComidaInput, RecetaUncheckedUpdateWithoutTipoComidaInput>
  }

  export type RecetaUpdateManyWithWhereWithoutTipoComidaInput = {
    where: RecetaScalarWhereInput
    data: XOR<RecetaUpdateManyMutationInput, RecetaUncheckedUpdateManyWithoutTipoComidaInput>
  }

  export type RecetaScalarWhereInput = {
    AND?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
    OR?: RecetaScalarWhereInput[]
    NOT?: RecetaScalarWhereInput | RecetaScalarWhereInput[]
    id?: IntFilter<"Receta"> | number
    usuarioId?: IntFilter<"Receta"> | number
    titulo?: StringFilter<"Receta"> | string
    descripcion?: StringFilter<"Receta"> | string
    tiempoPreparacion?: IntFilter<"Receta"> | number
    porciones?: IntFilter<"Receta"> | number
    imagen?: StringFilter<"Receta"> | string
    fechaCreacion?: DateTimeFilter<"Receta"> | Date | string
    idTipoComida?: IntFilter<"Receta"> | number
    idTipoSabor?: IntFilter<"Receta"> | number
    dificultad?: EnumDificultadRecetaFilter<"Receta"> | $Enums.DificultadReceta
  }

  export type RecetaCreateWithoutTipoSaborInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    Usuario: UsuarioCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutTipoSaborInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutTipoSaborInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput>
  }

  export type RecetaCreateManyTipoSaborInputEnvelope = {
    data: RecetaCreateManyTipoSaborInput | RecetaCreateManyTipoSaborInput[]
    skipDuplicates?: boolean
  }

  export type RecetaUpsertWithWhereUniqueWithoutTipoSaborInput = {
    where: RecetaWhereUniqueInput
    update: XOR<RecetaUpdateWithoutTipoSaborInput, RecetaUncheckedUpdateWithoutTipoSaborInput>
    create: XOR<RecetaCreateWithoutTipoSaborInput, RecetaUncheckedCreateWithoutTipoSaborInput>
  }

  export type RecetaUpdateWithWhereUniqueWithoutTipoSaborInput = {
    where: RecetaWhereUniqueInput
    data: XOR<RecetaUpdateWithoutTipoSaborInput, RecetaUncheckedUpdateWithoutTipoSaborInput>
  }

  export type RecetaUpdateManyWithWhereWithoutTipoSaborInput = {
    where: RecetaScalarWhereInput
    data: XOR<RecetaUpdateManyMutationInput, RecetaUncheckedUpdateManyWithoutTipoSaborInput>
  }

  export type CalificacionCreateWithoutUsuarioInput = {
    puntuacion: number
    fechaCalificacion?: Date | string
    Receta: RecetaCreateNestedOneWithoutCalificacionInput
  }

  export type CalificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    recetaId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type CalificacionCreateOrConnectWithoutUsuarioInput = {
    where: CalificacionWhereUniqueInput
    create: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type CalificacionCreateManyUsuarioInputEnvelope = {
    data: CalificacionCreateManyUsuarioInput | CalificacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutUsuarioInput = {
    comentario: string
    fechaComentario?: Date | string
    Receta: RecetaCreateNestedOneWithoutComentarioInput
    Reporte?: ReporteCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioUncheckedCreateWithoutUsuarioInput = {
    id?: number
    recetaId: number
    comentario: string
    fechaComentario?: Date | string
    Reporte?: ReporteUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type ComentarioCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioCreateManyUsuarioInputEnvelope = {
    data: ComentarioCreateManyUsuarioInput | ComentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CuentaCreateWithoutUsuarioInput = {
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CuentaUncheckedCreateWithoutUsuarioInput = {
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CuentaCreateOrConnectWithoutUsuarioInput = {
    where: CuentaWhereUniqueInput
    create: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput>
  }

  export type CuentaCreateManyUsuarioInputEnvelope = {
    data: CuentaCreateManyUsuarioInput | CuentaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type FavoritoCreateWithoutUsuarioInput = {
    fechaGuardado?: Date | string
    Receta: RecetaCreateNestedOneWithoutFavoritoInput
  }

  export type FavoritoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    recetaId: number
    fechaGuardado?: Date | string
  }

  export type FavoritoCreateOrConnectWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    create: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput>
  }

  export type FavoritoCreateManyUsuarioInputEnvelope = {
    data: FavoritoCreateManyUsuarioInput | FavoritoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ListaCompraCreateWithoutUsuarioInput = {
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
  }

  export type ListaCompraUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
  }

  export type ListaCompraCreateOrConnectWithoutUsuarioInput = {
    where: ListaCompraWhereUniqueInput
    create: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput>
  }

  export type ListaCompraCreateManyUsuarioInputEnvelope = {
    data: ListaCompraCreateManyUsuarioInput | ListaCompraCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type NotificacionCreateWithoutUsuarioInput = {
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionCreateManyUsuarioInputEnvelope = {
    data: NotificacionCreateManyUsuarioInput | NotificacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RecetaCreateWithoutUsuarioInput = {
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoCreateNestedManyWithoutRecetaInput
    TipoComida: TipoComidaCreateNestedOneWithoutRecetaInput
    TipoSabor: TipoSaborCreateNestedOneWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteCreateNestedManyWithoutRecetaInput
  }

  export type RecetaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedCreateNestedManyWithoutRecetaInput
    Comentario?: ComentarioUncheckedCreateNestedManyWithoutRecetaInput
    Favorito?: FavoritoUncheckedCreateNestedManyWithoutRecetaInput
    RecetaIngrediente?: RecetaIngredienteUncheckedCreateNestedManyWithoutRecetaInput
    Reporte?: ReporteUncheckedCreateNestedManyWithoutRecetaInput
  }

  export type RecetaCreateOrConnectWithoutUsuarioInput = {
    where: RecetaWhereUniqueInput
    create: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput>
  }

  export type RecetaCreateManyUsuarioInputEnvelope = {
    data: RecetaCreateManyUsuarioInput | RecetaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ReporteCreateWithoutUsuarioInput = {
    motivo: string
    estado?: string
    fechaReporte?: Date | string
    Comentario?: ComentarioCreateNestedOneWithoutReporteInput
    Receta?: RecetaCreateNestedOneWithoutReporteInput
  }

  export type ReporteUncheckedCreateWithoutUsuarioInput = {
    id?: number
    recetaId?: number | null
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteCreateOrConnectWithoutUsuarioInput = {
    where: ReporteWhereUniqueInput
    create: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput>
  }

  export type ReporteCreateManyUsuarioInputEnvelope = {
    data: ReporteCreateManyUsuarioInput | ReporteCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CalificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CalificacionWhereUniqueInput
    update: XOR<CalificacionUpdateWithoutUsuarioInput, CalificacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CalificacionCreateWithoutUsuarioInput, CalificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type CalificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CalificacionWhereUniqueInput
    data: XOR<CalificacionUpdateWithoutUsuarioInput, CalificacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type CalificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: CalificacionScalarWhereInput
    data: XOR<CalificacionUpdateManyMutationInput, CalificacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CuentaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CuentaWhereUniqueInput
    update: XOR<CuentaUpdateWithoutUsuarioInput, CuentaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CuentaCreateWithoutUsuarioInput, CuentaUncheckedCreateWithoutUsuarioInput>
  }

  export type CuentaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CuentaWhereUniqueInput
    data: XOR<CuentaUpdateWithoutUsuarioInput, CuentaUncheckedUpdateWithoutUsuarioInput>
  }

  export type CuentaUpdateManyWithWhereWithoutUsuarioInput = {
    where: CuentaScalarWhereInput
    data: XOR<CuentaUpdateManyMutationInput, CuentaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CuentaScalarWhereInput = {
    AND?: CuentaScalarWhereInput | CuentaScalarWhereInput[]
    OR?: CuentaScalarWhereInput[]
    NOT?: CuentaScalarWhereInput | CuentaScalarWhereInput[]
    idUsuario?: IntFilter<"Cuenta"> | number
    tipo?: StringFilter<"Cuenta"> | string
    provider?: StringFilter<"Cuenta"> | string
    providerAccountId?: StringFilter<"Cuenta"> | string
    refresh_token?: StringNullableFilter<"Cuenta"> | string | null
    access_token?: StringNullableFilter<"Cuenta"> | string | null
    expires_at?: IntNullableFilter<"Cuenta"> | number | null
    token_type?: StringNullableFilter<"Cuenta"> | string | null
    scope?: StringNullableFilter<"Cuenta"> | string | null
    id_token?: StringNullableFilter<"Cuenta"> | string | null
    session_state?: StringNullableFilter<"Cuenta"> | string | null
    createdAt?: DateTimeFilter<"Cuenta"> | Date | string
    updatedAt?: DateTimeFilter<"Cuenta"> | Date | string
  }

  export type FavoritoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    update: XOR<FavoritoUpdateWithoutUsuarioInput, FavoritoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput>
  }

  export type FavoritoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    data: XOR<FavoritoUpdateWithoutUsuarioInput, FavoritoUncheckedUpdateWithoutUsuarioInput>
  }

  export type FavoritoUpdateManyWithWhereWithoutUsuarioInput = {
    where: FavoritoScalarWhereInput
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ListaCompraUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ListaCompraWhereUniqueInput
    update: XOR<ListaCompraUpdateWithoutUsuarioInput, ListaCompraUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ListaCompraCreateWithoutUsuarioInput, ListaCompraUncheckedCreateWithoutUsuarioInput>
  }

  export type ListaCompraUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ListaCompraWhereUniqueInput
    data: XOR<ListaCompraUpdateWithoutUsuarioInput, ListaCompraUncheckedUpdateWithoutUsuarioInput>
  }

  export type ListaCompraUpdateManyWithWhereWithoutUsuarioInput = {
    where: ListaCompraScalarWhereInput
    data: XOR<ListaCompraUpdateManyMutationInput, ListaCompraUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ListaCompraScalarWhereInput = {
    AND?: ListaCompraScalarWhereInput | ListaCompraScalarWhereInput[]
    OR?: ListaCompraScalarWhereInput[]
    NOT?: ListaCompraScalarWhereInput | ListaCompraScalarWhereInput[]
    id?: IntFilter<"ListaCompra"> | number
    usuarioId?: IntFilter<"ListaCompra"> | number
    nombreIngrediente?: StringFilter<"ListaCompra"> | string
    cantidad?: IntFilter<"ListaCompra"> | number
    fechaCreacion?: DateTimeFilter<"ListaCompra"> | Date | string
  }

  export type NotificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    usuarioId?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    fechaNotificacion?: DateTimeFilter<"Notificacion"> | Date | string
  }

  export type RecetaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RecetaWhereUniqueInput
    update: XOR<RecetaUpdateWithoutUsuarioInput, RecetaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RecetaCreateWithoutUsuarioInput, RecetaUncheckedCreateWithoutUsuarioInput>
  }

  export type RecetaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RecetaWhereUniqueInput
    data: XOR<RecetaUpdateWithoutUsuarioInput, RecetaUncheckedUpdateWithoutUsuarioInput>
  }

  export type RecetaUpdateManyWithWhereWithoutUsuarioInput = {
    where: RecetaScalarWhereInput
    data: XOR<RecetaUpdateManyMutationInput, RecetaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ReporteUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ReporteWhereUniqueInput
    update: XOR<ReporteUpdateWithoutUsuarioInput, ReporteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ReporteCreateWithoutUsuarioInput, ReporteUncheckedCreateWithoutUsuarioInput>
  }

  export type ReporteUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ReporteWhereUniqueInput
    data: XOR<ReporteUpdateWithoutUsuarioInput, ReporteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ReporteUpdateManyWithWhereWithoutUsuarioInput = {
    where: ReporteScalarWhereInput
    data: XOR<ReporteUpdateManyMutationInput, ReporteUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ReporteCreateManyComentarioInput = {
    id?: number
    usuarioId: number
    recetaId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type ReporteUpdateWithoutComentarioInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneWithoutReporteNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReporteNestedInput
  }

  export type ReporteUncheckedUpdateWithoutComentarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteUncheckedUpdateManyWithoutComentarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaIngredienteCreateManyIngredienteInput = {
    id?: number
    recetaId: number
    cantidad: string
  }

  export type RecetaIngredienteUpdateWithoutIngredienteInput = {
    cantidad?: StringFieldUpdateOperationsInput | string
    Receta?: RecetaUpdateOneRequiredWithoutRecetaIngredienteNestedInput
  }

  export type RecetaIngredienteUncheckedUpdateWithoutIngredienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type RecetaIngredienteUncheckedUpdateManyWithoutIngredienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type CalificacionCreateManyRecetaInput = {
    id?: number
    usuarioId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type ComentarioCreateManyRecetaInput = {
    id?: number
    usuarioId: number
    comentario: string
    fechaComentario?: Date | string
  }

  export type FavoritoCreateManyRecetaInput = {
    id?: number
    usuarioId: number
    fechaGuardado?: Date | string
  }

  export type RecetaIngredienteCreateManyRecetaInput = {
    id?: number
    ingredienteId: number
    cantidad: string
  }

  export type ReporteCreateManyRecetaInput = {
    id?: number
    usuarioId: number
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type CalificacionUpdateWithoutRecetaInput = {
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUpdateWithoutRecetaInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutComentarioNestedInput
    Reporte?: ReporteUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Reporte?: ReporteUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateManyWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUpdateWithoutRecetaInput = {
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneRequiredWithoutFavoritoNestedInput
  }

  export type FavoritoUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaIngredienteUpdateWithoutRecetaInput = {
    cantidad?: StringFieldUpdateOperationsInput | string
    Ingrediente?: IngredienteUpdateOneRequiredWithoutRecetaIngredienteNestedInput
  }

  export type RecetaIngredienteUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredienteId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type RecetaIngredienteUncheckedUpdateManyWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredienteId?: IntFieldUpdateOperationsInput | number
    cantidad?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteUpdateWithoutRecetaInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    Comentario?: ComentarioUpdateOneWithoutReporteNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReporteNestedInput
  }

  export type ReporteUncheckedUpdateWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteUncheckedUpdateManyWithoutRecetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaCreateManyTipoComidaInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
  }

  export type RecetaUpdateWithoutTipoComidaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutTipoComidaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateManyWithoutTipoComidaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
  }

  export type RecetaCreateManyTipoSaborInput = {
    id?: number
    usuarioId: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    dificultad: $Enums.DificultadReceta
  }

  export type RecetaUpdateWithoutTipoSaborInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutTipoSaborInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateManyWithoutTipoSaborInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
  }

  export type CalificacionCreateManyUsuarioInput = {
    id?: number
    recetaId: number
    puntuacion: number
    fechaCalificacion?: Date | string
  }

  export type ComentarioCreateManyUsuarioInput = {
    id?: number
    recetaId: number
    comentario: string
    fechaComentario?: Date | string
  }

  export type CuentaCreateManyUsuarioInput = {
    tipo: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type FavoritoCreateManyUsuarioInput = {
    id?: number
    recetaId: number
    fechaGuardado?: Date | string
  }

  export type ListaCompraCreateManyUsuarioInput = {
    id?: number
    nombreIngrediente: string
    cantidad: number
    fechaCreacion?: Date | string
  }

  export type NotificacionCreateManyUsuarioInput = {
    id?: number
    mensaje: string
    leida?: boolean
    fechaNotificacion?: Date | string
  }

  export type RecetaCreateManyUsuarioInput = {
    id?: number
    titulo: string
    descripcion: string
    tiempoPreparacion: number
    porciones: number
    imagen: string
    fechaCreacion?: Date | string
    idTipoComida: number
    idTipoSabor: number
    dificultad: $Enums.DificultadReceta
  }

  export type ReporteCreateManyUsuarioInput = {
    id?: number
    recetaId?: number | null
    comentarioId?: number | null
    motivo: string
    estado?: string
    fechaReporte?: Date | string
  }

  export type CalificacionUpdateWithoutUsuarioInput = {
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutCalificacionNestedInput
  }

  export type CalificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    puntuacion?: IntFieldUpdateOperationsInput | number
    fechaCalificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComentarioUpdateWithoutUsuarioInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutComentarioNestedInput
    Reporte?: ReporteUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    Reporte?: ReporteUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaUpdateWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaUncheckedUpdateWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CuentaUncheckedUpdateManyWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUpdateWithoutUsuarioInput = {
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
    Receta?: RecetaUpdateOneRequiredWithoutFavoritoNestedInput
  }

  export type FavoritoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: IntFieldUpdateOperationsInput | number
    fechaGuardado?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListaCompraUpdateWithoutUsuarioInput = {
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListaCompraUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListaCompraUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreIngrediente?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUpdateWithoutUsuarioInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    fechaNotificacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecetaUpdateWithoutUsuarioInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUpdateManyWithoutRecetaNestedInput
    TipoComida?: TipoComidaUpdateOneRequiredWithoutRecetaNestedInput
    TipoSabor?: TipoSaborUpdateOneRequiredWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
    Calificacion?: CalificacionUncheckedUpdateManyWithoutRecetaNestedInput
    Comentario?: ComentarioUncheckedUpdateManyWithoutRecetaNestedInput
    Favorito?: FavoritoUncheckedUpdateManyWithoutRecetaNestedInput
    RecetaIngrediente?: RecetaIngredienteUncheckedUpdateManyWithoutRecetaNestedInput
    Reporte?: ReporteUncheckedUpdateManyWithoutRecetaNestedInput
  }

  export type RecetaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tiempoPreparacion?: IntFieldUpdateOperationsInput | number
    porciones?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    idTipoComida?: IntFieldUpdateOperationsInput | number
    idTipoSabor?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumDificultadRecetaFieldUpdateOperationsInput | $Enums.DificultadReceta
  }

  export type ReporteUpdateWithoutUsuarioInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
    Comentario?: ComentarioUpdateOneWithoutReporteNestedInput
    Receta?: RecetaUpdateOneWithoutReporteNestedInput
  }

  export type ReporteUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    recetaId?: NullableIntFieldUpdateOperationsInput | number | null
    comentarioId?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaReporte?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}